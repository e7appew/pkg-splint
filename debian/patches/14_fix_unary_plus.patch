From: Carlos Maddela <e7appew@gmail.com>
Date: Thu, 23 Mar 2017 00:14:09 +1100
Subject: Cherry-pick unreleased fix for parsing unary plus.

Description: Cherry-pick unreleased fix for parsing unary plus.
 Fix tracker issue 1837229.
 Synopsis: return +1;
 .
 The XPR_PREOP case treats plus/minus the same now.  I don't grok how unary
 values are being handled in splint, but at least +/- are the same.
Author: Bill Pringlemeir <bpringle@sympatico.ca>
Origin: upstream, https://github.com/ravenexp/splint/commit/1fbe73013b8d03274314e763f0a54e944e018bb7
Bug: https://sourceforge.net/p/splint/bugs/2/
Bug-Debian: https://bugs.debian.org/462375
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
---
 src/Headers/cgrammar_tokens.h  |    6 +-
 src/Headers/llgrammar_gen.h    |    6 +-
 src/Headers/llgrammar_gen2.h   |    6 +-
 src/Headers/mtgrammar_tokens.h |  214 ++-
 src/Headers/signature_gen.h    |    6 +-
 src/Makefile.am                |    2 +-
 src/cgrammar.c.der             | 1208 ++++++++---------
 src/constraintGeneration.c     |    4 +
 src/llgrammar.c.der            |  744 +++++------
 src/mtgrammar.c                | 2833 +++++++++++++++++++++++++---------------
 src/mtgrammar.c.der            | 2833 +++++++++++++++++++++++++---------------
 src/signature.c.der            |   90 +-
 12 files changed, 4710 insertions(+), 3242 deletions(-)

diff --git a/src/Headers/cgrammar_tokens.h b/src/Headers/cgrammar_tokens.h
index 4b838a3..7d1edd9 100644
--- a/src/Headers/cgrammar_tokens.h
+++ b/src/Headers/cgrammar_tokens.h
@@ -494,7 +494,7 @@
 
 #if ! defined cgrammar_YYSTYPE && ! defined cgrammar_YYSTYPE_IS_DECLARED
 typedef union cgrammar_YYSTYPE
-
+#line 81 "cgrammar.y"
 {
   lltok tok;
   int count;
@@ -544,8 +544,8 @@ typedef union cgrammar_YYSTYPE
   constraintExpr conE;
   /* drl */  
 }
-/* Line 1529 of yacc.c.  */
-
+/* Line 1489 of yacc.c.  */
+#line 491 "cgrammar.tab.h"
 	cgrammar_YYSTYPE;
 # define yystype cgrammar_YYSTYPE /* obsolescent; will be withdrawn */
 # define cgrammar_YYSTYPE_IS_DECLARED 1
diff --git a/src/Headers/llgrammar_gen.h b/src/Headers/llgrammar_gen.h
index 955da8e..7544a9e 100644
--- a/src/Headers/llgrammar_gen.h
+++ b/src/Headers/llgrammar_gen.h
@@ -374,7 +374,7 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
+#line 72 "llgrammar.y"
 {
   ltoken ltok;  /* a leaf is also an ltoken */
   qual typequal;
@@ -441,8 +441,8 @@ typedef union YYSTYPE
   /*@only@*/ CTypesNode ctypes;
   /*@-redef@*/
 }
-/* Line 1529 of yacc.c.  */
-
+/* Line 1489 of yacc.c.  */
+#line 388 "llgrammar.tab.h"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
diff --git a/src/Headers/llgrammar_gen2.h b/src/Headers/llgrammar_gen2.h
index 955da8e..7544a9e 100644
--- a/src/Headers/llgrammar_gen2.h
+++ b/src/Headers/llgrammar_gen2.h
@@ -374,7 +374,7 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
+#line 72 "llgrammar.y"
 {
   ltoken ltok;  /* a leaf is also an ltoken */
   qual typequal;
@@ -441,8 +441,8 @@ typedef union YYSTYPE
   /*@only@*/ CTypesNode ctypes;
   /*@-redef@*/
 }
-/* Line 1529 of yacc.c.  */
-
+/* Line 1489 of yacc.c.  */
+#line 388 "llgrammar.tab.h"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
diff --git a/src/Headers/mtgrammar_tokens.h b/src/Headers/mtgrammar_tokens.h
index c4806b3..b37faa8 100644
--- a/src/Headers/mtgrammar_tokens.h
+++ b/src/Headers/mtgrammar_tokens.h
@@ -52,13 +52,156 @@
 /*drl added 12/11/2002*/
 /*@-type@*/
 
+/*@-enummemuse@*/
+
 /* < end of bison.head > */
 
-#ifndef BISON_MTGRAMMAR_TAB_H
-# define BISON_MTGRAMMAR_TAB_H
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-#ifndef YYSTYPE
-typedef union {
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     MT_BADTOK = 258,
+     MT_END = 259,
+     MT_STATE = 260,
+     MT_GLOBAL = 261,
+     MT_CONTEXT = 262,
+     MT_ONEOF = 263,
+     MT_DEFAULTS = 264,
+     MT_DEFAULT = 265,
+     MT_REFERENCE = 266,
+     MT_PARAMETER = 267,
+     MT_RESULT = 268,
+     MT_CLAUSE = 269,
+     MT_LITERAL = 270,
+     MT_NULL = 271,
+     MT_ANNOTATIONS = 272,
+     MT_ARROW = 273,
+     MT_MERGE = 274,
+     MT_TRANSFERS = 275,
+     MT_PRECONDITIONS = 276,
+     MT_POSTCONDITIONS = 277,
+     MT_LOSEREFERENCE = 278,
+     MT_AS = 279,
+     MT_ERROR = 280,
+     MT_PLUS = 281,
+     MT_STAR = 282,
+     MT_BAR = 283,
+     MT_LPAREN = 284,
+     MT_RPAREN = 285,
+     MT_LBRACKET = 286,
+     MT_RBRACKET = 287,
+     MT_LBRACE = 288,
+     MT_RBRACE = 289,
+     MT_COMMA = 290,
+     MT_CHAR = 291,
+     MT_INT = 292,
+     MT_FLOAT = 293,
+     MT_DOUBLE = 294,
+     MT_VOID = 295,
+     MT_ANYTYPE = 296,
+     MT_INTEGRALTYPE = 297,
+     MT_UNSIGNEDINTEGRALTYPE = 298,
+     MT_SIGNEDINTEGRALTYPE = 299,
+     MT_CONST = 300,
+     MT_VOLATILE = 301,
+     MT_RESTRICT = 302,
+     MT_STRINGLIT = 303,
+     MT_IDENT = 304
+   };
+#endif
+/* Tokens.  */
+#define MT_BADTOK 258
+#define MT_END 259
+#define MT_STATE 260
+#define MT_GLOBAL 261
+#define MT_CONTEXT 262
+#define MT_ONEOF 263
+#define MT_DEFAULTS 264
+#define MT_DEFAULT 265
+#define MT_REFERENCE 266
+#define MT_PARAMETER 267
+#define MT_RESULT 268
+#define MT_CLAUSE 269
+#define MT_LITERAL 270
+#define MT_NULL 271
+#define MT_ANNOTATIONS 272
+#define MT_ARROW 273
+#define MT_MERGE 274
+#define MT_TRANSFERS 275
+#define MT_PRECONDITIONS 276
+#define MT_POSTCONDITIONS 277
+#define MT_LOSEREFERENCE 278
+#define MT_AS 279
+#define MT_ERROR 280
+#define MT_PLUS 281
+#define MT_STAR 282
+#define MT_BAR 283
+#define MT_LPAREN 284
+#define MT_RPAREN 285
+#define MT_LBRACKET 286
+#define MT_RBRACKET 287
+#define MT_LBRACE 288
+#define MT_RBRACE 289
+#define MT_COMMA 290
+#define MT_CHAR 291
+#define MT_INT 292
+#define MT_FLOAT 293
+#define MT_DOUBLE 294
+#define MT_VOID 295
+#define MT_ANYTYPE 296
+#define MT_INTEGRALTYPE 297
+#define MT_UNSIGNEDINTEGRALTYPE 298
+#define MT_SIGNEDINTEGRALTYPE 299
+#define MT_CONST 300
+#define MT_VOLATILE 301
+#define MT_RESTRICT 302
+#define MT_STRINGLIT 303
+#define MT_IDENT 304
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 62 "mtgrammar.y"
+{
   mttok tok; 
   mtDeclarationNode mtdecl;
   mtDeclarationPiece mtpiece;
@@ -85,60 +228,17 @@ typedef union {
   /*@only@*/ qtype qtyp;
   qual qual;
   qualList quals;
-} yystype;
-# define YYSTYPE yystype
+}
+/* Line 1489 of yacc.c.  */
+#line 176 "mtgrammar.tab.h"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
 #endif
-# define	MT_BADTOK	257
-# define	MT_END	258
-# define	MT_STATE	259
-# define	MT_GLOBAL	260
-# define	MT_CONTEXT	261
-# define	MT_ONEOF	262
-# define	MT_DEFAULTS	263
-# define	MT_DEFAULT	264
-# define	MT_REFERENCE	265
-# define	MT_PARAMETER	266
-# define	MT_RESULT	267
-# define	MT_CLAUSE	268
-# define	MT_LITERAL	269
-# define	MT_NULL	270
-# define	MT_ANNOTATIONS	271
-# define	MT_ARROW	272
-# define	MT_MERGE	273
-# define	MT_TRANSFERS	274
-# define	MT_PRECONDITIONS	275
-# define	MT_POSTCONDITIONS	276
-# define	MT_LOSEREFERENCE	277
-# define	MT_AS	278
-# define	MT_ERROR	279
-# define	MT_PLUS	280
-# define	MT_STAR	281
-# define	MT_BAR	282
-# define	MT_LPAREN	283
-# define	MT_RPAREN	284
-# define	MT_LBRACKET	285
-# define	MT_RBRACKET	286
-# define	MT_LBRACE	287
-# define	MT_RBRACE	288
-# define	MT_COMMA	289
-# define	MT_CHAR	290
-# define	MT_INT	291
-# define	MT_FLOAT	292
-# define	MT_DOUBLE	293
-# define	MT_VOID	294
-# define	MT_ANYTYPE	295
-# define	MT_INTEGRALTYPE	296
-# define	MT_UNSIGNEDINTEGRALTYPE	297
-# define	MT_SIGNEDINTEGRALTYPE	298
-# define	MT_CONST	299
-# define	MT_VOLATILE	300
-# define	MT_RESTRICT	301
-# define	MT_STRINGLIT	302
-# define	MT_IDENT	303
-
-
-#endif /* not BISON_MTGRAMMAR_TAB_H */
+
+
+
 /*
 ** Resets all flags in bison.head
 */
@@ -189,3 +289,5 @@ typedef union {
 
 /*drl added 12/11/2002*/
 /*@=type@*/
+
+/*@=enummemuse@*/
diff --git a/src/Headers/signature_gen.h b/src/Headers/signature_gen.h
index 078d0f0..d7e5242 100644
--- a/src/Headers/signature_gen.h
+++ b/src/Headers/signature_gen.h
@@ -196,7 +196,7 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
+#line 71 "signature.y"
 {
   ltoken ltok;  /* a leaf is also an ltoken */
   unsigned int count;
@@ -208,8 +208,8 @@ typedef union YYSTYPE
   /*@only@*/  lslOpList operators;
   /*@-redef@*/ /*@-matchfields@*/ 
 }
-/* Line 1529 of yacc.c.  */
-
+/* Line 1489 of yacc.c.  */
+#line 155 "signature.tab.h"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
diff --git a/src/Makefile.am b/src/Makefile.am
index 50bce91..2323a16 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -10,7 +10,7 @@ CHECK = 1
 # Some preferences
 ### We use the no-lines option to prevent confusion with splint flag settings.
 ### Should fix splint to avoid this...
-YFLAGS = -v -t -d --debug --no-lines
+YFLAGS = -v -t -d --debug
 LFLAGS = -L
 
 BISON_SRC = cgrammar.y  llgrammar.y  mtgrammar.y  signature.y
diff --git a/src/cgrammar.c.der b/src/cgrammar.c.der
index 061da3a..e4cdac4 100644
--- a/src/cgrammar.c.der
+++ b/src/cgrammar.c.der
@@ -520,7 +520,7 @@
 
 
 /* Copy the first part of user declarations.  */
-
+#line 24 "cgrammar.y"
 
 /*
 **
@@ -597,7 +597,7 @@ extern void yyerror (char *);
 
 #if ! defined cgrammar_YYSTYPE && ! defined cgrammar_YYSTYPE_IS_DECLARED
 typedef union cgrammar_YYSTYPE
-
+#line 81 "cgrammar.y"
 {
   lltok tok;
   int count;
@@ -647,8 +647,8 @@ typedef union cgrammar_YYSTYPE
   constraintExpr conE;
   /* drl */  
 }
-/* Line 193 of yacc.c.  */
-
+/* Line 187 of yacc.c.  */
+#line 594 "cgrammar.tab.c"
 	cgrammar_YYSTYPE;
 # define yystype cgrammar_YYSTYPE /* obsolescent; will be withdrawn */
 # define cgrammar_YYSTYPE_IS_DECLARED 1
@@ -661,7 +661,7 @@ typedef union cgrammar_YYSTYPE
 
 
 /* Line 216 of yacc.c.  */
-
+#line 607 "cgrammar.tab.c"
 
 #ifdef short
 # undef short
@@ -4272,72 +4272,72 @@ yyreduce:
   switch (yyn)
     {
         case 4:
-
+#line 333 "cgrammar.y"
     { context_checkGlobalScope (); ;}
     break;
 
   case 5:
-
+#line 334 "cgrammar.y"
     { context_checkGlobalScope (); ;}
     break;
 
   case 6:
-
+#line 338 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 7:
-
+#line 339 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 8:
-
+#line 340 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 9:
-
+#line 341 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 10:
-
+#line 342 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 11:
-
+#line 343 "cgrammar.y"
     { uentry_checkDecl (); exprNode_free ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 12:
-
+#line 344 "cgrammar.y"
     { uentry_clearDecl (); lltok_free ((yyvsp[(1) - (1)].tok)); /* evans 2002-02-08: okay to have a null statement */ ;}
     break;
 
   case 13:
-
+#line 345 "cgrammar.y"
     { uentry_clearDecl (); ;}
     break;
 
   case 14:
-
+#line 350 "cgrammar.y"
     { checkConstant ((yyvsp[(2) - (8)].qtyp), (yyvsp[(4) - (8)].ntyp)); lltok_free2 ((yyvsp[(1) - (8)].tok), (yyvsp[(8) - (8)].tok)); ;}
     break;
 
   case 15:
-
+#line 352 "cgrammar.y"
     { checkValueConstant ((yyvsp[(2) - (11)].qtyp), (yyvsp[(4) - (11)].ntyp), (yyvsp[(8) - (11)].expr)); lltok_free3 ((yyvsp[(1) - (11)].tok), (yyvsp[(6) - (11)].tok), (yyvsp[(11) - (11)].tok)); ;}
     break;
 
   case 16:
-
+#line 356 "cgrammar.y"
     { context_enterFunctionHeader (); ;}
     break;
 
   case 17:
-
+#line 357 "cgrammar.y"
     { 
      declareStaticFunction ((yyvsp[(3) - (5)].ntyp)); context_quietExitFunction (); 
      context_exitFunctionHeader (); 
@@ -4346,7 +4346,7 @@ yyreduce:
     break;
 
   case 18:
-
+#line 366 "cgrammar.y"
     { 
      qtype qint = qtype_create (ctype_int);
      (yyval.ntyp) = idDecl_fixBase ((yyvsp[(1) - (1)].ntyp), qint);
@@ -4355,32 +4355,32 @@ yyreduce:
     break;
 
   case 19:
-
+#line 372 "cgrammar.y"
     { (yyval.ntyp) = idDecl_fixBase ((yyvsp[(3) - (3)].ntyp), (yyvsp[(1) - (3)].qtyp)); ;}
     break;
 
   case 21:
-
+#line 378 "cgrammar.y"
     { (yyval.ntyp) = (yyvsp[(2) - (2)].ntyp); qtype_adjustPointers ((yyvsp[(1) - (2)].pointers), idDecl_getTyp ((yyval.ntyp))); ;}
     break;
 
   case 22:
-
+#line 382 "cgrammar.y"
     { (yyval.ntyp) = idDecl_create ((yyvsp[(1) - (1)].cname), qtype_unknown ()); ;}
     break;
 
   case 23:
-
+#line 384 "cgrammar.y"
     { (yyval.ntyp) = idDecl_expectFunction ((yyvsp[(4) - (6)].ntyp)); lltok_free2 ((yyvsp[(2) - (6)].tok), (yyvsp[(6) - (6)].tok)); ;}
     break;
 
   case 24:
-
+#line 386 "cgrammar.y"
     { (yyval.ntyp) = idDecl_replaceCtype ((yyvsp[(1) - (3)].ntyp), ctype_makeInnerArray (idDecl_getCtype ((yyvsp[(1) - (3)].ntyp)))); lltok_free2 ((yyvsp[(2) - (3)].tok), (yyvsp[(3) - (3)].tok)); ;}
     break;
 
   case 25:
-
+#line 388 "cgrammar.y"
     {
      exprNode_findValue ((yyvsp[(4) - (6)].expr));
      idDecl_notExpectingFunction ((yyvsp[(1) - (6)].ntyp));
@@ -4400,12 +4400,12 @@ yyreduce:
     break;
 
   case 26:
-
+#line 405 "cgrammar.y"
     { setCurrentParams (uentryList_missingParams); ;}
     break;
 
   case 27:
-
+#line 407 "cgrammar.y"
     { /* need to support globals and modifies here! */
      functionClauseList fcl;
      ctype ct = ctype_makeFunction (idDecl_getCtype ((yyvsp[(1) - (6)].ntyp)), 
@@ -4437,12 +4437,12 @@ yyreduce:
     break;
 
   case 28:
-
+#line 436 "cgrammar.y"
     { setCurrentParams ((yyvsp[(4) - (5)].entrylist)); ;}
     break;
 
   case 29:
-
+#line 438 "cgrammar.y"
     {
      functionClauseList fcl;
      setImplicitfcnConstraints ();
@@ -4470,24 +4470,24 @@ yyreduce:
     break;
 
   case 30:
-
+#line 465 "cgrammar.y"
     { (yyval.ntyp) = idDecl_create ((yyvsp[(1) - (1)].cname), qtype_unknown ()); ;}
     break;
 
   case 31:
-
+#line 467 "cgrammar.y"
     { (yyval.ntyp) = idDecl_expectFunction ((yyvsp[(4) - (6)].ntyp)); lltok_free2 ((yyvsp[(2) - (6)].tok), (yyvsp[(6) - (6)].tok)); ;}
     break;
 
   case 32:
-
+#line 469 "cgrammar.y"
     { (yyval.ntyp) = idDecl_replaceCtype ((yyvsp[(1) - (3)].ntyp), ctype_makeInnerArray (idDecl_getCtype ((yyvsp[(1) - (3)].ntyp)))); 
      lltok_free2 ((yyvsp[(2) - (3)].tok), (yyvsp[(3) - (3)].tok)); 
    ;}
     break;
 
   case 33:
-
+#line 473 "cgrammar.y"
     { 
      int value;
 
@@ -4507,12 +4507,12 @@ yyreduce:
     break;
 
   case 34:
-
+#line 490 "cgrammar.y"
     { setCurrentParams (uentryList_missingParams); ;}
     break;
 
   case 35:
-
+#line 492 "cgrammar.y"
     {
      ctype ct = ctype_makeFunction (idDecl_getCtype ((yyvsp[(1) - (6)].ntyp)), 
 				    uentryList_makeMissingParams ());
@@ -4525,12 +4525,12 @@ yyreduce:
     break;
 
   case 36:
-
+#line 502 "cgrammar.y"
     { setCurrentParams ((yyvsp[(4) - (5)].entrylist)); ;}
     break;
 
   case 37:
-
+#line 504 "cgrammar.y"
     { 
      clearCurrentParams ();
      (yyval.ntyp) = idDecl_replaceCtype ((yyvsp[(1) - (7)].ntyp), ctype_makeFunction (idDecl_getCtype ((yyvsp[(1) - (7)].ntyp)), (yyvsp[(4) - (7)].entrylist)));
@@ -4542,59 +4542,59 @@ yyreduce:
     break;
 
   case 38:
-
+#line 516 "cgrammar.y"
     { setCurrentParams ((yyvsp[(4) - (5)].entrylist)); ;}
     break;
 
   case 39:
-
+#line 517 "cgrammar.y"
     { clearCurrentParams (); ;}
     break;
 
   case 40:
-
+#line 518 "cgrammar.y"
     { declareCIter ((yyvsp[(2) - (10)].cname), (yyvsp[(4) - (10)].entrylist)); 
      lltok_free3 ((yyvsp[(1) - (10)].tok), (yyvsp[(3) - (10)].tok), (yyvsp[(5) - (10)].tok)); 
    ;}
     break;
 
   case 41:
-
+#line 524 "cgrammar.y"
     { exprNode_checkMacroBody ((yyvsp[(2) - (3)].expr)); lltok_free2 ((yyvsp[(1) - (3)].tok), (yyvsp[(3) - (3)].tok)); ;}
     break;
 
   case 42:
-
+#line 525 "cgrammar.y"
     { exprNode_checkIterBody ((yyvsp[(2) - (3)].expr)); lltok_free2 ((yyvsp[(1) - (3)].tok), (yyvsp[(3) - (3)].tok)); ;}
     break;
 
   case 43:
-
+#line 526 "cgrammar.y"
     { exprNode_checkIterEnd ((yyvsp[(2) - (3)].expr)); lltok_free2 ((yyvsp[(1) - (3)].tok), (yyvsp[(3) - (3)].tok));;}
     break;
 
   case 44:
-
+#line 527 "cgrammar.y"
     { exprChecks_checkEmptyMacroBody (); lltok_free2 ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 45:
-
+#line 531 "cgrammar.y"
     { clabstract_declareFunction ((yyvsp[(1) - (1)].ntyp)); ;}
     break;
 
   case 46:
-
+#line 536 "cgrammar.y"
     { (yyval.msconstraint) = metaStateConstraint_create ((yyvsp[(1) - (3)].msspec), (yyvsp[(3) - (3)].msexpr)); lltok_free ((yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 47:
-
+#line 540 "cgrammar.y"
     { cscannerHelp_expectingMetaStateName (); ;}
     break;
 
   case 48:
-
+#line 541 "cgrammar.y"
     { cscannerHelp_clearExpectingMetaStateName ();
       (yyval.msspec) = metaStateSpecifier_create ((yyvsp[(1) - (4)].sr), (yyvsp[(4) - (4)].msinfo)); 
       lltok_free ((yyvsp[(3) - (4)].tok)); 
@@ -4602,12 +4602,12 @@ yyreduce:
     break;
 
   case 49:
-
+#line 545 "cgrammar.y"
     { cscannerHelp_expectingMetaStateName (); ;}
     break;
 
   case 50:
-
+#line 546 "cgrammar.y"
     { cscannerHelp_clearExpectingMetaStateName ();
       (yyval.msspec) = metaStateSpecifier_createElipsis ((yyvsp[(4) - (4)].msinfo)); 
       lltok_free2 ((yyvsp[(1) - (4)].tok), (yyvsp[(3) - (4)].tok));
@@ -4615,71 +4615,71 @@ yyreduce:
     break;
 
   case 51:
-
+#line 553 "cgrammar.y"
     { (yyval.msexpr) = metaStateExpression_create ((yyvsp[(1) - (1)].msspec)); ;}
     break;
 
   case 52:
-
+#line 554 "cgrammar.y"
     { (yyval.msexpr) = metaStateExpression_createMerge ((yyvsp[(1) - (3)].msspec), (yyvsp[(3) - (3)].msexpr)); lltok_free ((yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 56:
-
+#line 569 "cgrammar.y"
     { (yyval.conL) = constraintList_add ((yyvsp[(3) - (3)].conL), (yyvsp[(1) - (3)].con)); ;}
     break;
 
   case 57:
-
+#line 570 "cgrammar.y"
     { (yyval.conL) = constraintList_single ((yyvsp[(1) - (1)].con)); ;}
     break;
 
   case 58:
-
+#line 574 "cgrammar.y"
     {
  (yyval.con) = makeConstraintParse3 ((yyvsp[(1) - (3)].conE), (yyvsp[(2) - (3)].tok), (yyvsp[(3) - (3)].conE));
  DPRINTF(("Done BufConstraint1\n")); ;}
     break;
 
   case 65:
-
+#line 592 "cgrammar.y"
     {(yyval.conE) = constraintExpr_parseMakeUnaryOp ((yyvsp[(1) - (4)].tok), (yyvsp[(3) - (4)].conE));  DPRINTF( ("Got BufConstraintExpr UNary Op ") ); ;}
     break;
 
   case 66:
-
+#line 593 "cgrammar.y"
     {
    DPRINTF( ("Got BufConstraintExpr BINary Op ") );
    (yyval.conE) = constraintExpr_parseMakeBinaryOp ((yyvsp[(2) - (5)].conE), (yyvsp[(3) - (5)].tok), (yyvsp[(4) - (5)].conE)); ;}
     break;
 
   case 67:
-
+#line 599 "cgrammar.y"
     { (yyval.conE) =  constraintExpr_makeTermsRef ((yyvsp[(1) - (1)].sr));;}
     break;
 
   case 68:
-
+#line 600 "cgrammar.y"
     { (yyval.conE) = constraintExpr_makeIntLiteral (exprNode_getLongValue ((yyvsp[(1) - (1)].expr))); ;}
     break;
 
   case 69:
-
+#line 605 "cgrammar.y"
     { /*@-onlytrans@*/ (yyval.sr) = checkbufferConstraintClausesId ((yyvsp[(1) - (1)].entry)); /*@=onlytrans@*/ /*@i523@*/ ;}
     break;
 
   case 70:
-
+#line 607 "cgrammar.y"
     { (yyval.sr) = fixStateClausesId ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 71:
-
+#line 609 "cgrammar.y"
     { (yyval.sr) = sRef_makeAnyArrayFetch ((yyvsp[(1) - (3)].sr)); ;}
     break;
 
   case 72:
-
+#line 611 "cgrammar.y"
     {
     /*
     char *t; int c; 
@@ -4691,117 +4691,117 @@ yyreduce:
     break;
 
   case 73:
-
+#line 620 "cgrammar.y"
     { (yyval.sr) = sRef_constructPointer ((yyvsp[(2) - (2)].sr)); ;}
     break;
 
   case 74:
-
+#line 622 "cgrammar.y"
     { (yyval.sr) = (yyvsp[(2) - (3)].sr); ;}
     break;
 
   case 75:
-
+#line 624 "cgrammar.y"
     { cstring_markOwned ((yyvsp[(3) - (3)].cname)); (yyval.sr) = sRef_buildField ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 76:
-
+#line 626 "cgrammar.y"
     { cstring_markOwned ((yyvsp[(3) - (3)].cname)); (yyval.sr) = sRef_makeArrow ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 80:
-
+#line 654 "cgrammar.y"
     { (yyval.funcclauselist) = functionClauseList_new (); ;}
     break;
 
   case 81:
-
+#line 656 "cgrammar.y"
     { (yyval.funcclauselist) = functionClauseList_prepend ((yyvsp[(2) - (2)].funcclauselist), (yyvsp[(1) - (2)].funcclause)); ;}
     break;
 
   case 82:
-
+#line 665 "cgrammar.y"
     { (yyval.funcclauselist) = functionClauseList_new (); ;}
     break;
 
   case 83:
-
+#line 667 "cgrammar.y"
     { (yyval.funcclauselist) = functionClauseList_prepend ((yyvsp[(2) - (2)].funcclauselist), (yyvsp[(1) - (2)].funcclause)); ;}
     break;
 
   case 84:
-
+#line 671 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createGlobals ((yyvsp[(1) - (1)].globsclause)); ;}
     break;
 
   case 85:
-
+#line 672 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createModifies ((yyvsp[(1) - (1)].modsclause)); ;}
     break;
 
   case 86:
-
+#line 673 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createModifies ((yyvsp[(1) - (1)].modsclause)); ;}
     break;
 
   case 87:
-
+#line 674 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createState ((yyvsp[(1) - (1)].stateclause)); ;}
     break;
 
   case 88:
-
+#line 675 "cgrammar.y"
     { (yyval.funcclause) = (yyvsp[(1) - (1)].funcclause); ;}
     break;
 
   case 89:
-
+#line 676 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createWarn ((yyvsp[(1) - (1)].warnclause)); ;}
     break;
 
   case 90:
-
+#line 680 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createGlobals ((yyvsp[(1) - (1)].globsclause)); ;}
     break;
 
   case 91:
-
+#line 681 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createModifies ((yyvsp[(1) - (1)].modsclause)); ;}
     break;
 
   case 92:
-
+#line 682 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createModifies ((yyvsp[(1) - (1)].modsclause)); ;}
     break;
 
   case 93:
-
+#line 683 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createState ((yyvsp[(1) - (1)].stateclause)); ;}
     break;
 
   case 94:
-
+#line 684 "cgrammar.y"
     { (yyval.funcclause) = (yyvsp[(1) - (1)].funcclause); ;}
     break;
 
   case 95:
-
+#line 685 "cgrammar.y"
     { (yyval.funcclause) = functionClause_createWarn ((yyvsp[(1) - (1)].warnclause)); ;}
     break;
 
   case 96:
-
+#line 689 "cgrammar.y"
     { (yyval.globsclause) = (yyvsp[(1) - (2)].globsclause); ;}
     break;
 
   case 97:
-
+#line 693 "cgrammar.y"
     { setProcessingGlobalsList (); ;}
     break;
 
   case 98:
-
+#line 695 "cgrammar.y"
     { 
      unsetProcessingGlobals (); 
      (yyval.globsclause) = globalsClause_create ((yyvsp[(1) - (4)].tok), (yyvsp[(3) - (4)].globset)); 
@@ -4809,17 +4809,17 @@ yyreduce:
     break;
 
   case 99:
-
+#line 702 "cgrammar.y"
     { (yyval.modsclause) = modifiesClause_createNoMods ((yyvsp[(1) - (1)].tok)); ;}
     break;
 
   case 100:
-
+#line 706 "cgrammar.y"
     { (yyval.modsclause) = (yyvsp[(1) - (2)].modsclause); ;}
     break;
 
   case 101:
-
+#line 711 "cgrammar.y"
     {
      context_setProtectVars (); enterParamsTemp (); 
      sRef_setGlobalScopeSafe (); 
@@ -4827,7 +4827,7 @@ yyreduce:
     break;
 
   case 102:
-
+#line 716 "cgrammar.y"
     { 
      exitParamsTemp ();
      sRef_clearGlobalScopeSafe (); 
@@ -4837,27 +4837,27 @@ yyreduce:
     break;
 
   case 103:
-
+#line 726 "cgrammar.y"
     { (yyval.flagspec) = flagSpec_createPlain ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 104:
-
+#line 728 "cgrammar.y"
     { (yyval.flagspec) = flagSpec_createOr ((yyvsp[(1) - (3)].cname), (yyvsp[(3) - (3)].flagspec)); ;}
     break;
 
   case 107:
-
+#line 737 "cgrammar.y"
     { (yyval.warnclause) = warnClause_undefined; ;}
     break;
 
   case 108:
-
+#line 741 "cgrammar.y"
     { (yyval.warnclause) = (yyvsp[(1) - (2)].warnclause); ;}
     break;
 
   case 109:
-
+#line 746 "cgrammar.y"
     {      
      llassert (exprNode_knownStringValue ((yyvsp[(3) - (3)].expr)));
      (yyval.warnclause) = warnClause_create ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].flagspec), cstring_copy (multiVal_forceString (exprNode_getValue ((yyvsp[(3) - (3)].expr))))); 
@@ -4866,77 +4866,77 @@ yyreduce:
     break;
 
   case 110:
-
+#line 752 "cgrammar.y"
     { (yyval.warnclause) = warnClause_create ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].flagspec), cstring_undefined); ;}
     break;
 
   case 111:
-
+#line 756 "cgrammar.y"
     { (yyval.globset) = globSet_single ((yyvsp[(1) - (1)].sr)); ;}
     break;
 
   case 112:
-
+#line 757 "cgrammar.y"
     { (yyval.globset) = globSet_insert ((yyvsp[(1) - (3)].globset), (yyvsp[(3) - (3)].sr)); ;}
     break;
 
   case 113:
-
+#line 761 "cgrammar.y"
     { (yyval.sr) = clabstract_createGlobal ((yyvsp[(2) - (2)].sr), (yyvsp[(1) - (2)].tquallist)); ;}
     break;
 
   case 114:
-
+#line 765 "cgrammar.y"
     { (yyval.tquallist) = qualList_undefined; ;}
     break;
 
   case 115:
-
+#line 766 "cgrammar.y"
     { (yyval.tquallist) = qualList_add ((yyvsp[(2) - (2)].tquallist), (yyvsp[(1) - (2)].typequal)); ;}
     break;
 
   case 116:
-
+#line 770 "cgrammar.y"
     { (yyval.sr) = uentry_getSref ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 117:
-
+#line 771 "cgrammar.y"
     { (yyval.sr) = clabstract_unrecognizedGlobal ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 118:
-
+#line 772 "cgrammar.y"
     { (yyval.sr) = clabstract_checkGlobal ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 119:
-
+#line 776 "cgrammar.y"
     { (yyval.typequal) = qual_createUndef (); ;}
     break;
 
   case 120:
-
+#line 777 "cgrammar.y"
     { (yyval.typequal) = qual_createKilled (); ;}
     break;
 
   case 121:
-
+#line 778 "cgrammar.y"
     { (yyval.typequal) = qual_createOut (); ;}
     break;
 
   case 122:
-
+#line 779 "cgrammar.y"
     { (yyval.typequal) = qual_createIn (); ;}
     break;
 
   case 123:
-
+#line 780 "cgrammar.y"
     { (yyval.typequal) = qual_createPartial (); ;}
     break;
 
   case 131:
-
+#line 798 "cgrammar.y"
     { 
      /**!!! deal with fred; fred (int); declarations! **/
      qtype qint = qtype_create (ctype_int); 
@@ -4946,17 +4946,17 @@ yyreduce:
     break;
 
   case 132:
-
+#line 805 "cgrammar.y"
     { (yyval.ntyp) = idDecl_fixBase ((yyvsp[(3) - (3)].ntyp), (yyvsp[(1) - (3)].qtyp)); ;}
     break;
 
   case 133:
-
+#line 809 "cgrammar.y"
     { checkDoneParams (); context_enterInnerContext (); ;}
     break;
 
   case 134:
-
+#line 811 "cgrammar.y"
     {  
      exprNode_checkFunctionBody ((yyvsp[(3) - (3)].expr)); (yyval.expr) = (yyvsp[(3) - (3)].expr); 
      context_exitInner ((yyvsp[(3) - (3)].expr)); 
@@ -4964,17 +4964,17 @@ yyreduce:
     break;
 
   case 135:
-
+#line 815 "cgrammar.y"
     { context_enterOldStyleScope (); ;}
     break;
 
   case 136:
-
+#line 816 "cgrammar.y"
     { oldStyleDoneParams (); context_enterInnerContext (); ;}
     break;
 
   case 137:
-
+#line 818 "cgrammar.y"
     {
      exprNode_checkFunctionBody ((yyvsp[(4) - (4)].expr)); 
      (yyval.expr) = (yyvsp[(4) - (4)].expr); /* oldstyle */ 
@@ -4983,7 +4983,7 @@ yyreduce:
     break;
 
   case 138:
-
+#line 827 "cgrammar.y"
     { 
      context_setFunctionDefined (exprNode_loc ((yyvsp[(2) - (2)].expr))); 
      exprNode_checkFunction (context_getHeader (),  (yyvsp[(2) - (2)].expr)); 
@@ -4994,129 +4994,129 @@ yyreduce:
     break;
 
   case 139:
-
+#line 837 "cgrammar.y"
     { (yyval.srset) = (yyvsp[(1) - (2)].srset); ;}
     break;
 
   case 140:
-
+#line 838 "cgrammar.y"
     { (yyval.srset) = sRefSet_new (); ;}
     break;
 
   case 141:
-
+#line 842 "cgrammar.y"
     { (yyval.sr) = uentry_getSref ((yyvsp[(1) - (1)].entry)); checkModifiesId ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 142:
-
+#line 843 "cgrammar.y"
     { (yyval.sr) = fixModifiesId ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 143:
-
+#line 844 "cgrammar.y"
     { (yyval.sr) = fixModifiesId ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 144:
-
+#line 845 "cgrammar.y"
     { (yyval.sr) = modListArrayFetch ((yyvsp[(1) - (3)].sr), sRef_undefined); ;}
     break;
 
   case 145:
-
+#line 846 "cgrammar.y"
     { (yyval.sr) = modListArrayFetch ((yyvsp[(1) - (4)].sr), (yyvsp[(3) - (4)].sr)); ;}
     break;
 
   case 146:
-
+#line 847 "cgrammar.y"
     { (yyval.sr) = modListPointer ((yyvsp[(2) - (2)].sr)); ;}
     break;
 
   case 147:
-
+#line 848 "cgrammar.y"
     { (yyval.sr) = (yyvsp[(2) - (3)].sr); ;}
     break;
 
   case 148:
-
+#line 849 "cgrammar.y"
     { (yyval.sr) = modListFieldAccess ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 149:
-
+#line 850 "cgrammar.y"
     { (yyval.sr) = modListArrowAccess ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 150:
-
+#line 854 "cgrammar.y"
     { (yyval.sr) = (yyvsp[(1) - (1)].sr); ;}
     break;
 
   case 151:
-
+#line 855 "cgrammar.y"
     { (yyval.sr) = sRef_makeUnknown (); /* sRef_makeConstant ($1); ? */ ;}
     break;
 
   case 152:
-
+#line 860 "cgrammar.y"
     { (yyval.srset) = sRefSet_single ((yyvsp[(1) - (1)].sr)); ;}
     break;
 
   case 153:
-
+#line 861 "cgrammar.y"
     { (yyval.srset) = sRefSet_insert ((yyvsp[(1) - (3)].srset), (yyvsp[(3) - (3)].sr)); ;}
     break;
 
   case 154:
-
+#line 866 "cgrammar.y"
     { (yyval.sr) = checkStateClausesId ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 155:
-
+#line 868 "cgrammar.y"
     { (yyval.sr) = fixStateClausesId ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 156:
-
+#line 869 "cgrammar.y"
     { (yyval.sr) = sRef_makeAnyArrayFetch ((yyvsp[(1) - (3)].sr)); ;}
     break;
 
   case 157:
-
+#line 870 "cgrammar.y"
     { (yyval.sr) = sRef_makeAnyArrayFetch ((yyvsp[(1) - (4)].sr)); ;}
     break;
 
   case 158:
-
+#line 871 "cgrammar.y"
     { (yyval.sr) = sRef_constructPointer ((yyvsp[(2) - (2)].sr)); ;}
     break;
 
   case 159:
-
+#line 872 "cgrammar.y"
     { (yyval.sr) = (yyvsp[(2) - (3)].sr); ;}
     break;
 
   case 160:
-
+#line 873 "cgrammar.y"
     { cstring_markOwned ((yyvsp[(3) - (3)].cname));
 					    (yyval.sr) = sRef_buildField ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 161:
-
+#line 875 "cgrammar.y"
     { cstring_markOwned ((yyvsp[(3) - (3)].cname));
                                             (yyval.sr) = sRef_makeArrow ((yyvsp[(1) - (3)].sr), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 162:
-
+#line 880 "cgrammar.y"
     { DPRINTF ((message("Empty optSpecClauseList") )); (yyval.srset) = sRefSet_undefined ;}
     break;
 
   case 164:
-
+#line 886 "cgrammar.y"
     { if (sRef_isValid ((yyvsp[(1) - (1)].sr))) { (yyval.srset) = sRefSet_single ((yyvsp[(1) - (1)].sr)); } 
       else {
 	DPRINTF((message("returning sRefSEt_undefined ")  ));
@@ -5125,7 +5125,7 @@ yyreduce:
     break;
 
   case 165:
-
+#line 892 "cgrammar.y"
     { if (sRef_isValid ((yyvsp[(3) - (3)].sr)))
 	{
 	  (yyval.srset) = sRefSet_insert ((yyvsp[(1) - (3)].srset), (yyvsp[(3) - (3)].sr)); 
@@ -5138,300 +5138,300 @@ yyreduce:
     break;
 
   case 166:
-
+#line 904 "cgrammar.y"
     { (yyval.expr) = exprNode_fromIdentifier ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 167:
-
+#line 905 "cgrammar.y"
     { (yyval.expr) = exprNode_fromUIO ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 169:
-
+#line 907 "cgrammar.y"
     { (yyval.expr) = exprNode_addParens ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].expr)); ;}
     break;
 
   case 170:
-
+#line 908 "cgrammar.y"
     { (yyval.expr) = exprNode_fromIdentifier (cscannerHelp_coerceId ((yyvsp[(1) - (1)].cname))); ;}
     break;
 
   case 171:
-
+#line 909 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 172:
-
+#line 910 "cgrammar.y"
     { exprChecks_inCompoundStatementExpression (); ;}
     break;
 
   case 173:
-
+#line 912 "cgrammar.y"
     { exprChecks_leaveCompoundStatementExpression (); (yyval.expr) = exprNode_compoundStatementExpression ((yyvsp[(1) - (4)].tok), (yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 175:
-
+#line 917 "cgrammar.y"
     { (yyval.expr) = exprNode_arrayFetch ((yyvsp[(1) - (4)].expr), (yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 176:
-
+#line 918 "cgrammar.y"
     { (yyval.expr) = exprNode_functionCall ((yyvsp[(1) - (3)].expr), exprNodeList_new ()); ;}
     break;
 
   case 177:
-
+#line 919 "cgrammar.y"
     { (yyval.expr) = exprNode_functionCall ((yyvsp[(1) - (4)].expr), (yyvsp[(3) - (4)].exprlist)); ;}
     break;
 
   case 178:
-
+#line 920 "cgrammar.y"
     { (yyval.expr) = exprNode_vaArg ((yyvsp[(1) - (6)].tok), (yyvsp[(3) - (6)].expr), (yyvsp[(5) - (6)].qtyp)); ;}
     break;
 
   case 179:
-
+#line 921 "cgrammar.y"
     { (yyval.expr) = exprNode_fieldAccess ((yyvsp[(1) - (5)].expr), (yyvsp[(3) - (5)].tok), (yyvsp[(4) - (5)].cname)); ;}
     break;
 
   case 180:
-
+#line 922 "cgrammar.y"
     { (yyval.expr) = exprNode_arrowAccess ((yyvsp[(1) - (5)].expr), (yyvsp[(3) - (5)].tok), (yyvsp[(4) - (5)].cname)); ;}
     break;
 
   case 181:
-
+#line 923 "cgrammar.y"
     { (yyval.expr) = exprNode_postOp ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 182:
-
+#line 924 "cgrammar.y"
     { (yyval.expr) = exprNode_postOp ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 183:
-
+#line 926 "cgrammar.y"
     { /* added for C99 */ (yyval.expr) = exprNode_undefined; /*@i87 no checking */ ;}
     break;
 
   case 184:
-
+#line 930 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_singleton ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 185:
-
+#line 931 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_push ((yyvsp[(1) - (3)].exprlist), (yyvsp[(3) - (3)].expr)); ;}
     break;
 
   case 187:
-
+#line 936 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 188:
-
+#line 937 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 189:
-
+#line 938 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 190:
-
+#line 939 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 191:
-
+#line 940 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 192:
-
+#line 941 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 193:
-
+#line 942 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 194:
-
+#line 943 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 195:
-
+#line 944 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
     break;
 
   case 196:
-
+#line 945 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 197:
-
+#line 949 "cgrammar.y"
     { (yyval.cstringlist) = cstringList_add ((yyvsp[(1) - (3)].cstringlist), (yyvsp[(3) - (3)].cname)); lltok_free ((yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 198:
-
+#line 950 "cgrammar.y"
     { (yyval.cstringlist) = (yyvsp[(1) - (4)].cstringlist); lltok_free2 ((yyvsp[(2) - (4)].tok), (yyvsp[(4) - (4)].tok)); ;}
     break;
 
   case 199:
-
+#line 952 "cgrammar.y"
     { (yyval.cstringlist) = cstringList_single ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 200:
-
+#line 957 "cgrammar.y"
     { (yyval.expr) = exprNode_offsetof ((yyvsp[(4) - (9)].qtyp), (yyvsp[(7) - (9)].cstringlist)); 
      lltok_free3 ((yyvsp[(1) - (9)].tok), (yyvsp[(3) - (9)].tok), (yyvsp[(6) - (9)].tok)); lltok_free ((yyvsp[(8) - (9)].tok)); ;}
     break;
 
   case 201:
-
+#line 962 "cgrammar.y"
     { context_setProtectVars (); ;}
     break;
 
   case 202:
-
+#line 963 "cgrammar.y"
     { context_sizeofReleaseVars (); (yyval.expr) = (yyvsp[(3) - (3)].expr); ;}
     break;
 
   case 203:
-
+#line 966 "cgrammar.y"
     {context_enterSizeof();}
     break;
 
   case 204:
-
+#line 969 "cgrammar.y"
     {context_leaveSizeof();}
     break;
 
   case 205:
-
+#line 973 "cgrammar.y"
     { (yyval.expr) = exprNode_sizeofType ((yyvsp[(3) - (4)].qtyp)); lltok_free3 ((yyvsp[(1) - (4)].tok), (yyvsp[(2) - (4)].tok), (yyvsp[(4) - (4)].tok));  ;}
     break;
 
   case 206:
-
+#line 974 "cgrammar.y"
     { (yyval.expr) = exprNode_sizeofExpr ((yyvsp[(2) - (2)].expr)); lltok_free ((yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 207:
-
+#line 975 "cgrammar.y"
     { (yyval.expr) = exprNode_alignofType ((yyvsp[(3) - (4)].qtyp)); lltok_free3 ((yyvsp[(1) - (4)].tok), (yyvsp[(2) - (4)].tok), (yyvsp[(4) - (4)].tok)); ;}
     break;
 
   case 208:
-
+#line 976 "cgrammar.y"
     { (yyval.expr) = exprNode_alignofExpr ((yyvsp[(2) - (2)].expr)); lltok_free ((yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 210:
-
+#line 984 "cgrammar.y"
     { (yyval.expr) = exprNode_cast ((yyvsp[(1) - (4)].tok), (yyvsp[(4) - (4)].expr), (yyvsp[(2) - (4)].qtyp)); lltok_free ((yyvsp[(3) - (4)].tok)); ;}
     break;
 
   case 212:
-
+#line 989 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 213:
-
+#line 990 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 214:
-
+#line 991 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 216:
-
+#line 996 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 217:
-
+#line 997 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 219:
-
+#line 1002 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 220:
-
+#line 1003 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 222:
-
+#line 1008 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 223:
-
+#line 1009 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 224:
-
+#line 1010 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 225:
-
+#line 1011 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 227:
-
+#line 1016 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 228:
-
+#line 1017 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 230:
-
+#line 1022 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 232:
-
+#line 1027 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 234:
-
+#line 1032 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 236:
-
+#line 1038 "cgrammar.y"
     { exprNode_produceGuards ((yyvsp[(1) - (2)].expr)); 
      context_enterAndClause ((yyvsp[(1) - (2)].expr)); 
    ;}
     break;
 
   case 237:
-
+#line 1042 "cgrammar.y"
     { 
      (yyval.expr) = exprNode_op ((yyvsp[(1) - (4)].expr), (yyvsp[(4) - (4)].expr), (yyvsp[(2) - (4)].tok)); 
      context_exitAndClause ((yyval.expr), (yyvsp[(4) - (4)].expr));
@@ -5439,7 +5439,7 @@ yyreduce:
     break;
 
   case 239:
-
+#line 1051 "cgrammar.y"
     { 
      exprNode_produceGuards ((yyvsp[(1) - (2)].expr));
      context_enterOrClause ((yyvsp[(1) - (2)].expr)); 
@@ -5447,7 +5447,7 @@ yyreduce:
     break;
 
   case 240:
-
+#line 1056 "cgrammar.y"
     { 
      (yyval.expr) = exprNode_op ((yyvsp[(1) - (4)].expr), (yyvsp[(4) - (4)].expr), (yyvsp[(2) - (4)].tok)); 
      context_exitOrClause ((yyval.expr), (yyvsp[(4) - (4)].expr));
@@ -5455,123 +5455,123 @@ yyreduce:
     break;
 
   case 242:
-
+#line 1065 "cgrammar.y"
     { /* GCC extension: conditional with empty if */
      exprNode_produceGuards ((yyvsp[(1) - (2)].expr)); context_enterTrueClause ((yyvsp[(1) - (2)].expr)); ;}
     break;
 
   case 243:
-
+#line 1067 "cgrammar.y"
     { context_enterFalseClause ((yyvsp[(1) - (4)].expr)); ;}
     break;
 
   case 244:
-
+#line 1068 "cgrammar.y"
     { (yyval.expr) = exprNode_condIfOmit ((yyvsp[(1) - (6)].expr), (yyvsp[(6) - (6)].expr)); context_exitClause ((yyvsp[(1) - (6)].expr), exprNode_undefined, (yyvsp[(6) - (6)].expr)); ;}
     break;
 
   case 245:
-
+#line 1069 "cgrammar.y"
     { exprNode_produceGuards ((yyvsp[(1) - (2)].expr)); context_enterTrueClause ((yyvsp[(1) - (2)].expr)); ;}
     break;
 
   case 246:
-
+#line 1070 "cgrammar.y"
     { context_enterFalseClause ((yyvsp[(1) - (5)].expr)); ;}
     break;
 
   case 247:
-
+#line 1071 "cgrammar.y"
     { (yyval.expr) = exprNode_cond ((yyvsp[(1) - (7)].expr), (yyvsp[(4) - (7)].expr), (yyvsp[(7) - (7)].expr)); context_exitClause ((yyvsp[(1) - (7)].expr), (yyvsp[(4) - (7)].expr), (yyvsp[(7) - (7)].expr)); ;}
     break;
 
   case 249:
-
+#line 1076 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 250:
-
+#line 1077 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 251:
-
+#line 1078 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 252:
-
+#line 1079 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 253:
-
+#line 1080 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 254:
-
+#line 1081 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 255:
-
+#line 1082 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 256:
-
+#line 1083 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 257:
-
+#line 1084 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 258:
-
+#line 1085 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 259:
-
+#line 1086 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 261:
-
+#line 1091 "cgrammar.y"
     { (yyval.expr) = exprNode_comma ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
     break;
 
   case 262:
-
+#line 1095 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 265:
-
+#line 1106 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 266:
-
+#line 1107 "cgrammar.y"
     { doVaDcl (); (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 267:
-
+#line 1108 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 268:
-
+#line 1113 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 269:
-
+#line 1127 "cgrammar.y"
     {
      setProcessingVars ((yyvsp[(1) - (4)].qtyp)); 
      processNamedDecl ((yyvsp[(3) - (4)].ntyp)); 
@@ -5579,7 +5579,7 @@ yyreduce:
     break;
 
   case 270:
-
+#line 1132 "cgrammar.y"
     { 
      unsetProcessingVars (); 
      (yyval.expr) = exprNode_makeEmptyInitialization ((yyvsp[(3) - (9)].ntyp)); 
@@ -5588,29 +5588,29 @@ yyreduce:
     break;
 
   case 271:
-
+#line 1138 "cgrammar.y"
     { setProcessingVars ((yyvsp[(1) - (5)].qtyp)); processNamedDecl ((yyvsp[(3) - (5)].ntyp)); ;}
     break;
 
   case 272:
-
+#line 1140 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(9) - (11)].expr), exprNode_makeInitialization ((yyvsp[(3) - (11)].ntyp), (yyvsp[(8) - (11)].expr))); 
      unsetProcessingVars ();
    ;}
     break;
 
   case 273:
-
+#line 1146 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 274:
-
+#line 1147 "cgrammar.y"
     { (yyval.expr) = exprNode_fromIdentifier (usymtab_getTypeEntry (ctype_typeId ((yyvsp[(1) - (1)].ctyp)))); ;}
     break;
 
   case 275:
-
+#line 1152 "cgrammar.y"
     { 
      processNamedDecl ((yyvsp[(1) - (2)].ntyp)); 
      (yyval.expr) = exprNode_makeEmptyInitialization ((yyvsp[(1) - (2)].ntyp));
@@ -5618,173 +5618,173 @@ yyreduce:
     break;
 
   case 276:
-
+#line 1156 "cgrammar.y"
     { processNamedDecl ((yyvsp[(1) - (3)].ntyp)); ;}
     break;
 
   case 277:
-
+#line 1157 "cgrammar.y"
     { (yyval.expr) = exprNode_makeInitialization ((yyvsp[(1) - (6)].ntyp), (yyvsp[(6) - (6)].expr)); ;}
     break;
 
   case 278:
-
+#line 1161 "cgrammar.y"
     { setProcessingTypedef ((yyvsp[(2) - (2)].qtyp)); ;}
     break;
 
   case 279:
-
+#line 1163 "cgrammar.y"
     { clabstract_declareType ((yyvsp[(5) - (8)].exprlist), (yyvsp[(7) - (8)].warnclause)); ;}
     break;
 
   case 280:
-
+#line 1164 "cgrammar.y"
     { /* in the ANSI grammar, semantics unclear */ ;}
     break;
 
   case 281:
-
+#line 1165 "cgrammar.y"
     { /* in the ANSI grammar, semantics unclear */ ;}
     break;
 
   case 282:
-
+#line 1169 "cgrammar.y"
     { cscannerHelp_setExpectingTypeName (); ;}
     break;
 
   case 283:
-
+#line 1173 "cgrammar.y"
     { cscannerHelp_setExpectingTypeName (); context_pushLoc (); ;}
     break;
 
   case 284:
-
+#line 1177 "cgrammar.y"
     { (yyval.exprlist) = (yyvsp[(1) - (2)].exprlist); ;}
     break;
 
   case 285:
-
+#line 1181 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_singleton ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 286:
-
+#line 1182 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_push ((yyvsp[(1) - (4)].exprlist), (yyvsp[(4) - (4)].expr)); ;}
     break;
 
   case 287:
-
+#line 1186 "cgrammar.y"
     { (yyval.exprlist) = (yyvsp[(1) - (2)].exprlist); ;}
     break;
 
   case 288:
-
+#line 1190 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_singleton ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 289:
-
+#line 1191 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_push ((yyvsp[(1) - (4)].exprlist), (yyvsp[(4) - (4)].expr)); ;}
     break;
 
   case 290:
-
+#line 1195 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 291:
-
+#line 1196 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (4)].expr), (yyvsp[(4) - (4)].expr)); ;}
     break;
 
   case 293:
-
+#line 1201 "cgrammar.y"
     { (yyval.expr) = exprNode_makeInitBlock ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].exprlist)); lltok_free ((yyvsp[(3) - (3)].tok)); ;}
     break;
 
   case 294:
-
+#line 1202 "cgrammar.y"
     { (yyval.expr) = exprNode_makeInitBlock ((yyvsp[(1) - (4)].tok), (yyvsp[(2) - (4)].exprlist)); lltok_free2 ((yyvsp[(3) - (4)].tok), (yyvsp[(4) - (4)].tok)); ;}
     break;
 
   case 295:
-
+#line 1203 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 296:
-
+#line 1211 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (2)].expr); ;}
     break;
 
   case 297:
-
+#line 1212 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; 
                                      /* gcc extension, obsolete since 2.5 */ ;}
     break;
 
   case 298:
-
+#line 1217 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 299:
-
+#line 1218 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 300:
-
+#line 1222 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 301:
-
+#line 1223 "cgrammar.y"
     { (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 302:
-
+#line 1228 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_singleton ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 303:
-
+#line 1230 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_push ((yyvsp[(1) - (3)].exprlist), (yyvsp[(3) - (3)].expr)); ;}
     break;
 
   case 304:
-
+#line 1239 "cgrammar.y"
     { setStorageClass (SCEXTERN); (yyval.typequal) = qual_createExtern (); ;}
     break;
 
   case 305:
-
+#line 1240 "cgrammar.y"
     { (yyval.typequal) = qual_createInline (); ;}
     break;
 
   case 306:
-
+#line 1241 "cgrammar.y"
     { setStorageClass (SCSTATIC); (yyval.typequal) = qual_createStatic (); ;}
     break;
 
   case 307:
-
+#line 1242 "cgrammar.y"
     { (yyval.typequal) = qual_createAuto (); ;}
     break;
 
   case 308:
-
+#line 1243 "cgrammar.y"
     { (yyval.typequal) = qual_createRegister (); ;}
     break;
 
   case 309:
-
+#line 1247 "cgrammar.y"
     { (yyval.stateclause) = (yyvsp[(1) - (2)].stateclause); ;}
     break;
 
   case 310:
-
+#line 1252 "cgrammar.y"
     {
      context_setProtectVars (); 
      enterParamsTemp (); 
@@ -5793,7 +5793,7 @@ yyreduce:
     break;
 
   case 311:
-
+#line 1258 "cgrammar.y"
     { 
      exitParamsTemp ();
      sRef_clearGlobalScopeSafe (); 
@@ -5803,17 +5803,17 @@ yyreduce:
     break;
 
   case 312:
-
+#line 1267 "cgrammar.y"
     { (yyval.funcclause) = (yyvsp[(1) - (2)].funcclause); ;}
     break;
 
   case 313:
-
+#line 1271 "cgrammar.y"
     { (yyval.tok) = (yyvsp[(1) - (2)].tok); context_enterFunctionHeader (); ;}
     break;
 
   case 314:
-
+#line 1276 "cgrammar.y"
     {
      context_exitFunctionHeader ();
      context_setProtectVars (); 
@@ -5823,7 +5823,7 @@ yyreduce:
     break;
 
   case 315:
-
+#line 1283 "cgrammar.y"
     { 
      exitParamsTemp ();
      sRef_clearGlobalScopeSafe (); 
@@ -5833,7 +5833,7 @@ yyreduce:
     break;
 
   case 316:
-
+#line 1290 "cgrammar.y"
     {
      context_setProtectVars (); 
      enterParamsTemp (); 
@@ -5842,7 +5842,7 @@ yyreduce:
     break;
 
   case 317:
-
+#line 1296 "cgrammar.y"
     {
      context_exitFunctionHeader ();
      exitParamsTemp ();
@@ -5868,577 +5868,577 @@ yyreduce:
     break;
 
   case 318:
-
+#line 1321 "cgrammar.y"
     { (yyval.fcnconstraint) = functionConstraint_createBufferConstraint ((yyvsp[(1) - (1)].conL)); ;}
     break;
 
   case 319:
-
+#line 1322 "cgrammar.y"
     { (yyval.fcnconstraint) = functionConstraint_createMetaStateConstraint ((yyvsp[(1) - (1)].msconstraint)); DPRINTF (("Made constraint: %s", functionConstraint_unparse ((yyval.fcnconstraint)))); ;}
     break;
 
   case 320:
-
+#line 1326 "cgrammar.y"
     { (yyval.typequal) = qual_createExits (); ;}
     break;
 
   case 321:
-
+#line 1327 "cgrammar.y"
     { (yyval.typequal) = qual_createMayExit (); ;}
     break;
 
   case 322:
-
+#line 1328 "cgrammar.y"
     { (yyval.typequal) = qual_createTrueExit (); ;}
     break;
 
   case 323:
-
+#line 1329 "cgrammar.y"
     { (yyval.typequal) = qual_createFalseExit (); ;}
     break;
 
   case 324:
-
+#line 1330 "cgrammar.y"
     { (yyval.typequal) = qual_createNeverExit (); ;}
     break;
 
   case 325:
-
+#line 1334 "cgrammar.y"
     { (yyval.typequal) = qual_createChecked (); ;}
     break;
 
   case 326:
-
+#line 1335 "cgrammar.y"
     { (yyval.typequal) = qual_createCheckMod (); ;}
     break;
 
   case 327:
-
+#line 1336 "cgrammar.y"
     { (yyval.typequal) = qual_createUnchecked (); ;}
     break;
 
   case 328:
-
+#line 1337 "cgrammar.y"
     { (yyval.typequal) = qual_createCheckedStrict (); ;}
     break;
 
   case 329:
-
+#line 1341 "cgrammar.y"
     { (yyval.typequal) = qual_createOwned (); ;}
     break;
 
   case 330:
-
+#line 1342 "cgrammar.y"
     { (yyval.typequal) = qual_createDependent (); ;}
     break;
 
   case 331:
-
+#line 1343 "cgrammar.y"
     { (yyval.typequal) = qual_createYield (); ;}
     break;
 
   case 332:
-
+#line 1344 "cgrammar.y"
     { (yyval.typequal) = qual_createTemp (); ;}
     break;
 
   case 333:
-
+#line 1345 "cgrammar.y"
     { (yyval.typequal) = qual_createOnly (); ;}
     break;
 
   case 334:
-
+#line 1346 "cgrammar.y"
     { (yyval.typequal) = qual_createKeep (); ;}
     break;
 
   case 335:
-
+#line 1347 "cgrammar.y"
     { (yyval.typequal) = qual_createKept (); ;}
     break;
 
   case 336:
-
+#line 1348 "cgrammar.y"
     { (yyval.typequal) = qual_createShared (); ;}
     break;
 
   case 337:
-
+#line 1349 "cgrammar.y"
     { (yyval.typequal) = qual_createUnique (); ;}
     break;
 
   case 338:
-
+#line 1350 "cgrammar.y"
     { (yyval.typequal) = qual_createNull (); ;}
     break;
 
   case 339:
-
+#line 1351 "cgrammar.y"
     { (yyval.typequal) = qual_createIsNull (); ;}
     break;
 
   case 340:
-
+#line 1352 "cgrammar.y"
     { (yyval.typequal) = qual_createRelNull (); ;}
     break;
 
   case 341:
-
+#line 1353 "cgrammar.y"
     { (yyval.typequal) = qual_createNotNull (); ;}
     break;
 
   case 342:
-
+#line 1354 "cgrammar.y"
     { (yyval.typequal) = qual_createExposed (); ;}
     break;
 
   case 343:
-
+#line 1355 "cgrammar.y"
     { (yyval.typequal) = qual_createObserver (); ;}
     break;
 
   case 344:
-
+#line 1356 "cgrammar.y"
     { (yyval.typequal) = qual_createNullTerminated (); ;}
     break;
 
   case 345:
-
+#line 1357 "cgrammar.y"
     { (yyval.typequal) = qual_createMetaState ((yyvsp[(1) - (1)].annotation)); ;}
     break;
 
   case 346:
-
+#line 1361 "cgrammar.y"
     { (yyval.typequal) = qual_createReturned (); ;}
     break;
 
   case 347:
-
+#line 1362 "cgrammar.y"
     { (yyval.typequal) = qual_createSef (); ;}
     break;
 
   case 348:
-
+#line 1366 "cgrammar.y"
     { (yyval.typequal) = qual_createUnused (); ;}
     break;
 
   case 349:
-
+#line 1367 "cgrammar.y"
     { (yyval.typequal) = qual_createExternal (); ;}
     break;
 
   case 350:
-
+#line 1371 "cgrammar.y"
     { (yyval.typequal) = qual_createTrueNull (); ;}
     break;
 
   case 351:
-
+#line 1372 "cgrammar.y"
     { (yyval.typequal) = qual_createFalseNull (); ;}
     break;
 
   case 352:
-
+#line 1376 "cgrammar.y"
     { (yyval.typequal) = qual_createAbstract (); ;}
     break;
 
   case 353:
-
+#line 1377 "cgrammar.y"
     { (yyval.typequal) = qual_createNumAbstract (); ;}
     break;
 
   case 354:
-
+#line 1378 "cgrammar.y"
     { (yyval.typequal) = qual_createConcrete (); ;}
     break;
 
   case 355:
-
+#line 1379 "cgrammar.y"
     { (yyval.typequal) = qual_createMutable (); ;}
     break;
 
   case 356:
-
+#line 1380 "cgrammar.y"
     { (yyval.typequal) = qual_createImmutable (); ;}
     break;
 
   case 357:
-
+#line 1384 "cgrammar.y"
     { (yyval.typequal) = qual_createRefCounted (); ;}
     break;
 
   case 358:
-
+#line 1385 "cgrammar.y"
     { (yyval.typequal) = qual_createRefs (); ;}
     break;
 
   case 359:
-
+#line 1386 "cgrammar.y"
     { (yyval.typequal) = qual_createKillRef (); ;}
     break;
 
   case 360:
-
+#line 1387 "cgrammar.y"
     { (yyval.typequal) = qual_createRelDef (); ;}
     break;
 
   case 361:
-
+#line 1388 "cgrammar.y"
     { (yyval.typequal) = qual_createNewRef (); ;}
     break;
 
   case 362:
-
+#line 1389 "cgrammar.y"
     { (yyval.typequal) = qual_createTempRef (); ;}
     break;
 
   case 363:
-
+#line 1393 "cgrammar.y"
     { (yyval.typequal) = qual_createShort (); ;}
     break;
 
   case 364:
-
+#line 1394 "cgrammar.y"
     { (yyval.typequal) = qual_createLong (); ;}
     break;
 
   case 365:
-
+#line 1395 "cgrammar.y"
     { (yyval.typequal) = qual_createSigned (); ;}
     break;
 
   case 366:
-
+#line 1396 "cgrammar.y"
     { (yyval.typequal) = qual_createUnsigned (); ;}
     break;
 
   case 367:
-
+#line 1400 "cgrammar.y"
     { (yyval.typequal) = qual_createOut (); ;}
     break;
 
   case 368:
-
+#line 1401 "cgrammar.y"
     { (yyval.typequal) = qual_createIn (); ;}
     break;
 
   case 369:
-
+#line 1402 "cgrammar.y"
     { (yyval.typequal) = qual_createPartial (); ;}
     break;
 
   case 370:
-
+#line 1403 "cgrammar.y"
     { (yyval.typequal) = qual_createSpecial (); ;}
     break;
 
   case 371:
-
+#line 1407 "cgrammar.y"
     { (yyval.typequal) = qual_createConst (); ;}
     break;
 
   case 372:
-
+#line 1408 "cgrammar.y"
     { (yyval.typequal) = qual_createVolatile (); ;}
     break;
 
   case 373:
-
+#line 1409 "cgrammar.y"
     { (yyval.typequal) = qual_createRestrict (); ;}
     break;
 
   case 374:
-
+#line 1410 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 375:
-
+#line 1411 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 376:
-
+#line 1412 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 377:
-
+#line 1413 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 378:
-
+#line 1414 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 379:
-
+#line 1415 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 380:
-
+#line 1416 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 381:
-
+#line 1417 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 382:
-
+#line 1418 "cgrammar.y"
     { (yyval.typequal) = (yyvsp[(1) - (2)].typequal); ;}
     break;
 
   case 389:
-
+#line 1432 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeAnytype (); ;}
     break;
 
   case 390:
-
+#line 1433 "cgrammar.y"
     { (yyval.ctyp) = ctype_anyintegral; ;}
     break;
 
   case 391:
-
+#line 1434 "cgrammar.y"
     { (yyval.ctyp) = ctype_unsignedintegral; ;}
     break;
 
   case 392:
-
+#line 1435 "cgrammar.y"
     { (yyval.ctyp) = ctype_signedintegral; ;}
     break;
 
   case 396:
-
+#line 1439 "cgrammar.y"
     { (yyval.ctyp) = ctype_fromQual ((yyvsp[(1) - (2)].typequal)); ;}
     break;
 
   case 397:
-
+#line 1444 "cgrammar.y"
     { (yyval.qtyp) = qtype_resolve ((yyvsp[(2) - (3)].qtyp)); ;}
     break;
 
   case 398:
-
+#line 1448 "cgrammar.y"
     { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
     break;
 
   case 399:
-
+#line 1450 "cgrammar.y"
     { (yyval.qtyp) = qtype_mergeAlt ((yyvsp[(1) - (4)].qtyp), (yyvsp[(3) - (4)].qtyp)); ;}
     break;
 
   case 401:
-
+#line 1456 "cgrammar.y"
     { (yyval.qtyp) = qtype_mergeAlt ((yyvsp[(1) - (3)].qtyp), (yyvsp[(3) - (3)].qtyp)); ;}
     break;
 
   case 402:
-
+#line 1460 "cgrammar.y"
     { (yyval.qtyp) = qtype_addQual ((yyvsp[(2) - (2)].qtyp), (yyvsp[(1) - (2)].typequal)); ;}
     break;
 
   case 403:
-
+#line 1461 "cgrammar.y"
     { (yyval.qtyp) = qtype_addQual ((yyvsp[(2) - (2)].qtyp), (yyvsp[(1) - (2)].typequal)); ;}
     break;
 
   case 404:
-
+#line 1462 "cgrammar.y"
     { (yyval.qtyp) = qtype_combine ((yyvsp[(2) - (2)].qtyp), (yyvsp[(1) - (2)].ctyp)); ;}
     break;
 
   case 405:
-
+#line 1466 "cgrammar.y"
     { (yyval.qtyp) = qtype_unknown (); ;}
     break;
 
   case 406:
-
+#line 1467 "cgrammar.y"
     { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
     break;
 
   case 407:
-
+#line 1471 "cgrammar.y"
     { (yyval.conL) = constraintList_undefined; ;}
     break;
 
   case 408:
-
+#line 1478 "cgrammar.y"
     { sRef_setGlobalScopeSafe (); ;}
     break;
 
   case 409:
-
+#line 1480 "cgrammar.y"
     { sRef_clearGlobalScopeSafe (); ;}
     break;
 
   case 410:
-
+#line 1483 "cgrammar.y"
     { ctype ct; ct = declareStruct ((yyvsp[(3) - (12)].cname), (yyvsp[(8) - (12)].flist)); /* context_setGlobalStructInfo(ct, $12); */ (yyval.ctyp) = ct; ;}
     break;
 
   case 411:
-
+#line 1484 "cgrammar.y"
     { sRef_setGlobalScopeSafe (); ;}
     break;
 
   case 412:
-
+#line 1486 "cgrammar.y"
     { sRef_clearGlobalScopeSafe (); ;}
     break;
 
   case 413:
-
+#line 1488 "cgrammar.y"
     { (yyval.ctyp) = declareUnion ((yyvsp[(3) - (11)].cname), (yyvsp[(8) - (11)].flist)); ;}
     break;
 
   case 414:
-
+#line 1490 "cgrammar.y"
     { (yyval.ctyp) = declareStruct ((yyvsp[(3) - (6)].cname), uentryList_new ()); ;}
     break;
 
   case 415:
-
+#line 1492 "cgrammar.y"
     { (yyval.ctyp) = declareUnion ((yyvsp[(3) - (6)].cname), uentryList_new ()); ;}
     break;
 
   case 416:
-
+#line 1493 "cgrammar.y"
     { sRef_setGlobalScopeSafe (); ;}
     break;
 
   case 417:
-
+#line 1495 "cgrammar.y"
     { sRef_clearGlobalScopeSafe (); ;}
     break;
 
   case 418:
-
+#line 1497 "cgrammar.y"
     { (yyval.ctyp) = declareUnnamedStruct ((yyvsp[(7) - (10)].flist)); ;}
     break;
 
   case 419:
-
+#line 1498 "cgrammar.y"
     { sRef_setGlobalScopeSafe (); ;}
     break;
 
   case 420:
-
+#line 1500 "cgrammar.y"
     { sRef_clearGlobalScopeSafe (); ;}
     break;
 
   case 421:
-
+#line 1502 "cgrammar.y"
     { (yyval.ctyp) = declareUnnamedUnion ((yyvsp[(7) - (10)].flist)); ;}
     break;
 
   case 422:
-
+#line 1504 "cgrammar.y"
     { (yyval.ctyp) = ctype_createUnnamedStruct (uentryList_new ()); ;}
     break;
 
   case 423:
-
+#line 1506 "cgrammar.y"
     { (yyval.ctyp) = ctype_createUnnamedUnion (uentryList_new ()); ;}
     break;
 
   case 424:
-
+#line 1507 "cgrammar.y"
     { (yyval.ctyp) = handleStruct ((yyvsp[(3) - (4)].cname)); ;}
     break;
 
   case 425:
-
+#line 1508 "cgrammar.y"
     { (yyval.ctyp) = handleUnion ((yyvsp[(3) - (4)].cname)); ;}
     break;
 
   case 426:
-
+#line 1512 "cgrammar.y"
     { cscannerHelp_clearExpectingTypeName (); ;}
     break;
 
   case 428:
-
+#line 1517 "cgrammar.y"
     { (yyval.flist) = uentryList_undefined; /* bogus! */ ;}
     break;
 
   case 429:
-
+#line 1518 "cgrammar.y"
     { (yyval.flist) = uentryList_mergeFields ((yyvsp[(1) - (2)].flist), (yyvsp[(2) - (2)].flist)); ;}
     break;
 
   case 430:
-
+#line 1523 "cgrammar.y"
     { (yyval.flist) = fixUentryList ((yyvsp[(3) - (5)].ntyplist), (yyvsp[(1) - (5)].qtyp)); ;}
     break;
 
   case 431:
-
+#line 1525 "cgrammar.y"
     { (yyval.flist) = fixUnnamedDecl ((yyvsp[(1) - (3)].qtyp)); ;}
     break;
 
   case 432:
-
+#line 1530 "cgrammar.y"
     { (yyval.ntyplist) = idDeclList_singleton ((yyvsp[(1) - (2)].ntyp)); ;}
     break;
 
   case 433:
-
+#line 1532 "cgrammar.y"
     { (yyval.ntyplist) = idDeclList_add ((yyvsp[(1) - (4)].ntyplist), (yyvsp[(3) - (4)].ntyp)); ;}
     break;
 
   case 434:
-
+#line 1536 "cgrammar.y"
     { (yyval.ntyp) = (yyvsp[(1) - (1)].ntyp); ;}
     break;
 
   case 435:
-
+#line 1537 "cgrammar.y"
     { (yyval.ntyp) = idDecl_undefined; ;}
     break;
 
   case 436:
-
+#line 1538 "cgrammar.y"
     { (yyval.ntyp) = (yyvsp[(1) - (4)].ntyp); ;}
     break;
 
   case 437:
-
+#line 1544 "cgrammar.y"
     { (yyval.ctyp) = declareUnnamedEnum ((yyvsp[(4) - (6)].enumnamelist)); ;}
     break;
 
   case 438:
-
+#line 1545 "cgrammar.y"
     { context_pushLoc (); ;}
     break;
 
   case 439:
-
+#line 1546 "cgrammar.y"
     { context_popLoc (); (yyval.ctyp) = declareEnum ((yyvsp[(3) - (8)].cname), (yyvsp[(6) - (8)].enumnamelist)); ;}
     break;
 
   case 440:
-
+#line 1547 "cgrammar.y"
     { (yyval.ctyp) = handleEnum ((yyvsp[(3) - (4)].cname)); ;}
     break;
 
   case 441:
-
+#line 1552 "cgrammar.y"
     { (yyval.enumnamelist) = enumNameList_single ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 442:
-
+#line 1554 "cgrammar.y"
     { (yyval.enumnamelist) = enumNameList_push ((yyvsp[(1) - (3)].enumnamelist), (yyvsp[(3) - (3)].cname)); ;}
     break;
 
   case 444:
-
+#line 1560 "cgrammar.y"
     { uentry ue = uentry_makeEnumConstant ((yyvsp[(1) - (1)].cname), ctype_unknown);
      usymtab_supGlobalEntry (ue);
      (yyval.cname) = (yyvsp[(1) - (1)].cname);
@@ -6446,7 +6446,7 @@ yyreduce:
     break;
 
   case 445:
-
+#line 1565 "cgrammar.y"
     { uentry ue = uentry_makeEnumInitializedConstant ((yyvsp[(1) - (4)].cname), ctype_unknown, (yyvsp[(4) - (4)].expr));
      usymtab_supGlobalEntry (ue);
      (yyval.cname) = (yyvsp[(1) - (4)].cname); 
@@ -6454,12 +6454,12 @@ yyreduce:
     break;
 
   case 447:
-
+#line 1573 "cgrammar.y"
     { (yyval.ntyp) = idDecl_create (cstring_undefined, qtype_create ((yyvsp[(1) - (1)].ctyp))); ;}
     break;
 
   case 448:
-
+#line 1575 "cgrammar.y"
     { 
      qtype qt = qtype_unknown ();
      qtype_adjustPointers ((yyvsp[(1) - (2)].pointers), qt);
@@ -6468,117 +6468,117 @@ yyreduce:
     break;
 
   case 449:
-
+#line 1581 "cgrammar.y"
     { (yyval.ntyp) = (yyvsp[(2) - (2)].ntyp); qtype_adjustPointers ((yyvsp[(1) - (2)].pointers), idDecl_getTyp ((yyval.ntyp))); ;}
     break;
 
   case 451:
-
+#line 1587 "cgrammar.y"
     { (yyval.ntyp) = (yyvsp[(2) - (2)].ntyp); qtype_adjustPointers ((yyvsp[(1) - (2)].pointers), idDecl_getTyp ((yyval.ntyp))); ;}
     break;
 
   case 452:
-
+#line 1591 "cgrammar.y"
     { (yyval.entrylist) = handleParamTypeList ((yyvsp[(1) - (1)].entrylist)); ;}
     break;
 
   case 453:
-
+#line 1592 "cgrammar.y"
     { (yyval.entrylist) = handleParamIdList ((yyvsp[(2) - (2)].entrylist)); ;}
     break;
 
   case 454:
-
+#line 1596 "cgrammar.y"
     { (yyval.typequal) = qual_createConst (); ;}
     break;
 
   case 455:
-
+#line 1597 "cgrammar.y"
     { (yyval.typequal) = qual_createRestrict (); ;}
     break;
 
   case 456:
-
+#line 1598 "cgrammar.y"
     { (yyval.typequal) = qual_createVolatile (); ;}
     break;
 
   case 457:
-
+#line 1602 "cgrammar.y"
     { (yyval.tquallist) = qualList_single ((yyvsp[(1) - (1)].typequal)); ;}
     break;
 
   case 458:
-
+#line 1603 "cgrammar.y"
     { (yyval.tquallist) = qualList_add ((yyvsp[(1) - (2)].tquallist), (yyvsp[(2) - (2)].typequal)); ;}
     break;
 
   case 459:
-
+#line 1607 "cgrammar.y"
     { (yyval.pointers) = pointers_create ((yyvsp[(1) - (1)].tok)); ;}
     break;
 
   case 460:
-
+#line 1608 "cgrammar.y"
     { (yyval.pointers) = pointers_createMods ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].tquallist)); ;}
     break;
 
   case 461:
-
+#line 1609 "cgrammar.y"
     { (yyval.pointers) = pointers_extend (pointers_create ((yyvsp[(1) - (2)].tok)), (yyvsp[(2) - (2)].pointers)); ;}
     break;
 
   case 462:
-
+#line 1610 "cgrammar.y"
     { (yyval.pointers) = pointers_extend (pointers_createMods ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].tquallist)), (yyvsp[(3) - (3)].pointers)); ;}
     break;
 
   case 464:
-
+#line 1615 "cgrammar.y"
     { (yyval.entrylist) = uentryList_add ((yyvsp[(1) - (3)].entrylist), uentry_makeElipsisMarker ()); ;}
     break;
 
   case 465:
-
+#line 1619 "cgrammar.y"
     { (yyval.entrylist) = uentryList_single (uentry_makeVariableLoc ((yyvsp[(1) - (1)].cname), ctype_int)); ;}
     break;
 
   case 466:
-
+#line 1620 "cgrammar.y"
     { (yyval.entrylist) = uentryList_add ((yyvsp[(1) - (3)].entrylist), uentry_makeVariableLoc ((yyvsp[(3) - (3)].cname), ctype_int)); ;}
     break;
 
   case 467:
-
+#line 1624 "cgrammar.y"
     { (yyval.entrylist) = uentryList_single (uentry_makeElipsisMarker ()); ;}
     break;
 
   case 469:
-
+#line 1626 "cgrammar.y"
     { (yyval.entrylist) = uentryList_add ((yyvsp[(1) - (3)].entrylist), uentry_makeElipsisMarker ()); ;}
     break;
 
   case 470:
-
+#line 1630 "cgrammar.y"
     { storeLoc (); ;}
     break;
 
   case 471:
-
+#line 1630 "cgrammar.y"
     { (yyval.entrylist) = uentryList_single ((yyvsp[(2) - (2)].oentry)); ;}
     break;
 
   case 472:
-
+#line 1631 "cgrammar.y"
     { storeLoc (); ;}
     break;
 
   case 473:
-
+#line 1632 "cgrammar.y"
     { (yyval.entrylist) = uentryList_add ((yyvsp[(1) - (4)].entrylist), (yyvsp[(4) - (4)].oentry)); ;}
     break;
 
   case 474:
-
+#line 1637 "cgrammar.y"
     { 
      if (isFlipOldStyle ()) 
        { 
@@ -6593,7 +6593,7 @@ yyreduce:
     break;
 
   case 475:
-
+#line 1649 "cgrammar.y"
     { 
      idDecl tparam = idDecl_create ((yyvsp[(1) - (1)].cname), qtype_unknown ());
 
@@ -6610,422 +6610,422 @@ yyreduce:
     break;
 
   case 477:
-
+#line 1666 "cgrammar.y"
     { (yyval.qtyp) = qtype_newBase ((yyvsp[(1) - (2)].qtyp), (yyvsp[(2) - (2)].ctyp)); ;}
     break;
 
   case 478:
-
+#line 1670 "cgrammar.y"
     { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (1)].pointers), ctype_unknown); ;}
     break;
 
   case 480:
-
+#line 1672 "cgrammar.y"
     { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (2)].pointers), (yyvsp[(2) - (2)].ctyp)); ;}
     break;
 
   case 481:
-
+#line 1676 "cgrammar.y"
     { (yyval.ctyp) = ctype_unknown; ;}
     break;
 
   case 483:
-
+#line 1682 "cgrammar.y"
     { (yyval.ctyp) = ctype_expectFunction ((yyvsp[(4) - (5)].ctyp)); ;}
     break;
 
   case 484:
-
+#line 1683 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeArray (ctype_unknown); ;}
     break;
 
   case 485:
-
+#line 1685 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeFixedArray (ctype_unknown, exprNode_getLongValue ((yyvsp[(2) - (3)].expr))); ;}
     break;
 
   case 486:
-
+#line 1686 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeInnerArray ((yyvsp[(1) - (3)].ctyp)); ;}
     break;
 
   case 487:
-
+#line 1688 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeInnerFixedArray ((yyvsp[(1) - (4)].ctyp), exprNode_getLongValue ((yyvsp[(3) - (4)].expr))); ;}
     break;
 
   case 488:
-
+#line 1690 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeFunction (ctype_unknown, uentryList_makeMissingParams ()); ;}
     break;
 
   case 489:
-
+#line 1692 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeParamsFunction (ctype_unknown, (yyvsp[(3) - (4)].entrylist)); ;}
     break;
 
   case 490:
-
+#line 1694 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeFunction ((yyvsp[(1) - (4)].ctyp), uentryList_makeMissingParams ()); ;}
     break;
 
   case 491:
-
+#line 1696 "cgrammar.y"
     { (yyval.ctyp) = ctype_makeParamsFunction ((yyvsp[(1) - (5)].ctyp), (yyvsp[(4) - (5)].entrylist)); ;}
     break;
 
   case 502:
-
+#line 1715 "cgrammar.y"
     { exprNode_revealState ((yyvsp[(3) - (4)].expr)); (yyval.expr) = exprNode_undefined; ;}
     break;
 
   case 503:
-
+#line 1719 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 506:
-
+#line 1729 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 507:
-
+#line 1734 "cgrammar.y"
     { (yyval.expr) = exprNode_while ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 508:
-
+#line 1736 "cgrammar.y"
     { (yyval.expr) = exprNode_doWhile ((yyvsp[(2) - (7)].expr), (yyvsp[(5) - (7)].expr)); ;}
     break;
 
   case 509:
-
+#line 1738 "cgrammar.y"
     { (yyval.expr) = exprNode_doWhile ((yyvsp[(2) - (6)].expr), (yyvsp[(5) - (6)].expr)); ;}
     break;
 
   case 510:
-
+#line 1740 "cgrammar.y"
     { (yyval.expr) = exprNode_for ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 511:
-
+#line 1745 "cgrammar.y"
     { context_setProtectVars (); ;}
     break;
 
   case 512:
-
+#line 1745 "cgrammar.y"
     { context_sizeofReleaseVars (); ;}
     break;
 
   case 513:
-
+#line 1747 "cgrammar.y"
     { (yyval.expr) = exprNode_forPred ((yyvsp[(3) - (10)].expr), (yyvsp[(5) - (10)].expr), (yyvsp[(8) - (10)].expr)); 
      context_enterForClause ((yyvsp[(5) - (10)].expr)); ;}
     break;
 
   case 514:
-
+#line 1753 "cgrammar.y"
     { setProcessingIterVars ((yyvsp[(1) - (3)].entry)); ;}
     break;
 
   case 515:
-
+#line 1755 "cgrammar.y"
     { (yyval.expr) = exprNode_iterStart ((yyvsp[(1) - (6)].entry), (yyvsp[(5) - (6)].exprlist)); ;}
     break;
 
   case 516:
-
+#line 1756 "cgrammar.y"
     { (yyval.expr) = exprNode_createId ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 520:
-
+#line 1763 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (2)].expr); DPRINTF (("def stmt: %s", exprNode_unparse ((yyval.expr)))); ;}
     break;
 
   case 528:
-
+#line 1771 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
     break;
 
   case 529:
-
+#line 1772 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 530:
-
+#line 1776 "cgrammar.y"
     { exprNode_checkIfPred ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 531:
-
+#line 1777 "cgrammar.y"
     { /* don't: context_exitTrueClause ($1, $2); */
      (yyval.expr) = exprNode_if ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); 
    ;}
     break;
 
   case 532:
-
+#line 1783 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 533:
-
+#line 1787 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 544:
-
+#line 1804 "cgrammar.y"
     { (yyval.expr) = exprNode_addParens ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].expr)); ;}
     break;
 
   case 547:
-
+#line 1807 "cgrammar.y"
     { (yyval.expr) = exprNode_makeError (); ;}
     break;
 
   case 548:
-
+#line 1811 "cgrammar.y"
     { (yyval.expr) = exprNode_labelMarker ((yyvsp[(1) - (2)].cname)); ;}
     break;
 
   case 549:
-
+#line 1812 "cgrammar.y"
     { (yyval.expr) = exprNode_notReached ((yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 550:
-
+#line 1820 "cgrammar.y"
     { ; ;}
     break;
 
   case 551:
-
+#line 1821 "cgrammar.y"
     { ; ;}
     break;
 
   case 552:
-
+#line 1828 "cgrammar.y"
     { context_enterCaseClause ((yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 553:
-
+#line 1829 "cgrammar.y"
     { (yyval.expr) = exprNode_caseMarker ((yyvsp[(2) - (4)].expr), FALSE); ;}
     break;
 
   case 554:
-
+#line 1830 "cgrammar.y"
     { context_enterCaseClause ((yyvsp[(4) - (4)].expr)); ;}
     break;
 
   case 555:
-
+#line 1831 "cgrammar.y"
     { (yyval.expr) = exprNode_caseMarker ((yyvsp[(4) - (6)].expr), TRUE); ;}
     break;
 
   case 556:
-
+#line 1835 "cgrammar.y"
     { context_enterCaseClause (exprNode_undefined); ;}
     break;
 
   case 557:
-
+#line 1836 "cgrammar.y"
     { (yyval.expr) = exprNode_defaultMarker ((yyvsp[(1) - (3)].tok), FALSE); ;}
     break;
 
   case 558:
-
+#line 1837 "cgrammar.y"
     { context_enterCaseClause (exprNode_undefined); ;}
     break;
 
   case 559:
-
+#line 1838 "cgrammar.y"
     { (yyval.expr) = exprNode_defaultMarker ((yyvsp[(3) - (5)].tok), TRUE); ;}
     break;
 
   case 560:
-
+#line 1842 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
     break;
 
   case 561:
-
+#line 1844 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (2)].expr); context_exitInner ((yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 562:
-
+#line 1848 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
     break;
 
   case 563:
-
+#line 1852 "cgrammar.y"
     { context_enterInnerContext (); ;}
     break;
 
   case 564:
-
+#line 1856 "cgrammar.y"
     { context_exitInnerPlain (); ;}
     break;
 
   case 565:
-
+#line 1860 "cgrammar.y"
     { context_enterStructInnerContext (); ;}
     break;
 
   case 566:
-
+#line 1864 "cgrammar.y"
     { context_exitStructInnerContext (); ;}
     break;
 
   case 567:
-
+#line 1868 "cgrammar.y"
     { context_exitInnerSafe (); ;}
     break;
 
   case 568:
-
+#line 1872 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(1) - (1)].tok)); ;}
     break;
 
   case 569:
-
+#line 1873 "cgrammar.y"
     { (yyval.expr) = exprNode_notReached (exprNode_createTok ((yyvsp[(2) - (2)].tok))); ;}
     break;
 
   case 570:
-
+#line 1874 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation ((yyvsp[(1) - (2)].expr), lltok_getLoc ((yyvsp[(2) - (2)].tok))); ;}
     break;
 
   case 571:
-
+#line 1876 "cgrammar.y"
     { (yyval.expr) = exprNode_notReached (exprNode_updateLocation ((yyvsp[(1) - (3)].expr), lltok_getLoc ((yyvsp[(3) - (3)].tok)))); ;}
     break;
 
   case 572:
-
+#line 1877 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation ((yyvsp[(1) - (2)].expr), lltok_getLoc ((yyvsp[(2) - (2)].tok))); ;}
     break;
 
   case 573:
-
+#line 1879 "cgrammar.y"
     { (yyval.expr) = exprNode_notReached (exprNode_updateLocation ((yyvsp[(1) - (3)].expr), lltok_getLoc ((yyvsp[(3) - (3)].tok)))); ;}
     break;
 
   case 574:
-
+#line 1881 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation (exprNode_concat ((yyvsp[(1) - (3)].expr), (yyvsp[(2) - (3)].expr)), lltok_getLoc ((yyvsp[(3) - (3)].tok))); ;}
     break;
 
   case 575:
-
+#line 1883 "cgrammar.y"
     { (yyval.expr) = exprNode_notReached (exprNode_updateLocation (exprNode_concat ((yyvsp[(1) - (4)].expr), (yyvsp[(2) - (4)].expr)), 
 							lltok_getLoc ((yyvsp[(3) - (4)].tok)))); 
    ;}
     break;
 
   case 576:
-
+#line 1890 "cgrammar.y"
     { (yyval.expr) = exprNode_makeBlock ((yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 577:
-
+#line 1895 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 578:
-
+#line 1897 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation ((yyvsp[(2) - (3)].expr), lltok_getLoc ((yyvsp[(3) - (3)].tok))); ;}
     break;
 
   case 579:
-
+#line 1899 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation ((yyvsp[(2) - (3)].expr), lltok_getLoc ((yyvsp[(3) - (3)].tok))); ;}
     break;
 
   case 580:
-
+#line 1901 "cgrammar.y"
     { (yyval.expr) = exprNode_updateLocation (exprNode_concat ((yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr)), lltok_getLoc ((yyvsp[(4) - (4)].tok))); ;}
     break;
 
   case 582:
-
+#line 1906 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 583:
-
+#line 1910 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 584:
-
+#line 1911 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 585:
-
+#line 1915 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 586:
-
+#line 1916 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
     break;
 
   case 587:
-
+#line 1920 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 588:
-
+#line 1921 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(2) - (4)].expr); ;}
     break;
 
   case 589:
-
+#line 1925 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 590:
-
+#line 1926 "cgrammar.y"
     { (yyval.expr) = exprNode_concat ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 591:
-
+#line 1930 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(1) - (1)].tok)); ;}
     break;
 
   case 592:
-
+#line 1931 "cgrammar.y"
     { (yyval.expr) = exprNode_statement ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 593:
-
+#line 1935 "cgrammar.y"
     { (yyval.expr) = exprNode_createTok ((yyvsp[(1) - (1)].tok)); ;}
     break;
 
   case 594:
-
+#line 1936 "cgrammar.y"
     { (yyval.expr) = exprNode_statement ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 595:
-
+#line 1937 "cgrammar.y"
     { (yyval.expr) = exprNode_checkExpr ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 596:
-
+#line 1942 "cgrammar.y"
     { 
      exprNode_produceGuards ((yyvsp[(3) - (4)].expr)); context_enterTrueClause ((yyvsp[(3) - (4)].expr)); 
      exprNode_checkIfPred ((yyvsp[(3) - (4)].expr));
@@ -7034,7 +7034,7 @@ yyreduce:
     break;
 
   case 597:
-
+#line 1956 "cgrammar.y"
     { 
      context_exitTrueClause ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr));
      (yyval.expr) = exprNode_if ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); 
@@ -7042,12 +7042,12 @@ yyreduce:
     break;
 
   case 598:
-
+#line 1960 "cgrammar.y"
     { context_enterFalseClause ((yyvsp[(1) - (3)].expr)); ;}
     break;
 
   case 599:
-
+#line 1961 "cgrammar.y"
     {
      context_exitClause ((yyvsp[(1) - (5)].expr), (yyvsp[(2) - (5)].expr), (yyvsp[(5) - (5)].expr));
      (yyval.expr) = exprNode_ifelse ((yyvsp[(1) - (5)].expr), (yyvsp[(2) - (5)].expr), (yyvsp[(5) - (5)].expr)); 
@@ -7055,37 +7055,37 @@ yyreduce:
     break;
 
   case 600:
-
+#line 1965 "cgrammar.y"
     { context_enterSwitch ((yyvsp[(3) - (3)].expr)); ;}
     break;
 
   case 601:
-
+#line 1966 "cgrammar.y"
     { (yyval.expr) = exprNode_switch ((yyvsp[(3) - (6)].expr), (yyvsp[(6) - (6)].expr)); ;}
     break;
 
   case 602:
-
+#line 1971 "cgrammar.y"
     { (yyval.expr) = exprNode_whilePred ((yyvsp[(3) - (4)].expr)); context_enterWhileClause ((yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 603:
-
+#line 1976 "cgrammar.y"
     { (yyval.expr) = exprNode_whilePred((yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 604:
-
+#line 1980 "cgrammar.y"
     { context_enterIterClause (); ;}
     break;
 
   case 605:
-
+#line 1981 "cgrammar.y"
     { setProcessingIterVars ((yyvsp[(1) - (4)].entry)); ;}
     break;
 
   case 606:
-
+#line 1984 "cgrammar.y"
     { 
      (yyval.expr) = exprNode_iter ((yyvsp[(1) - (10)].entry), (yyvsp[(6) - (10)].exprlist), (yyvsp[(8) - (10)].expr), (yyvsp[(9) - (10)].entry)); 
 
@@ -7093,32 +7093,32 @@ yyreduce:
     break;
 
   case 607:
-
+#line 1991 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_singleton ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 608:
-
+#line 1992 "cgrammar.y"
     { nextIterParam (); ;}
     break;
 
   case 609:
-
+#line 1993 "cgrammar.y"
     { (yyval.exprlist) = exprNodeList_push ((yyvsp[(1) - (4)].exprlist), (yyvsp[(4) - (4)].expr)); ;}
     break;
 
   case 610:
-
+#line 1997 "cgrammar.y"
     { (yyval.expr) = exprNode_iterExpr ((yyvsp[(1) - (1)].expr)); ;}
     break;
 
   case 611:
-
+#line 1998 "cgrammar.y"
     { (yyval.expr) = exprNode_iterId ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 612:
-
+#line 1999 "cgrammar.y"
     { uentry ue = cscannerHelp_coerceIterId ((yyvsp[(1) - (1)].cname));
 
 		      if (uentry_isValid (ue)) 
@@ -7133,433 +7133,433 @@ yyreduce:
     break;
 
   case 613:
-
+#line 2010 "cgrammar.y"
     { (yyval.expr) = exprNode_iterNewId ((yyvsp[(1) - (1)].cname)); ;}
     break;
 
   case 615:
-
+#line 2019 "cgrammar.y"
     { (yyval.expr) = exprNode_combineLiterals ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 617:
-
+#line 2024 "cgrammar.y"
     { (yyval.expr) = exprNode_addParens ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].expr)); ;}
     break;
 
   case 619:
-
+#line 2029 "cgrammar.y"
     { (yyval.expr) = exprNode_arrayFetch ((yyvsp[(1) - (4)].expr), (yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 620:
-
+#line 2030 "cgrammar.y"
     { (yyval.expr) = exprNode_functionCall ((yyvsp[(1) - (3)].expr), exprNodeList_new ()); ;}
     break;
 
   case 621:
-
+#line 2031 "cgrammar.y"
     { (yyval.expr) = exprNode_functionCall ((yyvsp[(1) - (4)].expr), (yyvsp[(3) - (4)].exprlist)); ;}
     break;
 
   case 622:
-
+#line 2033 "cgrammar.y"
     { (yyval.expr) = exprNode_vaArg ((yyvsp[(1) - (6)].tok), (yyvsp[(3) - (6)].expr), (yyvsp[(5) - (6)].qtyp)); ;}
     break;
 
   case 623:
-
+#line 2034 "cgrammar.y"
     { (yyval.expr) = exprNode_fieldAccess ((yyvsp[(1) - (5)].expr), (yyvsp[(3) - (5)].tok), (yyvsp[(4) - (5)].cname)); ;}
     break;
 
   case 624:
-
+#line 2035 "cgrammar.y"
     { (yyval.expr) = exprNode_arrowAccess ((yyvsp[(1) - (5)].expr), (yyvsp[(3) - (5)].tok), (yyvsp[(4) - (5)].cname)); ;}
     break;
 
   case 625:
-
+#line 2036 "cgrammar.y"
     { (yyval.expr) = exprNode_postOp ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 626:
-
+#line 2037 "cgrammar.y"
     { (yyval.expr) = exprNode_postOp ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].tok)); ;}
     break;
 
   case 628:
-
+#line 2042 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 629:
-
+#line 2043 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 630:
-
+#line 2044 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 631:
-
+#line 2045 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 632:
-
+#line 2046 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 633:
-
+#line 2047 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 634:
-
+#line 2048 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 635:
-
+#line 2049 "cgrammar.y"
     { (yyval.expr) = exprNode_preOp ((yyvsp[(2) - (2)].expr), (yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 636:
-
+#line 2050 "cgrammar.y"
     { (yyval.expr) = (yyvsp[(1) - (1)].expr); ;}
     break;
 
   case 638:
-
+#line 2055 "cgrammar.y"
     { (yyval.expr) = exprNode_cast ((yyvsp[(1) - (4)].tok), (yyvsp[(4) - (4)].expr), (yyvsp[(2) - (4)].qtyp)); ;}
     break;
 
   case 640:
-
+#line 2060 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 641:
-
+#line 2061 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 642:
-
+#line 2062 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 644:
-
+#line 2067 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 645:
-
+#line 2068 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 647:
-
+#line 2073 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 648:
-
+#line 2074 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 650:
-
+#line 2079 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 651:
-
+#line 2080 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 652:
-
+#line 2081 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 653:
-
+#line 2082 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 655:
-
+#line 2087 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 656:
-
+#line 2088 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 658:
-
+#line 2093 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 660:
-
+#line 2098 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 662:
-
+#line 2103 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 664:
-
+#line 2108 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 666:
-
+#line 2113 "cgrammar.y"
     { (yyval.expr) = exprNode_op ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 668:
-
+#line 2118 "cgrammar.y"
     { context_enterTrueClause ((yyvsp[(1) - (2)].expr)); ;}
     break;
 
   case 669:
-
+#line 2119 "cgrammar.y"
     { context_enterFalseClause ((yyvsp[(1) - (4)].expr)); ;}
     break;
 
   case 670:
-
+#line 2120 "cgrammar.y"
     { (yyval.expr) = exprNode_condIfOmit ((yyvsp[(1) - (6)].expr), (yyvsp[(6) - (6)].expr)); ;}
     break;
 
   case 671:
-
+#line 2121 "cgrammar.y"
     { context_enterTrueClause ((yyvsp[(1) - (2)].expr)); ;}
     break;
 
   case 672:
-
+#line 2122 "cgrammar.y"
     { context_enterFalseClause ((yyvsp[(1) - (5)].expr)); ;}
     break;
 
   case 673:
-
+#line 2123 "cgrammar.y"
     { (yyval.expr) = exprNode_cond ((yyvsp[(1) - (7)].expr), (yyvsp[(4) - (7)].expr), (yyvsp[(7) - (7)].expr)); ;}
     break;
 
   case 675:
-
+#line 2128 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 676:
-
+#line 2129 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 677:
-
+#line 2130 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 678:
-
+#line 2131 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 679:
-
+#line 2132 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 680:
-
+#line 2133 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 681:
-
+#line 2134 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 682:
-
+#line 2135 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 683:
-
+#line 2136 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 684:
-
+#line 2137 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 685:
-
+#line 2138 "cgrammar.y"
     { (yyval.expr) = exprNode_assign ((yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), (yyvsp[(2) - (3)].tok)); ;}
     break;
 
   case 686:
-
+#line 2142 "cgrammar.y"
     { (yyval.entry) = (yyvsp[(1) - (1)].entry); ;}
     break;
 
   case 687:
-
+#line 2143 "cgrammar.y"
     { (yyval.entry) = uentry_undefined; ;}
     break;
 
   case 688:
-
+#line 2147 "cgrammar.y"
     { context_enterDoWhileClause (); (yyval.tok) = (yyvsp[(1) - (1)].tok); ;}
     break;
 
   case 689:
-
+#line 2152 "cgrammar.y"
     { (yyval.expr) = exprNode_while ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); context_exitWhileClause ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 690:
-
+#line 2154 "cgrammar.y"
     { (yyval.expr) = exprNode_statement (exprNode_doWhile ((yyvsp[(2) - (7)].expr), (yyvsp[(5) - (7)].expr)), (yyvsp[(7) - (7)].tok)); ;}
     break;
 
   case 691:
-
+#line 2156 "cgrammar.y"
     { (yyval.expr) = exprNode_for ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); context_exitForClause ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 692:
-
+#line 2160 "cgrammar.y"
     { (yyval.expr) = exprNode_while ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); context_exitWhileClause ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 693:
-
+#line 2162 "cgrammar.y"
     { (yyval.expr) = exprNode_statement (exprNode_doWhile ((yyvsp[(2) - (7)].expr), (yyvsp[(5) - (7)].expr)), (yyvsp[(7) - (7)].tok)); ;}
     break;
 
   case 694:
-
+#line 2164 "cgrammar.y"
     { (yyval.expr) = exprNode_doWhile ((yyvsp[(2) - (6)].expr), (yyvsp[(5) - (6)].expr)); ;}
     break;
 
   case 695:
-
+#line 2165 "cgrammar.y"
     { (yyval.expr) = exprNode_for ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); context_exitForClause ((yyvsp[(1) - (2)].expr), (yyvsp[(2) - (2)].expr)); ;}
     break;
 
   case 696:
-
+#line 2169 "cgrammar.y"
     { (yyval.expr) = exprNode_goto ((yyvsp[(2) - (3)].cname)); ;}
     break;
 
   case 697:
-
+#line 2170 "cgrammar.y"
     { (yyval.expr) = exprNode_continue ((yyvsp[(1) - (2)].tok), BADTOK); ;}
     break;
 
   case 698:
-
+#line 2172 "cgrammar.y"
     { (yyval.expr) = exprNode_continue ((yyvsp[(1) - (3)].tok), QINNERCONTINUE); ;}
     break;
 
   case 699:
-
+#line 2173 "cgrammar.y"
     { (yyval.expr) = exprNode_break ((yyvsp[(1) - (2)].tok), BADTOK); ;}
     break;
 
   case 700:
-
+#line 2174 "cgrammar.y"
     { (yyval.expr) = exprNode_break ((yyvsp[(2) - (3)].tok), QSWITCHBREAK); ;}
     break;
 
   case 701:
-
+#line 2175 "cgrammar.y"
     { (yyval.expr) = exprNode_break ((yyvsp[(2) - (3)].tok), QLOOPBREAK); ;}
     break;
 
   case 702:
-
+#line 2176 "cgrammar.y"
     { (yyval.expr) = exprNode_break ((yyvsp[(2) - (3)].tok), QINNERBREAK); ;}
     break;
 
   case 703:
-
+#line 2177 "cgrammar.y"
     { (yyval.expr) = exprNode_break ((yyvsp[(2) - (3)].tok), QSAFEBREAK); ;}
     break;
 
   case 704:
-
+#line 2178 "cgrammar.y"
     { (yyval.expr) = exprNode_nullReturn ((yyvsp[(1) - (2)].tok)); ;}
     break;
 
   case 705:
-
+#line 2179 "cgrammar.y"
     { (yyval.expr) = exprNode_return ((yyvsp[(2) - (3)].expr)); ;}
     break;
 
   case 707:
-
+#line 2184 "cgrammar.y"
     { ; ;}
     break;
 
   case 709:
-
+#line 2189 "cgrammar.y"
     { ; ;}
     break;
 
   case 712:
-
+#line 2198 "cgrammar.y"
     { (yyval.cname) = uentry_getName ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 713:
-
+#line 2199 "cgrammar.y"
     { (yyval.cname) = uentry_getName ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 714:
-
+#line 2200 "cgrammar.y"
     { (yyval.cname) = uentry_getName ((yyvsp[(1) - (1)].entry)); ;}
     break;
 
   case 715:
-
+#line 2201 "cgrammar.y"
     { (yyval.cname) = (yyvsp[(1) - (1)].cname); ;}
     break;
 
   case 717:
-
+#line 2206 "cgrammar.y"
     { (yyval.ctyp) = ctype_unknown; ;}
     break;
 
   case 718:
-
+#line 2207 "cgrammar.y"
     { (yyval.ctyp) = exprNode_getType ((yyvsp[(3) - (4)].expr)); exprNode_free ((yyvsp[(3) - (4)].expr)); ;}
     break;
 
   case 719:
-
+#line 2208 "cgrammar.y"
     { (yyval.ctyp) = qtype_getType ((yyvsp[(3) - (4)].qtyp)); ;}
     break;
 
 
 /* Line 1267 of yacc.c.  */
-
+#line 7505 "cgrammar.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -7773,7 +7773,7 @@ yyreturn:
 }
 
 
-
+#line 2211 "cgrammar.y"
 
 
 /*@-redecl@*/ /*@-namechecks@*/
diff --git a/src/constraintGeneration.c b/src/constraintGeneration.c
index ac420eb..73fcd44 100644
--- a/src/constraintGeneration.c
+++ b/src/constraintGeneration.c
@@ -1428,6 +1428,10 @@ void exprNode_exprTraverse (/*@dependent@*/ exprNode e,
 	{
 	  break;
 	}
+      else if (lltok_isPlus_Op (tok))
+	{
+	  break;
+	}
       else if (lltok_isExcl_Op (tok))
 	{
 	  break;
diff --git a/src/llgrammar.c.der b/src/llgrammar.c.der
index 409ba91..7339b8f 100644
--- a/src/llgrammar.c.der
+++ b/src/llgrammar.c.der
@@ -408,7 +408,7 @@
 
 
 /* Copy the first part of user declarations.  */
-
+#line 27 "llgrammar.y"
 
 
 # include "splintMacros.nf"
@@ -471,7 +471,7 @@ bool g_inTypeDef = FALSE;
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
+#line 72 "llgrammar.y"
 {
   ltoken ltok;  /* a leaf is also an ltoken */
   qual typequal;
@@ -538,8 +538,8 @@ typedef union YYSTYPE
   /*@only@*/ CTypesNode ctypes;
   /*@-redef@*/
 }
-/* Line 193 of yacc.c.  */
-
+/* Line 187 of yacc.c.  */
+#line 485 "llgrammar.tab.c"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
@@ -552,7 +552,7 @@ typedef union YYSTYPE
 
 
 /* Line 216 of yacc.c.  */
-
+#line 498 "llgrammar.tab.c"
 
 #ifdef short
 # undef short
@@ -2996,209 +2996,209 @@ yyreduce:
   switch (yyn)
     {
         case 2:
-
+#line 382 "llgrammar.y"
     { lhExternals ((yyvsp[(1) - (1)].interfacelist)); ;}
     break;
 
   case 3:
-
+#line 383 "llgrammar.y"
     { interfaceNodeList_free ((yyvsp[(1) - (3)].interfacelist)); interfaceNodeList_free ((yyvsp[(3) - (3)].interfacelist)); ;}
     break;
 
   case 4:
-
+#line 387 "llgrammar.y"
     { (yyval.interfacelist) = interfaceNodeList_new (); ;}
     break;
 
   case 5:
-
+#line 388 "llgrammar.y"
     { (yyval.interfacelist) = interfaceNodeList_addh ((yyvsp[(1) - (2)].interfacelist), (yyvsp[(2) - (2)].iface));;}
     break;
 
   case 8:
-
+#line 397 "llgrammar.y"
     { (yyval.interfacelist) = interfaceNodeList_new (); ;}
     break;
 
   case 9:
-
+#line 398 "llgrammar.y"
     { (yyval.interfacelist) = consInterfaceNode ((yyvsp[(1) - (2)].iface), (yyvsp[(2) - (2)].interfacelist));;}
     break;
 
   case 10:
-
+#line 399 "llgrammar.y"
     { (yyval.interfacelist) = consInterfaceNode ((yyvsp[(1) - (2)].iface), (yyvsp[(2) - (2)].interfacelist));;}
     break;
 
   case 11:
-
+#line 403 "llgrammar.y"
     { (yyval.interfacelist) = interfaceNodeList_new (); ;}
     break;
 
   case 12:
-
+#line 404 "llgrammar.y"
     { (yyval.interfacelist) = interfaceNodeList_addh ((yyvsp[(1) - (2)].interfacelist), (yyvsp[(2) - (2)].iface));;}
     break;
 
   case 16:
-
+#line 415 "llgrammar.y"
     { (yyval.iface) = makeInterfaceNodeImports ((yyvsp[(2) - (3)].importlist));
      /* assume subspecs are already processed, symbol table info in external file */
    ;}
     break;
 
   case 17:
-
+#line 422 "llgrammar.y"
     { (yyval.iface) = makeInterfaceNodeUses ((yyvsp[(2) - (3)].traitreflist)); readlsignatures ((yyval.iface));;}
     break;
 
   case 18:
-
+#line 427 "llgrammar.y"
     { declareConstant ((yyvsp[(1) - (1)].constdeclaration)); (yyval.iface) = interfaceNode_makeConst ((yyvsp[(1) - (1)].constdeclaration)); ;}
     break;
 
   case 19:
-
+#line 429 "llgrammar.y"
     { declareVar ((yyvsp[(1) - (1)].vardeclaration)); (yyval.iface) = interfaceNode_makeVar ((yyvsp[(1) - (1)].vardeclaration)); ;}
     break;
 
   case 20:
-
+#line 431 "llgrammar.y"
     { declareType ((yyvsp[(1) - (1)].type)); (yyval.iface) = interfaceNode_makeType ((yyvsp[(1) - (1)].type)); ;}
     break;
 
   case 21:
-
+#line 433 "llgrammar.y"
     { declareFcn ((yyvsp[(1) - (1)].fcn), typeId_invalid); (yyval.iface) = interfaceNode_makeFcn ((yyvsp[(1) - (1)].fcn)); ;}
     break;
 
   case 22:
-
+#line 435 "llgrammar.y"
     { (yyval.iface) = interfaceNode_makeClaim ((yyvsp[(1) - (1)].claim)); ;}
     break;
 
   case 23:
-
+#line 437 "llgrammar.y"
     { declareIter ((yyvsp[(1) - (1)].iter)); (yyval.iface) = interfaceNode_makeIter ((yyvsp[(1) - (1)].iter)); ;}
     break;
 
   case 24:
-
+#line 442 "llgrammar.y"
     { (yyval.iter) = makeIterNode ((yyvsp[(2) - (6)].ltok), (yyvsp[(4) - (6)].paramlist)); ;}
     break;
 
   case 25:
-
+#line 446 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_new (); ;}
     break;
 
   case 26:
-
+#line 447 "llgrammar.y"
     { (yyval.paramlist) = (yyvsp[(1) - (1)].paramlist); ;}
     break;
 
   case 27:
-
+#line 452 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_add (paramNodeList_new (),  (yyvsp[(1) - (1)].param)); ;}
     break;
 
   case 28:
-
+#line 454 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_add ((yyvsp[(1) - (3)].paramlist),(yyvsp[(3) - (3)].param)); ;}
     break;
 
   case 29:
-
+#line 458 "llgrammar.y"
     { (yyval.param) = markYieldParamNode ((yyvsp[(2) - (2)].param)); ;}
     break;
 
   case 30:
-
+#line 459 "llgrammar.y"
     { (yyval.param) = (yyvsp[(1) - (1)].param); ;}
     break;
 
   case 31:
-
+#line 463 "llgrammar.y"
     { symtable_export (g_symtab, FALSE); ;}
     break;
 
   case 32:
-
+#line 464 "llgrammar.y"
     { (yyval.iface) = (yyvsp[(3) - (3)].iface); symtable_export (g_symtab, TRUE); ;}
     break;
 
   case 33:
-
+#line 469 "llgrammar.y"
     { declarePrivConstant ((yyvsp[(1) - (1)].constdeclaration)); (yyval.iface) =  interfaceNode_makePrivConst ((yyvsp[(1) - (1)].constdeclaration)); ;}
     break;
 
   case 34:
-
+#line 471 "llgrammar.y"
     { declarePrivVar ((yyvsp[(1) - (1)].vardeclaration)); (yyval.iface) = interfaceNode_makePrivVar ((yyvsp[(1) - (1)].vardeclaration)); ;}
     break;
 
   case 35:
-
+#line 473 "llgrammar.y"
     { declarePrivType ((yyvsp[(1) - (1)].type)); (yyval.iface) = interfaceNode_makePrivType ((yyvsp[(1) - (1)].type)); ;}
     break;
 
   case 36:
-
+#line 475 "llgrammar.y"
     { declarePrivFcn ((yyvsp[(1) - (1)].fcn), typeId_invalid); (yyval.iface) = interfaceNode_makePrivFcn ((yyvsp[(1) - (1)].fcn)); ;}
     break;
 
   case 37:
-
+#line 480 "llgrammar.y"
     { (yyval.constdeclaration) = makeConstDeclarationNode ((yyvsp[(2) - (4)].lcltypespec), (yyvsp[(3) - (4)].initdecls)); ;}
     break;
 
   case 38:
-
+#line 485 "llgrammar.y"
     { (yyval.vardeclaration) = makeVarDeclarationNode ((yyvsp[(1) - (3)].lcltypespec), (yyvsp[(2) - (3)].initdecls), FALSE, FALSE); (yyval.vardeclaration)->qualifier = QLF_NONE; ;}
     break;
 
   case 39:
-
+#line 487 "llgrammar.y"
     { (yyval.vardeclaration) = makeVarDeclarationNode ((yyvsp[(2) - (4)].lcltypespec), (yyvsp[(3) - (4)].initdecls), FALSE, FALSE); (yyval.vardeclaration)->qualifier = QLF_CONST; ;}
     break;
 
   case 40:
-
+#line 489 "llgrammar.y"
     { (yyval.vardeclaration) = makeVarDeclarationNode ((yyvsp[(2) - (4)].lcltypespec), (yyvsp[(3) - (4)].initdecls), FALSE, FALSE); (yyval.vardeclaration)->qualifier = QLF_VOLATILE; ;}
     break;
 
   case 41:
-
+#line 493 "llgrammar.y"
     { (yyval.type) = makeAbstractTypeNode ((yyvsp[(1) - (1)].abstract)); ;}
     break;
 
   case 42:
-
+#line 494 "llgrammar.y"
     { (yyval.type) = makeExposedTypeNode ((yyvsp[(1) - (1)].exposed)); ;}
     break;
 
   case 43:
-
+#line 498 "llgrammar.y"
     { (yyval.typequal) = qual_createPrintfLike (); ;}
     break;
 
   case 44:
-
+#line 499 "llgrammar.y"
     { (yyval.typequal) = qual_createScanfLike (); ;}
     break;
 
   case 45:
-
+#line 500 "llgrammar.y"
     { (yyval.typequal) = qual_createMessageLike (); ;}
     break;
 
   case 46:
-
+#line 504 "llgrammar.y"
     { enteringFcnScope ((yyvsp[(1) - (3)].lcltypespec), (yyvsp[(2) - (3)].declare), (yyvsp[(3) - (3)].globals)); ;}
     break;
 
   case 47:
-
+#line 506 "llgrammar.y"
     { (yyval.fcn) = makeFcnNode (qual_createUnknown (),  (yyvsp[(1) - (13)].lcltypespec), (yyvsp[(2) - (13)].declare), (yyvsp[(3) - (13)].globals), (yyvsp[(6) - (13)].vardeclarationlist), (yyvsp[(7) - (13)].letdecls), 
 		       (yyvsp[(8) - (13)].lclpredicate), (yyvsp[(9) - (13)].lclpredicate), (yyvsp[(10) - (13)].modify), (yyvsp[(11) - (13)].lclpredicate), (yyvsp[(12) - (13)].lclpredicate)); 
      /* type, declarator, glovbls, privateinits,
@@ -3208,12 +3208,12 @@ yyreduce:
     break;
 
   case 48:
-
+#line 512 "llgrammar.y"
     { enteringFcnScope ((yyvsp[(2) - (4)].lcltypespec), (yyvsp[(3) - (4)].declare), (yyvsp[(4) - (4)].globals)); ;}
     break;
 
   case 49:
-
+#line 516 "llgrammar.y"
     { (yyval.fcn) = makeFcnNode ((yyvsp[(1) - (14)].typequal), (yyvsp[(2) - (14)].lcltypespec), (yyvsp[(3) - (14)].declare), (yyvsp[(4) - (14)].globals), (yyvsp[(7) - (14)].vardeclarationlist), 
 		       (yyvsp[(8) - (14)].letdecls), (yyvsp[(9) - (14)].lclpredicate), (yyvsp[(10) - (14)].lclpredicate), (yyvsp[(11) - (14)].modify), (yyvsp[(12) - (14)].lclpredicate), (yyvsp[(13) - (14)].lclpredicate)); 
      /* type, declarator, glovbls, privateinits,
@@ -3223,484 +3223,484 @@ yyreduce:
     break;
 
   case 50:
-
+#line 526 "llgrammar.y"
     { enteringClaimScope ((yyvsp[(4) - (6)].paramlist), (yyvsp[(6) - (6)].globals)); ;}
     break;
 
   case 51:
-
+#line 528 "llgrammar.y"
     {      (yyval.claim) = makeClaimNode ((yyvsp[(2) - (13)].ltok), (yyvsp[(4) - (13)].paramlist), (yyvsp[(6) - (13)].globals), (yyvsp[(9) - (13)].letdecls), (yyvsp[(10) - (13)].lclpredicate), (yyvsp[(11) - (13)].program), (yyvsp[(12) - (13)].lclpredicate)); 
      symtable_exitScope (g_symtab); ;}
     break;
 
   case 52:
-
+#line 531 "llgrammar.y"
     { (yyval.claim) = (claimNode) 0; ;}
     break;
 
   case 53:
-
+#line 535 "llgrammar.y"
     {g_inTypeDef = TRUE; ;}
     break;
 
   case 54:
-
+#line 535 "llgrammar.y"
     {g_inTypeDef = FALSE; ;}
     break;
 
   case 55:
-
+#line 536 "llgrammar.y"
     { (yyval.abstract) = makeAbstractNode ((yyvsp[(1) - (6)].ltok), (yyvsp[(4) - (6)].ltok), TRUE, FALSE, (yyvsp[(6) - (6)].abstbody)); ;}
     break;
 
   case 56:
-
+#line 537 "llgrammar.y"
     {g_inTypeDef = TRUE; ;}
     break;
 
   case 57:
-
+#line 538 "llgrammar.y"
     {g_inTypeDef = FALSE; ;}
     break;
 
   case 58:
-
+#line 539 "llgrammar.y"
     { (yyval.abstract) = makeAbstractNode ((yyvsp[(1) - (7)].ltok), (yyvsp[(5) - (7)].ltok), TRUE, TRUE, (yyvsp[(7) - (7)].abstbody)); ;}
     break;
 
   case 59:
-
+#line 540 "llgrammar.y"
     {g_inTypeDef = TRUE; ;}
     break;
 
   case 60:
-
+#line 541 "llgrammar.y"
     {g_inTypeDef = FALSE; ;}
     break;
 
   case 61:
-
+#line 542 "llgrammar.y"
     { (yyval.abstract) = makeAbstractNode ((yyvsp[(2) - (7)].ltok), (yyvsp[(5) - (7)].ltok), TRUE, TRUE, (yyvsp[(7) - (7)].abstbody)); ;}
     break;
 
   case 62:
-
+#line 543 "llgrammar.y"
     {g_inTypeDef = TRUE; ;}
     break;
 
   case 63:
-
+#line 543 "llgrammar.y"
     {g_inTypeDef = FALSE; ;}
     break;
 
   case 64:
-
+#line 544 "llgrammar.y"
     { (yyval.abstract) = makeAbstractNode ((yyvsp[(1) - (6)].ltok), (yyvsp[(4) - (6)].ltok), FALSE, FALSE, (yyvsp[(6) - (6)].abstbody)); ;}
     break;
 
   case 65:
-
+#line 548 "llgrammar.y"
     { g_inTypeDef = TRUE; setExposedType ((yyvsp[(2) - (2)].lcltypespec)); ;}
     break;
 
   case 66:
-
+#line 549 "llgrammar.y"
     { g_inTypeDef = FALSE; ;}
     break;
 
   case 67:
-
+#line 550 "llgrammar.y"
     { (yyval.exposed) = makeExposedNode ((yyvsp[(1) - (6)].ltok), (yyvsp[(2) - (6)].lcltypespec), (yyvsp[(4) - (6)].declaratorinvs)); /* to support mutually recursive types */ ;}
     break;
 
   case 68:
-
+#line 552 "llgrammar.y"
     { (yyval.exposed) = makeExposedNode ((yyvsp[(2) - (2)].ltok), makeLclTypeSpecNodeSU ((yyvsp[(1) - (2)].structorunion)), declaratorInvNodeList_new ()); ;}
     break;
 
   case 69:
-
+#line 554 "llgrammar.y"
     { (yyval.exposed) = makeExposedNode ((yyvsp[(2) - (2)].ltok), makeLclTypeSpecNodeEnum ((yyvsp[(1) - (2)].enumspec)), declaratorInvNodeList_new ()); ;}
     break;
 
   case 70:
-
+#line 571 "llgrammar.y"
     { (yyval.importlist) = importNodeList_add (importNodeList_new (),  (yyvsp[(1) - (1)].import)); ;}
     break;
 
   case 71:
-
+#line 573 "llgrammar.y"
     { (yyval.importlist) = importNodeList_add ((yyvsp[(1) - (3)].importlist), (yyvsp[(3) - (3)].import)); ;}
     break;
 
   case 72:
-
+#line 577 "llgrammar.y"
     { (yyval.import) = importNode_makePlain ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 73:
-
+#line 579 "llgrammar.y"
     { checkBrackets ((yyvsp[(1) - (3)].ltok), (yyvsp[(3) - (3)].ltok)); (yyval.import) = importNode_makeBracketed ((yyvsp[(2) - (3)].ltok)); ;}
     break;
 
   case 74:
-
+#line 580 "llgrammar.y"
     { (yyval.import) = importNode_makeQuoted ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 75:
-
+#line 584 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 76:
-
+#line 585 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 78:
-
+#line 595 "llgrammar.y"
     { (yyval.traitreflist) = traitRefNodeList_add (traitRefNodeList_new (),  (yyvsp[(1) - (1)].traitref)); ;}
     break;
 
   case 79:
-
+#line 597 "llgrammar.y"
     { (yyval.traitreflist) = traitRefNodeList_add ((yyvsp[(1) - (3)].traitreflist), (yyvsp[(3) - (3)].traitref)); ;}
     break;
 
   case 80:
-
+#line 602 "llgrammar.y"
     { (yyval.traitref) = makeTraitRefNode (ltokenList_singleton ((yyvsp[(1) - (1)].ltok)), (renamingNode)0); ;}
     break;
 
   case 81:
-
+#line 604 "llgrammar.y"
     { (yyval.traitref) = makeTraitRefNode (ltokenList_singleton ((yyvsp[(1) - (4)].ltok)), (yyvsp[(3) - (4)].renaming)); ;}
     break;
 
   case 82:
-
+#line 606 "llgrammar.y"
     { (yyval.traitref) = makeTraitRefNode ((yyvsp[(2) - (3)].ltokenList), (renamingNode)0); ;}
     break;
 
   case 83:
-
+#line 608 "llgrammar.y"
     { (yyval.traitref) = makeTraitRefNode ((yyvsp[(2) - (6)].ltokenList), (yyvsp[(5) - (6)].renaming)); ;}
     break;
 
   case 84:
-
+#line 612 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 85:
-
+#line 613 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 86:
-
+#line 618 "llgrammar.y"
     { (yyval.renaming) = makeRenamingNode (typeNameNodeList_new (),  (yyvsp[(1) - (1)].replacelist)); ;}
     break;
 
   case 87:
-
+#line 620 "llgrammar.y"
     { (yyval.renaming) = makeRenamingNode ((yyvsp[(1) - (1)].namelist), replaceNodeList_new ()); ;}
     break;
 
   case 88:
-
+#line 621 "llgrammar.y"
     { (yyval.renaming) = makeRenamingNode ((yyvsp[(1) - (3)].namelist), (yyvsp[(3) - (3)].replacelist)); ;}
     break;
 
   case 89:
-
+#line 626 "llgrammar.y"
     { (yyval.namelist) = typeNameNodeList_add (typeNameNodeList_new (),  (yyvsp[(1) - (1)].typname)); ;}
     break;
 
   case 90:
-
+#line 627 "llgrammar.y"
     { (yyval.namelist) = typeNameNodeList_add ((yyvsp[(1) - (3)].namelist), (yyvsp[(3) - (3)].typname)); ;}
     break;
 
   case 91:
-
+#line 632 "llgrammar.y"
     { (yyval.replacelist) = replaceNodeList_add (replaceNodeList_new (),  (yyvsp[(1) - (1)].replace)); ;}
     break;
 
   case 92:
-
+#line 633 "llgrammar.y"
     { (yyval.replacelist) = replaceNodeList_add ((yyvsp[(1) - (3)].replacelist), (yyvsp[(3) - (3)].replace)); ;}
     break;
 
   case 93:
-
+#line 637 "llgrammar.y"
     { (yyval.replace) = makeReplaceNode ((yyvsp[(2) - (3)].ltok), (yyvsp[(1) - (3)].typname), TRUE, (yyvsp[(3) - (3)].ltok), NULL, NULL); ;}
     break;
 
   case 94:
-
+#line 638 "llgrammar.y"
     { (yyval.replace) = makeReplaceNameNode ((yyvsp[(2) - (3)].ltok), (yyvsp[(1) - (3)].typname), (yyvsp[(3) - (3)].name)); ;}
     break;
 
   case 95:
-
+#line 639 "llgrammar.y"
     { (yyval.replace) = makeReplaceNode ((yyvsp[(2) - (4)].ltok), (yyvsp[(1) - (4)].typname), FALSE, ltoken_undefined,
 							 (yyvsp[(3) - (4)].name), (yyvsp[(4) - (4)].signature)); ;}
     break;
 
   case 96:
-
+#line 644 "llgrammar.y"
     { (yyval.name) = makeNameNodeId ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 97:
-
+#line 645 "llgrammar.y"
     { (yyval.name) = makeNameNodeForm ((yyvsp[(1) - (1)].opform)); ;}
     break;
 
   case 100:
-
+#line 656 "llgrammar.y"
     { (yyval.initdecls) = initDeclNodeList_add (initDeclNodeList_new (),  (yyvsp[(1) - (1)].initdecl)); ;}
     break;
 
   case 101:
-
+#line 658 "llgrammar.y"
     { (yyval.initdecls) = initDeclNodeList_add ((yyvsp[(1) - (3)].initdecls), (yyvsp[(3) - (3)].initdecl)); ;}
     break;
 
   case 102:
-
+#line 662 "llgrammar.y"
     { (yyval.initdecl) = makeInitDeclNode ((yyvsp[(1) - (1)].declare), (termNode)0); ;}
     break;
 
   case 103:
-
+#line 663 "llgrammar.y"
     { (yyval.initdecl) = makeInitDeclNode ((yyvsp[(1) - (3)].declare), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 104:
-
+#line 668 "llgrammar.y"
     { (yyval.globals) = varDeclarationNodeList_new (); ;}
     break;
 
   case 105:
-
+#line 670 "llgrammar.y"
     { varDeclarationNodeList_addh ((yyvsp[(1) - (2)].globals), (yyvsp[(2) - (2)].vardeclaration)); (yyval.globals) = (yyvsp[(1) - (2)].globals); ;}
     break;
 
   case 106:
-
+#line 674 "llgrammar.y"
     { (yyval.vardeclaration) = makeVarDeclarationNode ((yyvsp[(1) - (3)].lcltypespec), (yyvsp[(2) - (3)].initdecls), TRUE, FALSE); ;}
     break;
 
   case 107:
-
+#line 675 "llgrammar.y"
     { (yyval.vardeclaration) = makeInternalStateNode (); ;}
     break;
 
   case 108:
-
+#line 676 "llgrammar.y"
     { (yyval.vardeclaration) = makeFileSystemNode (); ;}
     break;
 
   case 109:
-
+#line 680 "llgrammar.y"
     { (yyval.vardeclarationlist) = varDeclarationNodeList_new (); ;}
     break;
 
   case 110:
-
+#line 681 "llgrammar.y"
     { varDeclarationNodeList_addh ((yyvsp[(1) - (2)].vardeclarationlist), (yyvsp[(2) - (2)].vardeclaration)); (yyval.vardeclarationlist) = (yyvsp[(1) - (2)].vardeclarationlist); ;}
     break;
 
   case 111:
-
+#line 686 "llgrammar.y"
     { (yyval.vardeclaration) = makeVarDeclarationNode ((yyvsp[(2) - (4)].lcltypespec), (yyvsp[(3) - (4)].initdecls), FALSE, TRUE); ;}
     break;
 
   case 112:
-
+#line 690 "llgrammar.y"
     { (yyval.letdecls) = letDeclNodeList_new (); ;}
     break;
 
   case 113:
-
+#line 691 "llgrammar.y"
     { (yyval.letdecls) = (yyvsp[(2) - (3)].letdecls); ;}
     break;
 
   case 114:
-
+#line 695 "llgrammar.y"
     { (yyval.letdecls) = letDeclNodeList_add (letDeclNodeList_new (),  (yyvsp[(1) - (1)].letdecl)); ;}
     break;
 
   case 115:
-
+#line 696 "llgrammar.y"
     { (yyval.letdecls) = letDeclNodeList_add ((yyvsp[(1) - (3)].letdecls), (yyvsp[(3) - (3)].letdecl)); ;}
     break;
 
   case 116:
-
+#line 700 "llgrammar.y"
     { (yyval.letdecl) = makeLetDeclNode ((yyvsp[(1) - (5)].ltok), (yyvsp[(3) - (5)].lcltypespec), (yyvsp[(5) - (5)].term)); ;}
     break;
 
   case 117:
-
+#line 701 "llgrammar.y"
     { (yyval.letdecl) = makeLetDeclNode ((yyvsp[(1) - (3)].ltok), (lclTypeSpecNode)0, (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 119:
-
+#line 708 "llgrammar.y"
     { (yyval.lclpredicate) = (lclPredicateNode)0; ;}
     break;
 
   case 120:
-
+#line 709 "llgrammar.y"
     { checkLclPredicate ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); (yyval.lclpredicate) = makeChecksNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); ;}
     break;
 
   case 121:
-
+#line 713 "llgrammar.y"
     { (yyval.lclpredicate) = (lclPredicateNode)0; ;}
     break;
 
   case 122:
-
+#line 714 "llgrammar.y"
     { checkLclPredicate ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); (yyval.lclpredicate) = makeRequiresNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate));;}
     break;
 
   case 123:
-
+#line 718 "llgrammar.y"
     { (yyval.modify) = (modifyNode)0; ;}
     break;
 
   case 124:
-
+#line 719 "llgrammar.y"
     { (yyval.modify) = makeModifyNodeSpecial ((yyvsp[(1) - (3)].ltok), TRUE); ;}
     break;
 
   case 125:
-
+#line 720 "llgrammar.y"
     { (yyval.modify) = makeModifyNodeSpecial ((yyvsp[(1) - (3)].ltok), FALSE); ;}
     break;
 
   case 126:
-
+#line 721 "llgrammar.y"
     { (yyval.modify) = makeModifyNodeRef ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].storereflist)); ;}
     break;
 
   case 127:
-
+#line 725 "llgrammar.y"
     { (yyval.storereflist) = storeRefNodeList_add (storeRefNodeList_new (),  (yyvsp[(1) - (1)].storeref)); ;}
     break;
 
   case 128:
-
+#line 726 "llgrammar.y"
     { (yyval.storereflist) = storeRefNodeList_add ((yyvsp[(1) - (3)].storereflist), (yyvsp[(3) - (3)].storeref)); ;}
     break;
 
   case 129:
-
+#line 730 "llgrammar.y"
     { (yyval.storeref) = makeStoreRefNodeTerm ((yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 130:
-
+#line 731 "llgrammar.y"
     { (yyval.storeref) = makeStoreRefNodeType ((yyvsp[(1) - (1)].lcltypespec), FALSE); ;}
     break;
 
   case 131:
-
+#line 732 "llgrammar.y"
     { (yyval.storeref) = makeStoreRefNodeType ((yyvsp[(2) - (2)].lcltypespec), TRUE); ;}
     break;
 
   case 132:
-
+#line 733 "llgrammar.y"
     { (yyval.storeref) = makeStoreRefNodeInternal (); ;}
     break;
 
   case 133:
-
+#line 734 "llgrammar.y"
     { (yyval.storeref) = makeStoreRefNodeSystem (); ;}
     break;
 
   case 134:
-
+#line 738 "llgrammar.y"
     { (yyval.lclpredicate) = (lclPredicateNode)0; ;}
     break;
 
   case 135:
-
+#line 739 "llgrammar.y"
     { checkLclPredicate ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); (yyval.lclpredicate) = makeEnsuresNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate));;}
     break;
 
   case 136:
-
+#line 743 "llgrammar.y"
     { (yyval.lclpredicate) = (lclPredicateNode)0; ;}
     break;
 
   case 137:
-
+#line 744 "llgrammar.y"
     { checkLclPredicate ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); (yyval.lclpredicate) = makeIntraClaimNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate));;}
     break;
 
   case 138:
-
+#line 748 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_new (); ;}
     break;
 
   case 139:
-
+#line 749 "llgrammar.y"
     { (yyval.paramlist) = (yyvsp[(1) - (1)].paramlist); ;}
     break;
 
   case 141:
-
+#line 754 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_add (paramNodeList_new (),  paramNode_elipsis ()); ;}
     break;
 
   case 142:
-
+#line 755 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_add ((yyvsp[(1) - (3)].paramlist), paramNode_elipsis ()); ;}
     break;
 
   case 143:
-
+#line 759 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_single ((yyvsp[(1) - (1)].param)); ;}
     break;
 
   case 144:
-
+#line 760 "llgrammar.y"
     { (yyval.paramlist) = paramNodeList_add ((yyvsp[(1) - (3)].paramlist), (yyvsp[(3) - (3)].param)); ;}
     break;
 
   case 145:
-
+#line 764 "llgrammar.y"
     { (yyval.program) = (programNode)0; ;}
     break;
 
   case 146:
-
+#line 765 "llgrammar.y"
     { (yyval.program) = (yyvsp[(3) - (4)].program); ;}
     break;
 
   case 147:
-
+#line 766 "llgrammar.y"
     { (yyval.program) = (yyvsp[(3) - (5)].program); ;}
     break;
 
   case 148:
-
+#line 770 "llgrammar.y"
     { (yyval.program) = makeProgramNode ((yyvsp[(1) - (1)].stmt)); ;}
     break;
 
   case 149:
-
+#line 773 "llgrammar.y"
     { (yyval.program) = (yyvsp[(2) - (3)].program); (yyval.program)->wrapped = (yyval.program)->wrapped + 1; ;}
     break;
 
   case 150:
-
+#line 775 "llgrammar.y"
     { programNodeList x = programNodeList_new ();
      programNodeList_addh (x, (yyvsp[(1) - (2)].program));
      (yyval.program) = makeProgramNodeAction (x, ACT_ITER); 
@@ -3708,7 +3708,7 @@ yyreduce:
     break;
 
   case 151:
-
+#line 780 "llgrammar.y"
     { programNodeList x = programNodeList_new ();
      programNodeList_addh (x, (yyvsp[(1) - (3)].program));
      programNodeList_addh (x, (yyvsp[(3) - (3)].program));
@@ -3717,7 +3717,7 @@ yyreduce:
     break;
 
   case 152:
-
+#line 786 "llgrammar.y"
     { programNodeList x = programNodeList_new ();
      programNodeList_addh (x, (yyvsp[(1) - (3)].program));
      programNodeList_addh (x, (yyvsp[(3) - (3)].program));
@@ -3726,112 +3726,112 @@ yyreduce:
     break;
 
   case 153:
-
+#line 795 "llgrammar.y"
     { (yyval.stmt) = makeStmtNode (ltoken_undefined, (yyvsp[(1) - (4)].ltok), (yyvsp[(3) - (4)].termlist)); ;}
     break;
 
   case 154:
-
+#line 797 "llgrammar.y"
     { (yyval.stmt) = makeStmtNode (ltoken_undefined, (yyvsp[(1) - (3)].ltok), termNodeList_new ()); ;}
     break;
 
   case 155:
-
+#line 799 "llgrammar.y"
     { (yyval.stmt) = makeStmtNode ((yyvsp[(1) - (5)].ltok), (yyvsp[(3) - (5)].ltok), termNodeList_new ()); ;}
     break;
 
   case 156:
-
+#line 801 "llgrammar.y"
     { (yyval.stmt) = makeStmtNode ((yyvsp[(1) - (6)].ltok), (yyvsp[(3) - (6)].ltok), (yyvsp[(5) - (6)].termlist)); ;}
     break;
 
   case 157:
-
+#line 805 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push (termNodeList_new (),  (yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 158:
-
+#line 806 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push ((yyvsp[(1) - (3)].termlist), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 160:
-
+#line 811 "llgrammar.y"
     { (yyval.term) = makeSimpleTermNode ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 161:
-
+#line 812 "llgrammar.y"
     { (yyval.term) = makePrefixTermNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].term)); ;}
     break;
 
   case 162:
-
+#line 813 "llgrammar.y"
     { (yyval.term) = makePostfixTermNode2 ((yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 163:
-
+#line 814 "llgrammar.y"
     { (yyval.term) = makeInfixTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 164:
-
+#line 815 "llgrammar.y"
     { (yyval.term) = (yyvsp[(2) - (3)].term); (yyval.term)->wrapped = (yyval.term)->wrapped + 1; ;}
     break;
 
   case 165:
-
+#line 817 "llgrammar.y"
     { (yyval.term) = makeOpCallTermNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].ltok), termNodeList_new (),  (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 166:
-
+#line 819 "llgrammar.y"
     { (yyval.term) = makeOpCallTermNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].termlist), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 167:
-
+#line 823 "llgrammar.y"
     { (yyval.abstbody) = (abstBodyNode)0; ;}
     break;
 
   case 168:
-
+#line 824 "llgrammar.y"
     { (yyval.abstbody) = makeAbstBodyNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].fcns)); ;}
     break;
 
   case 169:
-
+#line 825 "llgrammar.y"
     { (yyval.abstbody) = makeAbstBodyNode2 ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltokenList)); ;}
     break;
 
   case 170:
-
+#line 826 "llgrammar.y"
     { (yyval.abstbody) = (abstBodyNode)0; ;}
     break;
 
   case 171:
-
+#line 830 "llgrammar.y"
     { (yyval.fcns) = fcnNodeList_new (); ;}
     break;
 
   case 172:
-
+#line 831 "llgrammar.y"
     { (yyval.fcns) = fcnNodeList_add ((yyvsp[(1) - (2)].fcns), (yyvsp[(2) - (2)].fcn)); ;}
     break;
 
   case 173:
-
+#line 835 "llgrammar.y"
     { (yyval.lclpredicate) = (lclPredicateNode)0; ;}
     break;
 
   case 175:
-
+#line 840 "llgrammar.y"
     { g_inTypeDef = FALSE; ;}
     break;
 
   case 176:
-
+#line 841 "llgrammar.y"
     { (yyvsp[(5) - (6)].lclpredicate)->tok = (yyvsp[(1) - (6)].ltok); (yyvsp[(5) - (6)].lclpredicate)->kind = LPD_CONSTRAINT;
      checkLclPredicate ((yyvsp[(1) - (6)].ltok), (yyvsp[(5) - (6)].lclpredicate));
      (yyval.lclpredicate) = (yyvsp[(5) - (6)].lclpredicate);
@@ -3841,954 +3841,954 @@ yyreduce:
     break;
 
   case 177:
-
+#line 850 "llgrammar.y"
     { (yyval.declaratorinvs) = declaratorInvNodeList_add (declaratorInvNodeList_new (),  (yyvsp[(1) - (1)].declaratorinv)); ;}
     break;
 
   case 178:
-
+#line 852 "llgrammar.y"
     { (yyval.declaratorinvs) = declaratorInvNodeList_add ((yyvsp[(1) - (3)].declaratorinvs), (yyvsp[(3) - (3)].declaratorinv)); ;}
     break;
 
   case 179:
-
+#line 856 "llgrammar.y"
     { declareForwardType ((yyvsp[(1) - (1)].declare)); ;}
     break;
 
   case 180:
-
+#line 857 "llgrammar.y"
     { (yyval.declaratorinv) = makeDeclaratorInvNode ((yyvsp[(1) - (3)].declare), (yyvsp[(3) - (3)].abstbody)); ;}
     break;
 
   case 181:
-
+#line 861 "llgrammar.y"
     { (yyval.abstbody) = (abstBodyNode)0; ;}
     break;
 
   case 182:
-
+#line 862 "llgrammar.y"
     { (yyval.abstbody) = makeExposedBodyNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].lclpredicate)); ;}
     break;
 
   case 183:
-
+#line 866 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_VOID, 0)); ;}
     break;
 
   case 184:
-
+#line 867 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_CHAR, 0)); ;}
     break;
 
   case 185:
-
+#line 868 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_DOUBLE, 0)); ;}
     break;
 
   case 186:
-
+#line 869 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_FLOAT, 0)); ;}
     break;
 
   case 187:
-
+#line 870 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_INT, 0)); ;}
     break;
 
   case 188:
-
+#line 871 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_LONG, 0)); ;}
     break;
 
   case 189:
-
+#line 872 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_SHORT, 0)); ;}
     break;
 
   case 190:
-
+#line 873 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_SIGNED, 0)); ;}
     break;
 
   case 191:
-
+#line 874 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_UNSIGNED, 0)); ;}
     break;
 
   case 192:
-
+#line 875 "llgrammar.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ltoken_setIntField ((yyval.ltok), fixBits (TS_UNKNOWN, 0)); ;}
     break;
 
   case 193:
-
+#line 884 "llgrammar.y"
     { (yyval.ctypes) = makeCTypesNode ((CTypesNode)0, (yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 194:
-
+#line 885 "llgrammar.y"
     { (yyval.ctypes) = makeCTypesNode ((yyvsp[(1) - (2)].ctypes), (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 195:
-
+#line 892 "llgrammar.y"
     { (yyval.ctypes) = makeTypeSpecifier ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 196:
-
+#line 894 "llgrammar.y"
     { (yyval.ctypes) = (yyvsp[(1) - (1)].ctypes); (yyval.ctypes)->sort = sort_lookupName (lclctype_toSort ((yyvsp[(1) - (1)].ctypes)->intfield)); ;}
     break;
 
   case 197:
-
+#line 900 "llgrammar.y"
     { (yyval.typequal) = qual_createOut (); ;}
     break;
 
   case 198:
-
+#line 901 "llgrammar.y"
     { (yyval.typequal) = qual_createUnused (); ;}
     break;
 
   case 199:
-
+#line 902 "llgrammar.y"
     { (yyval.typequal) = qual_createSef (); ;}
     break;
 
   case 200:
-
+#line 903 "llgrammar.y"
     { (yyval.typequal) = qual_createOnly (); ;}
     break;
 
   case 201:
-
+#line 904 "llgrammar.y"
     { (yyval.typequal) = qual_createOwned (); ;}
     break;
 
   case 202:
-
+#line 905 "llgrammar.y"
     { (yyval.typequal) = qual_createDependent (); ;}
     break;
 
   case 203:
-
+#line 906 "llgrammar.y"
     { (yyval.typequal) = qual_createKeep (); ;}
     break;
 
   case 204:
-
+#line 907 "llgrammar.y"
     { (yyval.typequal) = qual_createKept (); ;}
     break;
 
   case 205:
-
+#line 908 "llgrammar.y"
     { (yyval.typequal) = qual_createObserver (); ;}
     break;
 
   case 206:
-
+#line 909 "llgrammar.y"
     { (yyval.typequal) = qual_createExits (); ;}
     break;
 
   case 207:
-
+#line 910 "llgrammar.y"
     { (yyval.typequal) = qual_createMayExit (); ;}
     break;
 
   case 208:
-
+#line 911 "llgrammar.y"
     { (yyval.typequal) = qual_createTrueExit (); ;}
     break;
 
   case 209:
-
+#line 912 "llgrammar.y"
     { (yyval.typequal) = qual_createFalseExit (); ;}
     break;
 
   case 210:
-
+#line 913 "llgrammar.y"
     { (yyval.typequal) = qual_createNeverExit (); ;}
     break;
 
   case 211:
-
+#line 914 "llgrammar.y"
     { (yyval.typequal) = qual_createOnly (); ;}
     break;
 
   case 212:
-
+#line 915 "llgrammar.y"
     { (yyval.typequal) = qual_createShared (); ;}
     break;
 
   case 213:
-
+#line 916 "llgrammar.y"
     { (yyval.typequal) = qual_createUnique (); ;}
     break;
 
   case 214:
-
+#line 917 "llgrammar.y"
     { (yyval.typequal) = qual_createChecked (); ;}
     break;
 
   case 215:
-
+#line 918 "llgrammar.y"
     { (yyval.typequal) = qual_createUnchecked (); ;}
     break;
 
   case 216:
-
+#line 919 "llgrammar.y"
     { (yyval.typequal) = qual_createCheckedStrict (); ;}
     break;
 
   case 217:
-
+#line 920 "llgrammar.y"
     { (yyval.typequal) = qual_createTrueNull (); ;}
     break;
 
   case 218:
-
+#line 921 "llgrammar.y"
     { (yyval.typequal) = qual_createFalseNull (); ;}
     break;
 
   case 219:
-
+#line 922 "llgrammar.y"
     { (yyval.typequal) = qual_createRelNull (); ;}
     break;
 
   case 220:
-
+#line 923 "llgrammar.y"
     { (yyval.typequal) = qual_createRelDef (); ;}
     break;
 
   case 221:
-
+#line 924 "llgrammar.y"
     { (yyval.typequal) = qual_createRefCounted (); ;}
     break;
 
   case 222:
-
+#line 925 "llgrammar.y"
     { (yyval.typequal) = qual_createRefs (); ;}
     break;
 
   case 223:
-
+#line 926 "llgrammar.y"
     { (yyval.typequal) = qual_createNewRef (); ;}
     break;
 
   case 224:
-
+#line 927 "llgrammar.y"
     { (yyval.typequal) = qual_createKillRef (); ;}
     break;
 
   case 225:
-
+#line 928 "llgrammar.y"
     { (yyval.typequal) = qual_createNull (); ;}
     break;
 
   case 226:
-
+#line 929 "llgrammar.y"
     { (yyval.typequal) = qual_createNotNull (); ;}
     break;
 
   case 227:
-
+#line 930 "llgrammar.y"
     { (yyval.typequal) = qual_createReturned (); ;}
     break;
 
   case 228:
-
+#line 931 "llgrammar.y"
     { (yyval.typequal) = qual_createExposed (); ;}
     break;
 
   case 229:
-
+#line 932 "llgrammar.y"
     { (yyval.typequal) = qual_createPartial (); ;}
     break;
 
   case 230:
-
+#line 933 "llgrammar.y"
     { (yyval.typequal) = qual_createNullTerminated () ; ;}
     break;
 
   case 231:
-
+#line 934 "llgrammar.y"
     { (yyval.typequal) = qual_createUndef (); ;}
     break;
 
   case 232:
-
+#line 935 "llgrammar.y"
     { (yyval.typequal) = qual_createKilled (); ;}
     break;
 
   case 233:
-
+#line 940 "llgrammar.y"
     { (yyval.lcltypespec) = makeLclTypeSpecNodeType ((yyvsp[(1) - (1)].ctypes)); ;}
     break;
 
   case 234:
-
+#line 942 "llgrammar.y"
     { (yyval.lcltypespec) = makeLclTypeSpecNodeSU ((yyvsp[(1) - (1)].structorunion)); ;}
     break;
 
   case 235:
-
+#line 944 "llgrammar.y"
     { (yyval.lcltypespec) = makeLclTypeSpecNodeEnum ((yyvsp[(1) - (1)].enumspec)); ;}
     break;
 
   case 236:
-
+#line 946 "llgrammar.y"
     { (yyval.lcltypespec) = lclTypeSpecNode_addQual ((yyvsp[(2) - (2)].lcltypespec), (yyvsp[(1) - (2)].typequal)); ;}
     break;
 
   case 237:
-
+#line 948 "llgrammar.y"
     { (yyval.lcltypespec) = makeLclTypeSpecNodeConj ((yyvsp[(2) - (5)].lcltypespec), (yyvsp[(4) - (5)].lcltypespec)); ;}
     break;
 
   case 239:
-
+#line 959 "llgrammar.y"
     { llassert (lclTypeSpecNode_isDefined ((yyvsp[(1) - (2)].lcltypespec)));
      (yyvsp[(1) - (2)].lcltypespec)->pointers = (yyvsp[(2) - (2)].pointers); (yyval.lcltypespec) = (yyvsp[(1) - (2)].lcltypespec); ;}
     break;
 
   case 240:
-
+#line 964 "llgrammar.y"
     { (yyval.pointers) = pointers_createLt ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 241:
-
+#line 965 "llgrammar.y"
     { (yyval.pointers) = pointers_extend ((yyvsp[(1) - (2)].pointers), pointers_createLt ((yyvsp[(2) - (2)].ltok))); ;}
     break;
 
   case 242:
-
+#line 970 "llgrammar.y"
     { (void) checkAndEnterTag (TAG_FWDSTRUCT, ltoken_copy ((yyvsp[(2) - (2)].ltok))); ;}
     break;
 
   case 243:
-
+#line 972 "llgrammar.y"
     { (yyval.structorunion) = makestrOrUnionNode ((yyvsp[(1) - (6)].ltok), SU_STRUCT, (yyvsp[(2) - (6)].ltok), (yyvsp[(5) - (6)].structdecls)); ;}
     break;
 
   case 244:
-
+#line 974 "llgrammar.y"
     { (void) checkAndEnterTag (TAG_FWDUNION, ltoken_copy ((yyvsp[(2) - (2)].ltok))); ;}
     break;
 
   case 245:
-
+#line 976 "llgrammar.y"
     { (yyval.structorunion) = makestrOrUnionNode ((yyvsp[(1) - (6)].ltok), SU_UNION, (yyvsp[(2) - (6)].ltok), (yyvsp[(5) - (6)].structdecls)); ;}
     break;
 
   case 246:
-
+#line 978 "llgrammar.y"
     { (yyval.structorunion) = makeForwardstrOrUnionNode ((yyvsp[(1) - (2)].ltok), SU_STRUCT, (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 247:
-
+#line 980 "llgrammar.y"
     { (yyval.structorunion) = makeForwardstrOrUnionNode ((yyvsp[(1) - (2)].ltok), SU_UNION, (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 248:
-
+#line 984 "llgrammar.y"
     { (yyval.ltok) = ltoken_undefined; ;}
     break;
 
   case 250:
-
+#line 989 "llgrammar.y"
     { (yyval.structdecls) = stDeclNodeList_add (stDeclNodeList_new (),  (yyvsp[(1) - (1)].structdecl)); ;}
     break;
 
   case 251:
-
+#line 990 "llgrammar.y"
     { (yyval.structdecls) = stDeclNodeList_add ((yyvsp[(1) - (2)].structdecls), (yyvsp[(2) - (2)].structdecl)); ;}
     break;
 
   case 252:
-
+#line 996 "llgrammar.y"
     { (yyval.structdecl) = makestDeclNode ((yyvsp[(1) - (3)].lcltypespec), (yyvsp[(2) - (3)].declarelist)); ;}
     break;
 
   case 253:
-
+#line 1001 "llgrammar.y"
     { (yyval.declarelist) = declaratorNodeList_add (declaratorNodeList_new (),  (yyvsp[(1) - (1)].declare)); ;}
     break;
 
   case 254:
-
+#line 1003 "llgrammar.y"
     { (yyval.declarelist) = declaratorNodeList_add ((yyvsp[(1) - (3)].declarelist), (yyvsp[(3) - (3)].declare)); ;}
     break;
 
   case 255:
-
+#line 1007 "llgrammar.y"
     { ; ;}
     break;
 
   case 256:
-
+#line 1008 "llgrammar.y"
     { ; ;}
     break;
 
   case 257:
-
+#line 1013 "llgrammar.y"
     { (yyval.enumspec) = makeEnumSpecNode ((yyvsp[(1) - (6)].ltok), (yyvsp[(2) - (6)].ltok), (yyvsp[(4) - (6)].ltokenList)); ;}
     break;
 
   case 258:
-
+#line 1015 "llgrammar.y"
     { (yyval.enumspec) = makeEnumSpecNode2 ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 259:
-
+#line 1019 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 260:
-
+#line 1020 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 261:
-
+#line 1031 "llgrammar.y"
     { (yyval.declare) = makeDeclaratorNode ((yyvsp[(1) - (1)].typeexpr)); ;}
     break;
 
   case 262:
-
+#line 1032 "llgrammar.y"
     { (yyval.declare) = makeDeclaratorNode ((yyvsp[(1) - (1)].typeexpr)); ;}
     break;
 
   case 263:
-
+#line 1036 "llgrammar.y"
     { (yyval.typeexpr) = makeTypeExpr ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 264:
-
+#line 1037 "llgrammar.y"
     { (yyval.typeexpr) = (yyvsp[(2) - (3)].typeexpr); (yyval.typeexpr)->wrapped = (yyval.typeexpr)->wrapped + 1; ;}
     break;
 
   case 265:
-
+#line 1038 "llgrammar.y"
     { (yyval.typeexpr) = makePointerNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 266:
-
+#line 1039 "llgrammar.y"
     { (yyval.typeexpr) = makeArrayNode ((yyvsp[(1) - (2)].typeexpr), (yyvsp[(2) - (2)].array)); ;}
     break;
 
   case 267:
-
+#line 1040 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (3)].typeexpr), paramNodeList_new ()); ;}
     break;
 
   case 268:
-
+#line 1041 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (4)].typeexpr), (yyvsp[(3) - (4)].paramlist)); ;}
     break;
 
   case 269:
-
+#line 1045 "llgrammar.y"
     { (yyval.typeexpr) = makeTypeExpr ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 270:
-
+#line 1046 "llgrammar.y"
     { (yyval.typeexpr) = (yyvsp[(2) - (3)].typeexpr); (yyval.typeexpr)->wrapped = (yyval.typeexpr)->wrapped + 1; ;}
     break;
 
   case 271:
-
+#line 1047 "llgrammar.y"
     { (yyval.typeexpr) = makePointerNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 272:
-
+#line 1048 "llgrammar.y"
     { (yyval.typeexpr) = makeArrayNode ((yyvsp[(1) - (2)].typeexpr), (yyvsp[(2) - (2)].array)); ;}
     break;
 
   case 273:
-
+#line 1049 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (3)].typeexpr), paramNodeList_new ()); ;}
     break;
 
   case 274:
-
+#line 1050 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (4)].typeexpr), (yyvsp[(3) - (4)].paramlist)); ;}
     break;
 
   case 275:
-
+#line 1060 "llgrammar.y"
     { (yyval.typeexpr) = makeTypeExpr ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 276:
-
+#line 1061 "llgrammar.y"
     { (yyval.typeexpr) = makePointerNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 277:
-
+#line 1062 "llgrammar.y"
     { (yyval.typeexpr) = makeArrayNode ((yyvsp[(1) - (2)].typeexpr), (yyvsp[(2) - (2)].array)); ;}
     break;
 
   case 278:
-
+#line 1063 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (3)].typeexpr), paramNodeList_new ()); ;}
     break;
 
   case 279:
-
+#line 1064 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (4)].typeexpr), (yyvsp[(3) - (4)].paramlist)); ;}
     break;
 
   case 280:
-
+#line 1071 "llgrammar.y"
     { (yyval.param) = makeParamNode ((yyvsp[(1) - (2)].lcltypespec), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 281:
-
+#line 1072 "llgrammar.y"
     { (yyval.param) = makeParamNode ((yyvsp[(1) - (2)].lcltypespec), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 282:
-
+#line 1073 "llgrammar.y"
     { (yyval.param) = makeParamNode ((yyvsp[(1) - (2)].lcltypespec), (yyvsp[(2) - (2)].abstDecl)); ;}
     break;
 
   case 283:
-
+#line 1084 "llgrammar.y"
     { (yyval.typname) = makeTypeNameNode (FALSE, (yyvsp[(1) - (2)].lcltypespec), (yyvsp[(2) - (2)].abstDecl)); ;}
     break;
 
   case 284:
-
+#line 1085 "llgrammar.y"
     { (yyval.typname) = makeTypeNameNode (TRUE, (yyvsp[(2) - (3)].lcltypespec), (yyvsp[(3) - (3)].abstDecl)); ;}
     break;
 
   case 285:
-
+#line 1086 "llgrammar.y"
     { (yyval.typname) = makeTypeNameNodeOp ((yyvsp[(1) - (1)].opform)); ;}
     break;
 
   case 286:
-
+#line 1092 "llgrammar.y"
     { (yyval.abstDecl) = (abstDeclaratorNode)0; ;}
     break;
 
   case 287:
-
+#line 1093 "llgrammar.y"
     { (yyval.abstDecl) = (abstDeclaratorNode)(yyvsp[(1) - (1)].typeexpr); ;}
     break;
 
   case 288:
-
+#line 1097 "llgrammar.y"
     { (yyval.typeexpr) = (yyvsp[(2) - (3)].typeexpr); (yyval.typeexpr)->wrapped = (yyval.typeexpr)->wrapped + 1; ;}
     break;
 
   case 289:
-
+#line 1098 "llgrammar.y"
     { (yyval.typeexpr) = makePointerNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].typeexpr)); ;}
     break;
 
   case 290:
-
+#line 1099 "llgrammar.y"
     { (yyval.typeexpr) = makePointerNode ((yyvsp[(1) - (1)].ltok), (typeExpr)0); ;}
     break;
 
   case 291:
-
+#line 1100 "llgrammar.y"
     { (yyval.typeexpr) = makeArrayNode ((typeExpr)0, (yyvsp[(1) - (1)].array)); ;}
     break;
 
   case 292:
-
+#line 1101 "llgrammar.y"
     { (yyval.typeexpr) = makeArrayNode ((yyvsp[(1) - (2)].typeexpr), (yyvsp[(2) - (2)].array)); ;}
     break;
 
   case 293:
-
+#line 1102 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (3)].typeexpr), paramNodeList_new ()); ;}
     break;
 
   case 294:
-
+#line 1103 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((typeExpr)0, (yyvsp[(2) - (3)].paramlist)); ;}
     break;
 
   case 295:
-
+#line 1104 "llgrammar.y"
     { (yyval.typeexpr) = makeFunctionNode ((yyvsp[(1) - (4)].typeexpr), (yyvsp[(3) - (4)].paramlist)); ;}
     break;
 
   case 296:
-
+#line 1108 "llgrammar.y"
     { (yyval.array) = makeArrayQualNode ((yyvsp[(1) - (2)].ltok), (termNode)0); ;}
     break;
 
   case 297:
-
+#line 1109 "llgrammar.y"
     { (yyval.array) = makeArrayQualNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].term)); ;}
     break;
 
   case 298:
-
+#line 1114 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (6)].ltok), OPF_IF, opFormUnion_createMiddle (0), ltoken_undefined); ;}
     break;
 
   case 299:
-
+#line 1116 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (1)].ltok), OPF_ANYOP, opFormUnion_createAnyOp ((yyvsp[(1) - (1)].ltok)), ltoken_undefined); ;}
     break;
 
   case 300:
-
+#line 1118 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_MANYOP, opFormUnion_createAnyOp ((yyvsp[(2) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 301:
-
+#line 1120 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_ANYOPM, opFormUnion_createAnyOp ((yyvsp[(1) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 302:
-
+#line 1122 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MANYOPM, 
 			  opFormUnion_createAnyOp ((yyvsp[(2) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 303:
-
+#line 1125 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MIDDLE, opFormUnion_createMiddle ((yyvsp[(2) - (3)].count)), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 304:
-
+#line 1127 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (4)].ltok), OPF_MMIDDLE, opFormUnion_createMiddle ((yyvsp[(3) - (4)].count)), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 305:
-
+#line 1129 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (4)].ltok), OPF_MIDDLEM, opFormUnion_createMiddle ((yyvsp[(2) - (4)].count)), (yyvsp[(3) - (4)].ltok)); ;}
     break;
 
   case 306:
-
+#line 1131 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (5)].ltok), OPF_MMIDDLEM, opFormUnion_createMiddle ((yyvsp[(3) - (5)].count)), (yyvsp[(4) - (5)].ltok)); ;}
     break;
 
   case 307:
-
+#line 1133 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_BMIDDLE, opFormUnion_createMiddle ((yyvsp[(2) - (3)].count)), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 308:
-
+#line 1135 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (4)].ltok), OPF_BMIDDLEM, opFormUnion_createMiddle ((yyvsp[(2) - (4)].count)), (yyvsp[(3) - (4)].ltok)); ;}
     break;
 
   case 309:
-
+#line 1143 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (4)].ltok), OPF_BMMIDDLE, opFormUnion_createMiddle ((yyvsp[(3) - (4)].count)), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 310:
-
+#line 1145 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (5)].ltok), OPF_BMMIDDLEM, opFormUnion_createMiddle ((yyvsp[(3) - (5)].count)), (yyvsp[(4) - (5)].ltok)); ;}
     break;
 
   case 311:
-
+#line 1147 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_SELECT, 
 			  opFormUnion_createAnyOp ((yyvsp[(2) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 312:
-
+#line 1150 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_MAP, 
 			  opFormUnion_createAnyOp ((yyvsp[(2) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 313:
-
+#line 1153 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MSELECT, 
 			  opFormUnion_createAnyOp ((yyvsp[(3) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 314:
-
+#line 1156 "llgrammar.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MMAP, 
 			  opFormUnion_createAnyOp ((yyvsp[(3) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 322:
-
+#line 1177 "llgrammar.y"
     { (yyval.count) = 0; ;}
     break;
 
   case 324:
-
+#line 1182 "llgrammar.y"
     { (yyval.count) = 1; ;}
     break;
 
   case 325:
-
+#line 1183 "llgrammar.y"
     { (yyval.count) = (yyvsp[(1) - (3)].count) + 1; ;}
     break;
 
   case 328:
-
+#line 1192 "llgrammar.y"
     { (yyval.signature) = makesigNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltokenList), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 329:
-
+#line 1196 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_new (); ;}
     break;
 
   case 331:
-
+#line 1201 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 332:
-
+#line 1202 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 333:
-
+#line 1206 "llgrammar.y"
     { (yyval.lclpredicate) = makeLclPredicateNode (ltoken_undefined, (yyvsp[(1) - (1)].term), LPD_PLAIN);;}
     break;
 
   case 334:
-
+#line 1210 "llgrammar.y"
     { (yyval.term) = checkSort ((yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 335:
-
+#line 1218 "llgrammar.y"
     { (yyval.term) = makeIfTermNode ((yyvsp[(1) - (6)].ltok),(yyvsp[(2) - (6)].term),(yyvsp[(3) - (6)].ltok),(yyvsp[(4) - (6)].term),(yyvsp[(5) - (6)].ltok),(yyvsp[(6) - (6)].term)); ;}
     break;
 
   case 337:
-
+#line 1220 "llgrammar.y"
     { (yyval.term) = makeInfixTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 339:
-
+#line 1227 "llgrammar.y"
     { checkLclPredicate ((yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].lclpredicate)); (yyval.term) = makeQuantifiedTermNode ((yyvsp[(1) - (4)].quantifiers), (yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].lclpredicate)->predicate, (yyvsp[(4) - (4)].ltok));
      symtable_exitScope (g_symtab); 
    ;}
     break;
 
   case 340:
-
+#line 1231 "llgrammar.y"
     { (yyval.term) = makeInfixTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].term));;}
     break;
 
   case 341:
-
+#line 1233 "llgrammar.y"
     { (yyval.term) = makeInfixTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].term));;}
     break;
 
   case 343:
-
+#line 1238 "llgrammar.y"
     { (yyval.term) = makePostfixTermNode ((yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].ltokenList)); ;}
     break;
 
   case 344:
-
+#line 1239 "llgrammar.y"
     { (yyval.term) = CollapseInfixTermNode ((yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].termlist)); ;}
     break;
 
   case 348:
-
+#line 1249 "llgrammar.y"
     { (yyval.term) = makePrefixTermNode ((yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].term)); ;}
     break;
 
   case 349:
-
+#line 1253 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 350:
-
+#line 1254 "llgrammar.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (2)].ltokenList), (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 351:
-
+#line 1258 "llgrammar.y"
     { (yyval.termlist) = pushInfixOpPartNode (termNodeList_new (),  (yyvsp[(1) - (2)].ltok), (yyvsp[(2) - (2)].term)); ;}
     break;
 
   case 352:
-
+#line 1259 "llgrammar.y"
     { (yyval.termlist) = pushInfixOpPartNode ((yyvsp[(1) - (3)].termlist), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 354:
-
+#line 1264 "llgrammar.y"
     { (yyval.term) = computePossibleSorts ((yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 355:
-
+#line 1265 "llgrammar.y"
     { (yyval.term) = updateMatchedNode ((termNode)0, (yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].term)); ;}
     break;
 
   case 356:
-
+#line 1266 "llgrammar.y"
     { (yyval.term) = updateMatchedNode ((yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].term), (termNode)0); ;}
     break;
 
   case 357:
-
+#line 1267 "llgrammar.y"
     { (yyval.term) = updateMatchedNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].term), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 358:
-
+#line 1268 "llgrammar.y"
     { (yyval.term) = computePossibleSorts ((yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 359:
-
+#line 1269 "llgrammar.y"
     { (yyval.term) = updateSqBracketedNode ((termNode)0, (yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].term)); ;}
     break;
 
   case 360:
-
+#line 1273 "llgrammar.y"
     { (yyval.term) = (yyvsp[(1) - (3)].term); (yyval.term)->sort = sort_lookupName (ltoken_getText ((yyvsp[(3) - (3)].ltok))); ;}
     break;
 
   case 362:
-
+#line 1279 "llgrammar.y"
     { (yyval.term) = makeSqBracketedNode ((yyvsp[(1) - (5)].ltok), (yyvsp[(2) - (5)].termlist), (yyvsp[(3) - (5)].ltok)); 
      (yyval.term)->given = sort_lookupName (ltoken_getText ((yyvsp[(5) - (5)].ltok))); ;}
     break;
 
   case 363:
-
+#line 1282 "llgrammar.y"
     { (yyval.term) = makeSqBracketedNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].termlist), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 364:
-
+#line 1284 "llgrammar.y"
     { (yyval.term) = makeSqBracketedNode ((yyvsp[(1) - (4)].ltok), termNodeList_new (),  (yyvsp[(2) - (4)].ltok)); 
      (yyval.term)->given = sort_lookupName (ltoken_getText ((yyvsp[(4) - (4)].ltok))); 
    ;}
     break;
 
   case 365:
-
+#line 1288 "llgrammar.y"
     { (yyval.term) = makeSqBracketedNode ((yyvsp[(1) - (2)].ltok), termNodeList_new (),  (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 366:
-
+#line 1292 "llgrammar.y"
     { (yyval.term) = makeMatchedNode ((yyvsp[(1) - (3)].ltok), (yyvsp[(2) - (3)].termlist), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 367:
-
+#line 1293 "llgrammar.y"
     { (yyval.term) = makeMatchedNode ((yyvsp[(1) - (2)].ltok), termNodeList_new (),  (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 368:
-
+#line 1297 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push (termNodeList_new (),  (yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 369:
-
+#line 1298 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push ((yyvsp[(1) - (3)].termlist), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 370:
-
+#line 1303 "llgrammar.y"
     { (yyval.term) = (yyvsp[(2) - (3)].term); (yyval.term)->wrapped = (yyval.term)->wrapped + 1; ;}
     break;
 
   case 371:
-
+#line 1305 "llgrammar.y"
     { (yyval.term) = makeSimpleTermNode ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 372:
-
+#line 1307 "llgrammar.y"
     { (yyval.term) = makeOpCallTermNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].termlist), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 374:
-
+#line 1310 "llgrammar.y"
     { (yyval.term) = makePostfixTermNode2 ((yyvsp[(1) - (2)].term), (yyvsp[(2) - (2)].ltok)); ;}
     break;
 
   case 375:
-
+#line 1312 "llgrammar.y"
     { ltoken_markOwned ((yyvsp[(3) - (3)].ltok)); (yyval.term) = makeSelectTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 376:
-
+#line 1314 "llgrammar.y"
     { ltoken_markOwned ((yyvsp[(3) - (3)].ltok)); (yyval.term) = makeMapTermNode ((yyvsp[(1) - (3)].term), (yyvsp[(2) - (3)].ltok), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 377:
-
+#line 1316 "llgrammar.y"
     { (yyval.term) = updateSqBracketedNode ((yyvsp[(1) - (3)].term), makeSqBracketedNode ((yyvsp[(2) - (3)].ltok), termNodeList_new (),  (yyvsp[(3) - (3)].ltok)), 
 				(termNode)0); ;}
     break;
 
   case 378:
-
+#line 1319 "llgrammar.y"
     { (yyval.term) = updateSqBracketedNode ((yyvsp[(1) - (4)].term), makeSqBracketedNode ((yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].termlist), (yyvsp[(4) - (4)].ltok)), (termNode)0); ;}
     break;
 
   case 379:
-
+#line 1321 "llgrammar.y"
     { (yyval.term) = (yyvsp[(1) - (3)].term); (yyval.term)->given = sort_lookupName (ltoken_getText ((yyvsp[(3) - (3)].ltok))); ;}
     break;
 
   case 380:
-
+#line 1325 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push (termNodeList_new (),  (yyvsp[(1) - (1)].term)); ;}
     break;
 
   case 381:
-
+#line 1326 "llgrammar.y"
     { (yyval.termlist) = termNodeList_push ((yyvsp[(1) - (3)].termlist), (yyvsp[(3) - (3)].term)); ;}
     break;
 
   case 387:
-
+#line 1338 "llgrammar.y"
     { (yyval.term) = makeSimpleTermNode ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 388:
-
+#line 1339 "llgrammar.y"
     { (yyval.term) = makeOpCallTermNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltok), (yyvsp[(3) - (4)].termlist), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 389:
-
+#line 1340 "llgrammar.y"
     { (yyval.term) = makeUnchangedTermNode1 ((yyvsp[(1) - (4)].ltok), (yyvsp[(3) - (4)].ltok)); ;}
     break;
 
   case 390:
-
+#line 1341 "llgrammar.y"
     { (yyval.term) = makeUnchangedTermNode2 ((yyvsp[(1) - (4)].ltok), (yyvsp[(3) - (4)].storereflist)); ;}
     break;
 
   case 391:
-
+#line 1343 "llgrammar.y"
     { termNodeList x = termNodeList_new (); 
      termNodeList_addh (x, (yyvsp[(3) - (4)].term));
      (yyval.term) = makeOpCallTermNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(2) - (4)].ltok), x, (yyvsp[(4) - (4)].ltok)); 
@@ -4796,7 +4796,7 @@ yyreduce:
     break;
 
   case 392:
-
+#line 1348 "llgrammar.y"
     { termNodeList x = termNodeList_new ();
      termNodeList_addh (x, (yyvsp[(3) - (6)].term));
      termNodeList_addh (x, (yyvsp[(5) - (6)].term));
@@ -4805,75 +4805,75 @@ yyreduce:
     break;
 
   case 393:
-
+#line 1353 "llgrammar.y"
     { (yyval.term) = makeSizeofTermNode ((yyvsp[(1) - (4)].ltok), (yyvsp[(3) - (4)].lcltypespec)); ;}
     break;
 
   case 394:
-
+#line 1364 "llgrammar.y"
     { (yyval.term) = makeLiteralTermNode ((yyvsp[(1) - (1)].ltok), g_sortInt); ;}
     break;
 
   case 395:
-
+#line 1365 "llgrammar.y"
     { (yyval.term) = makeLiteralTermNode ((yyvsp[(1) - (1)].ltok), g_sortCstring); ;}
     break;
 
   case 396:
-
+#line 1366 "llgrammar.y"
     { (yyval.term) = makeLiteralTermNode ((yyvsp[(1) - (1)].ltok), g_sortChar); ;}
     break;
 
   case 397:
-
+#line 1367 "llgrammar.y"
     { (yyval.term) = makeLiteralTermNode ((yyvsp[(1) - (1)].ltok), g_sortDouble); ;}
     break;
 
   case 398:
-
+#line 1372 "llgrammar.y"
     { (yyval.quantifiers) = quantifierNodeList_add (quantifierNodeList_new (),  (yyvsp[(1) - (1)].quantifier)); ;}
     break;
 
   case 399:
-
+#line 1374 "llgrammar.y"
     { (yyval.quantifiers) = quantifierNodeList_add ((yyvsp[(1) - (2)].quantifiers), (yyvsp[(2) - (2)].quantifier)); ;}
     break;
 
   case 400:
-
+#line 1378 "llgrammar.y"
     { scopeInfo si = (scopeInfo) dmalloc (sizeof (*si));
 		   si->kind = SPE_QUANT;
 		   symtable_enterScope (g_symtab, si); ;}
     break;
 
   case 401:
-
+#line 1382 "llgrammar.y"
     { (yyval.quantifier) = makeQuantifierNode ((yyvsp[(3) - (3)].vars), (yyvsp[(1) - (3)].ltok)); ;}
     break;
 
   case 402:
-
+#line 1386 "llgrammar.y"
     { (yyval.vars) = varNodeList_add (varNodeList_new (),  (yyvsp[(1) - (1)].var)); ;}
     break;
 
   case 403:
-
+#line 1387 "llgrammar.y"
     { (yyval.vars) = varNodeList_add ((yyvsp[(1) - (3)].vars), (yyvsp[(3) - (3)].var)); ;}
     break;
 
   case 404:
-
+#line 1391 "llgrammar.y"
     { (yyval.var) = makeVarNode ((yyvsp[(1) - (3)].ltok), FALSE, (yyvsp[(3) - (3)].lcltypespec)); ;}
     break;
 
   case 405:
-
+#line 1392 "llgrammar.y"
     { (yyval.var) = makeVarNode ((yyvsp[(1) - (4)].ltok), TRUE, (yyvsp[(4) - (4)].lcltypespec)); ;}
     break;
 
 
 /* Line 1267 of yacc.c.  */
-
+#line 4819 "llgrammar.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -5087,7 +5087,7 @@ yyreturn:
 }
 
 
-
+#line 1409 "llgrammar.y"
 
 
 # include "bison.reset"
diff --git a/src/mtgrammar.c b/src/mtgrammar.c
index 67c2e99..4b7c5fc 100644
--- a/src/mtgrammar.c
+++ b/src/mtgrammar.c
@@ -52,69 +52,190 @@
 /*drl added 12/11/2002*/
 /*@-type@*/
 
+/*@-enummemuse@*/
+
 /* < end of bison.head > */
 
-/* A Bison parser, made from mtgrammar.y
-   by GNU bison 1.35.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-#define YYBISON 1  /* Identify Bison output.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
 #define yyparse mtparse
-#define yylex mtlex
+#define yylex   mtlex
 #define yyerror mterror
-#define yylval mtlval
-#define yychar mtchar
+#define yylval  mtlval
+#define yychar  mtchar
 #define yydebug mtdebug
 #define yynerrs mtnerrs
-# define	MT_BADTOK	257
-# define	MT_END	258
-# define	MT_STATE	259
-# define	MT_GLOBAL	260
-# define	MT_CONTEXT	261
-# define	MT_ONEOF	262
-# define	MT_DEFAULTS	263
-# define	MT_DEFAULT	264
-# define	MT_REFERENCE	265
-# define	MT_PARAMETER	266
-# define	MT_RESULT	267
-# define	MT_CLAUSE	268
-# define	MT_LITERAL	269
-# define	MT_NULL	270
-# define	MT_ANNOTATIONS	271
-# define	MT_ARROW	272
-# define	MT_MERGE	273
-# define	MT_TRANSFERS	274
-# define	MT_PRECONDITIONS	275
-# define	MT_POSTCONDITIONS	276
-# define	MT_LOSEREFERENCE	277
-# define	MT_AS	278
-# define	MT_ERROR	279
-# define	MT_PLUS	280
-# define	MT_STAR	281
-# define	MT_BAR	282
-# define	MT_LPAREN	283
-# define	MT_RPAREN	284
-# define	MT_LBRACKET	285
-# define	MT_RBRACKET	286
-# define	MT_LBRACE	287
-# define	MT_RBRACE	288
-# define	MT_COMMA	289
-# define	MT_CHAR	290
-# define	MT_INT	291
-# define	MT_FLOAT	292
-# define	MT_DOUBLE	293
-# define	MT_VOID	294
-# define	MT_ANYTYPE	295
-# define	MT_INTEGRALTYPE	296
-# define	MT_UNSIGNEDINTEGRALTYPE	297
-# define	MT_SIGNEDINTEGRALTYPE	298
-# define	MT_CONST	299
-# define	MT_VOLATILE	300
-# define	MT_RESTRICT	301
-# define	MT_STRINGLIT	302
-# define	MT_IDENT	303
 
 
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     MT_BADTOK = 258,
+     MT_END = 259,
+     MT_STATE = 260,
+     MT_GLOBAL = 261,
+     MT_CONTEXT = 262,
+     MT_ONEOF = 263,
+     MT_DEFAULTS = 264,
+     MT_DEFAULT = 265,
+     MT_REFERENCE = 266,
+     MT_PARAMETER = 267,
+     MT_RESULT = 268,
+     MT_CLAUSE = 269,
+     MT_LITERAL = 270,
+     MT_NULL = 271,
+     MT_ANNOTATIONS = 272,
+     MT_ARROW = 273,
+     MT_MERGE = 274,
+     MT_TRANSFERS = 275,
+     MT_PRECONDITIONS = 276,
+     MT_POSTCONDITIONS = 277,
+     MT_LOSEREFERENCE = 278,
+     MT_AS = 279,
+     MT_ERROR = 280,
+     MT_PLUS = 281,
+     MT_STAR = 282,
+     MT_BAR = 283,
+     MT_LPAREN = 284,
+     MT_RPAREN = 285,
+     MT_LBRACKET = 286,
+     MT_RBRACKET = 287,
+     MT_LBRACE = 288,
+     MT_RBRACE = 289,
+     MT_COMMA = 290,
+     MT_CHAR = 291,
+     MT_INT = 292,
+     MT_FLOAT = 293,
+     MT_DOUBLE = 294,
+     MT_VOID = 295,
+     MT_ANYTYPE = 296,
+     MT_INTEGRALTYPE = 297,
+     MT_UNSIGNEDINTEGRALTYPE = 298,
+     MT_SIGNEDINTEGRALTYPE = 299,
+     MT_CONST = 300,
+     MT_VOLATILE = 301,
+     MT_RESTRICT = 302,
+     MT_STRINGLIT = 303,
+     MT_IDENT = 304
+   };
+#endif
+/* Tokens.  */
+#define MT_BADTOK 258
+#define MT_END 259
+#define MT_STATE 260
+#define MT_GLOBAL 261
+#define MT_CONTEXT 262
+#define MT_ONEOF 263
+#define MT_DEFAULTS 264
+#define MT_DEFAULT 265
+#define MT_REFERENCE 266
+#define MT_PARAMETER 267
+#define MT_RESULT 268
+#define MT_CLAUSE 269
+#define MT_LITERAL 270
+#define MT_NULL 271
+#define MT_ANNOTATIONS 272
+#define MT_ARROW 273
+#define MT_MERGE 274
+#define MT_TRANSFERS 275
+#define MT_PRECONDITIONS 276
+#define MT_POSTCONDITIONS 277
+#define MT_LOSEREFERENCE 278
+#define MT_AS 279
+#define MT_ERROR 280
+#define MT_PLUS 281
+#define MT_STAR 282
+#define MT_BAR 283
+#define MT_LPAREN 284
+#define MT_RPAREN 285
+#define MT_LBRACKET 286
+#define MT_RBRACKET 287
+#define MT_LBRACE 288
+#define MT_RBRACE 289
+#define MT_COMMA 290
+#define MT_CHAR 291
+#define MT_INT 292
+#define MT_FLOAT 293
+#define MT_DOUBLE 294
+#define MT_VOID 295
+#define MT_ANYTYPE 296
+#define MT_INTEGRALTYPE 297
+#define MT_UNSIGNEDINTEGRALTYPE 298
+#define MT_SIGNEDINTEGRALTYPE 299
+#define MT_CONST 300
+#define MT_VOLATILE 301
+#define MT_RESTRICT 302
+#define MT_STRINGLIT 303
+#define MT_IDENT 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 30 "mtgrammar.y"
+
 
 # include "bison.reset"
 # include "splintMacros.nf"
@@ -143,8 +264,29 @@ static void yyprint (/*FILE *p_file, int p_type, YYSTYPE p_value */);
 # include "bison.head"
 
 
-#ifndef YYSTYPE
-typedef union {
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 62 "mtgrammar.y"
+{
   mttok tok; 
   mtDeclarationNode mtdecl;
   mtDeclarationPiece mtpiece;
@@ -171,393 +313,212 @@ typedef union {
   /*@only@*/ qtype qtyp;
   qual qual;
   qualList quals;
-} yystype;
-# define YYSTYPE yystype
+}
+/* Line 187 of yacc.c.  */
+#line 261 "mtgrammar.tab.c"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
 #endif
-#ifndef YYDEBUG
-# define YYDEBUG 1
-#endif
 
 
 
-#define	YYFINAL		136
-#define	YYFLAG		-32768
-#define	YYNTBASE	50
+/* Copy the second part of user declarations.  */
 
-/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
-#define YYTRANSLATE(x) ((unsigned)(x) <= 303 ? yytranslate[x] : 93)
 
-/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
-static const char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
-       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
-      46,    47,    48,    49
-};
-
-#if YYDEBUG
-static const short yyprhs[] =
-{
-       0,     0,     1,     3,     7,    12,    15,    16,    19,    21,
-      23,    25,    27,    29,    31,    33,    35,    37,    39,    42,
-      43,    45,    48,    51,    54,    57,    60,    63,    64,    66,
-      68,    71,    73,    77,    80,    81,    83,    85,    87,    90,
-      92,    95,    98,   102,   104,   106,   108,   110,   113,   117,
-     120,   124,   126,   128,   130,   132,   134,   136,   138,   140,
-     142,   144,   146,   149,   151,   155,   158,   161,   165,   170,
-     173,   175,   178,   183,   186,   188,   191,   197,   199,   201,
-     204,   207,   210,   213,   215,   218,   222,   224,   227,   233,
-     235,   237,   239,   242
-};
-static const short yyrhs[] =
-{
-      -1,    51,     0,     5,    52,     4,     0,     6,     5,    52,
-       4,     0,    49,    53,     0,     0,    54,    53,     0,    55,
-       0,    70,     0,    73,     0,    72,     0,    75,     0,    78,
-       0,    84,     0,    82,     0,    83,     0,    85,     0,     7,
-      57,     0,     0,    57,     0,    12,    58,     0,    11,    58,
-       0,    13,    58,     0,    14,    58,     0,    15,    58,     0,
-      16,    58,     0,     0,    59,     0,    60,     0,    60,    63,
-       0,    61,     0,    60,    28,    59,     0,    68,    62,     0,
-       0,    60,     0,    64,     0,    67,     0,    64,    67,     0,
-      27,     0,    27,    66,     0,    27,    64,     0,    27,    66,
-      64,     0,    45,     0,    46,     0,    47,     0,    65,     0,
-      66,    65,     0,    29,    63,    30,     0,    31,    32,     0,
-      67,    31,    32,     0,    36,     0,    37,     0,    38,     0,
-      39,     0,    40,     0,    41,     0,    42,     0,    43,     0,
-      44,     0,    69,     0,    49,     0,     8,    71,     0,    49,
-       0,    49,    35,    71,     0,    10,    92,     0,     9,    74,
-       0,    57,    18,    92,     0,    57,    18,    92,    74,     0,
-      17,    76,     0,    77,     0,    77,    76,     0,    49,    56,
-      18,    92,     0,    19,    79,     0,    80,     0,    80,    79,
-       0,    81,    26,    81,    18,    90,     0,    92,     0,    27,
-       0,    21,    88,     0,    22,    88,     0,    20,    88,     0,
-      23,    86,     0,    87,     0,    87,    86,     0,    92,    18,
-      91,     0,    89,     0,    89,    88,     0,    92,    24,    92,
-      18,    90,     0,    92,     0,    91,     0,    25,     0,    25,
-      48,     0,    49,     0
-};
+/* Line 216 of yacc.c.  */
+#line 274 "mtgrammar.tab.c"
 
+#ifdef short
+# undef short
 #endif
 
-#if YYDEBUG
-/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
-static const short yyrline[] =
-{
-       0,   160,   161,   165,   167,   172,   177,   178,   183,   184,
-     185,   186,   187,   188,   189,   190,   191,   192,   196,   201,
-     202,   206,   207,   208,   209,   210,   211,   219,   220,   224,
-     225,   229,   230,   235,   239,   240,   244,   245,   246,   250,
-     251,   252,   253,   257,   258,   259,   263,   264,   268,   269,
-     270,   278,   279,   280,   281,   282,   283,   284,   285,   286,
-     287,   294,   298,   302,   303,   308,   312,   316,   318,   323,
-     327,   328,   333,   338,   342,   343,   347,   352,   353,   357,
-     361,   365,   369,   373,   374,   378,   382,   383,   387,   392,
-     393,   397,   398,   402
-};
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
 #endif
 
-
-#if (YYDEBUG) || defined YYERROR_VERBOSE
-
-/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
-static const char *const yytname[] =
-{
-  "$", "error", "$undefined.", "MT_BADTOK", "MT_END", "MT_STATE", 
-  "MT_GLOBAL", "MT_CONTEXT", "MT_ONEOF", "MT_DEFAULTS", "MT_DEFAULT", 
-  "MT_REFERENCE", "MT_PARAMETER", "MT_RESULT", "MT_CLAUSE", "MT_LITERAL", 
-  "MT_NULL", "MT_ANNOTATIONS", "MT_ARROW", "MT_MERGE", "MT_TRANSFERS", 
-  "MT_PRECONDITIONS", "MT_POSTCONDITIONS", "MT_LOSEREFERENCE", "MT_AS", 
-  "MT_ERROR", "MT_PLUS", "MT_STAR", "MT_BAR", "MT_LPAREN", "MT_RPAREN", 
-  "MT_LBRACKET", "MT_RBRACKET", "MT_LBRACE", "MT_RBRACE", "MT_COMMA", 
-  "MT_CHAR", "MT_INT", "MT_FLOAT", "MT_DOUBLE", "MT_VOID", "MT_ANYTYPE", 
-  "MT_INTEGRALTYPE", "MT_UNSIGNEDINTEGRALTYPE", "MT_SIGNEDINTEGRALTYPE", 
-  "MT_CONST", "MT_VOLATILE", "MT_RESTRICT", "MT_STRINGLIT", "MT_IDENT", 
-  "file", "mtsDeclaration", "declarationNode", "declarationPieces", 
-  "declarationPiece", "contextDeclaration", "optContextSelection", 
-  "contextSelection", "optType", "typeExpression", "completeType", 
-  "completeTypeAux", "optCompleteType", "abstractDecl", "pointers", 
-  "innerMods", "innerModsList", "abstractDeclBase", "typeSpecifier", 
-  "typeName", "valuesDeclaration", "valuesList", "defaultNode", 
-  "defaultsDeclaration", "defaultDeclarationList", 
-  "annotationsDeclaration", "annotationsDeclarationList", 
-  "annotationDeclaration", "mergeDeclaration", "mergeClauses", 
-  "mergeClause", "mergeItem", "preconditionsDeclaration", 
-  "postconditionsDeclaration", "transfersDeclaration", 
-  "loseReferenceDeclaration", "lostClauses", "lostClause", 
-  "transferClauses", "transferClause", "transferAction", "errorAction", 
-  "valueChoice", 0
-};
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
 #endif
 
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
-static const short yyr1[] =
-{
-       0,    50,    50,    51,    51,    52,    53,    53,    54,    54,
-      54,    54,    54,    54,    54,    54,    54,    54,    55,    56,
-      56,    57,    57,    57,    57,    57,    57,    58,    58,    59,
-      59,    60,    60,    61,    62,    62,    63,    63,    63,    64,
-      64,    64,    64,    65,    65,    65,    66,    66,    67,    67,
-      67,    68,    68,    68,    68,    68,    68,    68,    68,    68,
-      68,    69,    70,    71,    71,    72,    73,    74,    74,    75,
-      76,    76,    77,    78,    79,    79,    80,    81,    81,    82,
-      83,    84,    85,    86,    86,    87,    88,    88,    89,    90,
-      90,    91,    91,    92
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
-static const short yyr2[] =
-{
-       0,     0,     1,     3,     4,     2,     0,     2,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     2,     0,
-       1,     2,     2,     2,     2,     2,     2,     0,     1,     1,
-       2,     1,     3,     2,     0,     1,     1,     1,     2,     1,
-       2,     2,     3,     1,     1,     1,     1,     2,     3,     2,
-       3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     2,     1,     3,     2,     2,     3,     4,     2,
-       1,     2,     4,     2,     1,     2,     5,     1,     1,     2,
-       2,     2,     2,     1,     2,     3,     1,     2,     5,     1,
-       1,     1,     2,     1
-};
-
-/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
-   doesn't specify something else to do.  Zero means the default is an
-   error. */
-static const short yydefact[] =
-{
-       1,     0,     0,     2,     6,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     5,     6,     8,
-       9,    11,    10,    12,    13,    15,    16,    14,    17,     3,
-       0,    27,    27,    27,    27,    27,    27,    18,    63,    62,
-       0,    66,    93,    65,    19,    69,    70,    78,    73,    74,
-       0,    77,    81,    86,     0,    79,    80,    82,    83,     0,
-       7,     4,    51,    52,    53,    54,    55,    56,    57,    58,
-      59,    61,    22,    28,    29,    31,    34,    60,    21,    23,
-      24,    25,    26,     0,     0,     0,    20,    71,    75,     0,
-      87,     0,    84,     0,    39,     0,     0,     0,    30,    36,
-      37,    35,    33,    64,    67,     0,     0,     0,    91,    85,
-      43,    44,    45,    41,    46,    40,    32,     0,    49,    38,
-       0,    68,    72,     0,     0,    92,    42,    47,    48,    50,
-      76,    90,    89,    88,     0,     0,     0
-};
-
-static const short yydefgoto[] =
-{
-     134,     3,     5,    17,    18,    19,    85,    40,    72,    73,
-      74,    75,   102,    98,    99,   114,   115,   100,    76,    77,
-      20,    39,    21,    22,    41,    23,    45,    46,    24,    48,
-      49,    50,    25,    26,    27,    28,    57,    58,    52,    53,
-     130,   131,    54
-};
-
-static const short yypact[] =
-{
-      21,   -29,    30,-32768,     2,    33,   -29,    52,    -9,    52,
-      -8,    -3,   -19,    -8,    -8,    -8,    -8,-32768,     2,-32768,
-  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-      54,    13,    13,    13,    13,    13,    13,-32768,    24,-32768,
-      43,-32768,-32768,-32768,    52,-32768,    -3,-32768,-32768,   -19,
-      34,-32768,-32768,    -8,    46,-32768,-32768,-32768,    -8,    57,
-  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-  -32768,-32768,-32768,-32768,    16,-32768,    13,-32768,-32768,-32768,
-  -32768,-32768,-32768,    -9,    -8,    58,-32768,-32768,-32768,   -19,
-  -32768,    -8,-32768,    47,   -14,    13,    42,    45,-32768,     5,
-      49,    50,-32768,-32768,    52,    -8,    64,    65,    36,-32768,
-  -32768,-32768,-32768,-32768,-32768,   -14,-32768,    55,-32768,    49,
-      56,-32768,-32768,   -20,   -20,-32768,-32768,-32768,-32768,-32768,
-  -32768,-32768,-32768,-32768,    86,    87,-32768
-};
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-static const short yypgoto[] =
-{
-  -32768,-32768,    83,    72,-32768,-32768,-32768,    -6,   -18,    -4,
-      17,-32768,-32768,    -2,   -87,   -23,-32768,    -1,-32768,-32768,
-  -32768,    14,-32768,-32768,    -5,-32768,    59,-32768,-32768,    51,
-  -32768,     7,-32768,-32768,-32768,-32768,    44,-32768,   -11,-32768,
-     -21,     8,   -10
-};
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-#define	YYLAST		114
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
 
-static const short yytable[] =
-{
-      43,    37,    51,    55,    56,   108,    59,   113,    47,     7,
-       8,     9,    10,    94,    78,    79,    80,    81,    82,    11,
-       4,    12,    13,    14,    15,    16,     1,     2,   126,    42,
-      42,   110,   111,   112,    96,     6,    97,    29,    86,    51,
-      38,    42,    90,    94,    95,    96,    44,    97,    59,    62,
-      63,    64,    65,    66,    67,    68,    69,    70,    61,    83,
-      89,    84,    71,    31,    32,    33,    34,    35,    36,    94,
-      91,    96,   108,    97,   104,    93,   105,   118,    95,    51,
-     120,   107,   123,   124,   125,   128,   135,   136,   129,    30,
-      60,   116,   127,   101,   117,   122,   106,   103,   119,   121,
-      88,   109,    92,   133,     0,    87,     0,     0,     0,     0,
-       0,     0,     0,   132,   132
-};
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
 
-static const short yycheck[] =
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
 {
-      10,     7,    12,    14,    15,    25,    16,    94,    27,     7,
-       8,     9,    10,    27,    32,    33,    34,    35,    36,    17,
-      49,    19,    20,    21,    22,    23,     5,     6,   115,    49,
-      49,    45,    46,    47,    29,     5,    31,     4,    44,    49,
-      49,    49,    53,    27,    28,    29,    49,    31,    58,    36,
-      37,    38,    39,    40,    41,    42,    43,    44,     4,    35,
-      26,    18,    49,    11,    12,    13,    14,    15,    16,    27,
-      24,    29,    25,    31,    84,    18,    18,    32,    28,    89,
-      31,    91,    18,    18,    48,    30,     0,     0,    32,     6,
-      18,    95,   115,    76,    96,   105,    89,    83,    99,   104,
-      49,    93,    58,   124,    -1,    46,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,   123,   124
-};
-#define YYPURE 1
-
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-
-/* Skeleton output parser for bison,
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
-   Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser when
-   the %semantic_parser declaration is not specified in the grammar.
-   It was written by Richard Stallman by simplifying the hairy parser
-   used when %semantic_parser is specified.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
+  return i;
+}
+#endif
 
-#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
-# else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
 #   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
 # else
-#  if defined (__STDC__) || defined (__cplusplus)
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
 #  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
 # endif
-#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
-# if YYLSP_NEEDED
-  YYLTYPE yyls;
-# endif
-};
+  };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
-# if YYLSP_NEEDED
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
-      + 2 * YYSTACK_GAP_MAX)
-# else
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
-# endif
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -572,97 +533,416 @@ union yyalloc
 	YYSIZE_T yynewbytes;						\
 	YYCOPY (&yyptr->Stack, Stack, yysize);				\
 	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  8
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   114
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  44
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  94
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  136
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     6,    10,    15,    18,    19,    22,
+      24,    26,    28,    30,    32,    34,    36,    38,    40,    42,
+      45,    46,    48,    51,    54,    57,    60,    63,    66,    67,
+      69,    71,    74,    76,    80,    83,    84,    86,    88,    90,
+      93,    95,    98,   101,   105,   107,   109,   111,   113,   116,
+     120,   123,   127,   129,   131,   133,   135,   137,   139,   141,
+     143,   145,   147,   149,   152,   154,   158,   161,   164,   168,
+     173,   176,   178,   181,   186,   189,   191,   194,   200,   202,
+     204,   207,   210,   213,   216,   218,   221,   225,   227,   230,
+     236,   238,   240,   242,   245
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      51,     0,    -1,    -1,    52,    -1,     5,    53,     4,    -1,
+       6,     5,    53,     4,    -1,    49,    54,    -1,    -1,    55,
+      54,    -1,    56,    -1,    71,    -1,    74,    -1,    73,    -1,
+      76,    -1,    79,    -1,    85,    -1,    83,    -1,    84,    -1,
+      86,    -1,     7,    58,    -1,    -1,    58,    -1,    12,    59,
+      -1,    11,    59,    -1,    13,    59,    -1,    14,    59,    -1,
+      15,    59,    -1,    16,    59,    -1,    -1,    60,    -1,    61,
+      -1,    61,    64,    -1,    62,    -1,    61,    28,    60,    -1,
+      69,    63,    -1,    -1,    61,    -1,    65,    -1,    68,    -1,
+      65,    68,    -1,    27,    -1,    27,    67,    -1,    27,    65,
+      -1,    27,    67,    65,    -1,    45,    -1,    46,    -1,    47,
+      -1,    66,    -1,    67,    66,    -1,    29,    64,    30,    -1,
+      31,    32,    -1,    68,    31,    32,    -1,    36,    -1,    37,
+      -1,    38,    -1,    39,    -1,    40,    -1,    41,    -1,    42,
+      -1,    43,    -1,    44,    -1,    70,    -1,    49,    -1,     8,
+      72,    -1,    49,    -1,    49,    35,    72,    -1,    10,    93,
+      -1,     9,    75,    -1,    58,    18,    93,    -1,    58,    18,
+      93,    75,    -1,    17,    77,    -1,    78,    -1,    78,    77,
+      -1,    49,    57,    18,    93,    -1,    19,    80,    -1,    81,
+      -1,    81,    80,    -1,    82,    26,    82,    18,    91,    -1,
+      93,    -1,    27,    -1,    21,    89,    -1,    22,    89,    -1,
+      20,    89,    -1,    23,    87,    -1,    88,    -1,    88,    87,
+      -1,    93,    18,    92,    -1,    90,    -1,    90,    89,    -1,
+      93,    24,    93,    18,    91,    -1,    93,    -1,    92,    -1,
+      25,    -1,    25,    48,    -1,    49,    -1
+};
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   160,   160,   161,   165,   167,   172,   177,   178,   183,
+     184,   185,   186,   187,   188,   189,   190,   191,   192,   196,
+     201,   202,   206,   207,   208,   209,   210,   211,   219,   220,
+     224,   225,   229,   230,   235,   239,   240,   244,   245,   246,
+     250,   251,   252,   253,   257,   258,   259,   263,   264,   268,
+     269,   270,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   294,   298,   302,   303,   308,   312,   316,   318,
+     323,   327,   328,   333,   338,   342,   343,   347,   352,   353,
+     357,   361,   365,   369,   373,   374,   378,   382,   383,   387,
+     392,   393,   397,   398,   402
+};
 #endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "MT_BADTOK", "MT_END", "MT_STATE",
+  "MT_GLOBAL", "MT_CONTEXT", "MT_ONEOF", "MT_DEFAULTS", "MT_DEFAULT",
+  "MT_REFERENCE", "MT_PARAMETER", "MT_RESULT", "MT_CLAUSE", "MT_LITERAL",
+  "MT_NULL", "MT_ANNOTATIONS", "MT_ARROW", "MT_MERGE", "MT_TRANSFERS",
+  "MT_PRECONDITIONS", "MT_POSTCONDITIONS", "MT_LOSEREFERENCE", "MT_AS",
+  "MT_ERROR", "MT_PLUS", "MT_STAR", "MT_BAR", "MT_LPAREN", "MT_RPAREN",
+  "MT_LBRACKET", "MT_RBRACKET", "MT_LBRACE", "MT_RBRACE", "MT_COMMA",
+  "MT_CHAR", "MT_INT", "MT_FLOAT", "MT_DOUBLE", "MT_VOID", "MT_ANYTYPE",
+  "MT_INTEGRALTYPE", "MT_UNSIGNEDINTEGRALTYPE", "MT_SIGNEDINTEGRALTYPE",
+  "MT_CONST", "MT_VOLATILE", "MT_RESTRICT", "MT_STRINGLIT", "MT_IDENT",
+  "$accept", "file", "mtsDeclaration", "declarationNode",
+  "declarationPieces", "declarationPiece", "contextDeclaration",
+  "optContextSelection", "contextSelection", "optType", "typeExpression",
+  "completeType", "completeTypeAux", "optCompleteType", "abstractDecl",
+  "pointers", "innerMods", "innerModsList", "abstractDeclBase",
+  "typeSpecifier", "typeName", "valuesDeclaration", "valuesList",
+  "defaultNode", "defaultsDeclaration", "defaultDeclarationList",
+  "annotationsDeclaration", "annotationsDeclarationList",
+  "annotationDeclaration", "mergeDeclaration", "mergeClauses",
+  "mergeClause", "mergeItem", "preconditionsDeclaration",
+  "postconditionsDeclaration", "transfersDeclaration",
+  "loseReferenceDeclaration", "lostClauses", "lostClause",
+  "transferClauses", "transferClause", "transferAction", "errorAction",
+  "valueChoice", 0
+};
 #endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
+};
 # endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    50,    51,    51,    52,    52,    53,    54,    54,    55,
+      55,    55,    55,    55,    55,    55,    55,    55,    55,    56,
+      57,    57,    58,    58,    58,    58,    58,    58,    59,    59,
+      60,    60,    61,    61,    62,    63,    63,    64,    64,    64,
+      65,    65,    65,    65,    66,    66,    66,    67,    67,    68,
+      68,    68,    69,    69,    69,    69,    69,    69,    69,    69,
+      69,    69,    70,    71,    72,    72,    73,    74,    75,    75,
+      76,    77,    77,    78,    79,    80,    80,    81,    82,    82,
+      83,    84,    85,    86,    87,    87,    88,    89,    89,    90,
+      91,    91,    92,    92,    93
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     1,     3,     4,     2,     0,     2,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       0,     1,     2,     2,     2,     2,     2,     2,     0,     1,
+       1,     2,     1,     3,     2,     0,     1,     1,     1,     2,
+       1,     2,     2,     3,     1,     1,     1,     1,     2,     3,
+       2,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     2,     1,     3,     2,     2,     3,     4,
+       2,     1,     2,     4,     2,     1,     2,     5,     1,     1,
+       2,     2,     2,     2,     1,     2,     3,     1,     2,     5,
+       1,     1,     1,     2,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     0,     0,     3,     7,     0,     0,     1,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     6,
+       7,     9,    10,    12,    11,    13,    14,    16,    17,    15,
+      18,     4,     0,    28,    28,    28,    28,    28,    28,    19,
+      64,    63,     0,    67,    94,    66,    20,    70,    71,    79,
+      74,    75,     0,    78,    82,    87,     0,    80,    81,    83,
+      84,     0,     8,     5,    52,    53,    54,    55,    56,    57,
+      58,    59,    60,    62,    23,    29,    30,    32,    35,    61,
+      22,    24,    25,    26,    27,     0,     0,     0,    21,    72,
+      76,     0,    88,     0,    85,     0,    40,     0,     0,     0,
+      31,    37,    38,    36,    34,    65,    68,     0,     0,     0,
+      92,    86,    44,    45,    46,    42,    47,    41,    33,     0,
+      50,    39,     0,    69,    73,     0,     0,    93,    43,    48,
+      49,    51,    77,    91,    90,    89
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     6,    19,    20,    21,    87,    42,    74,
+      75,    76,    77,   104,   100,   101,   116,   117,   102,    78,
+      79,    22,    41,    23,    24,    43,    25,    47,    48,    26,
+      50,    51,    52,    27,    28,    29,    30,    59,    60,    54,
+      55,   132,   133,    56
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int8 yypact[] =
+{
+      21,   -35,    10,    35,   -90,     2,    33,   -35,   -90,    52,
+      -9,    52,    11,    12,   -19,    11,    11,    11,    11,   -90,
+       2,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,    37,    13,    13,    13,    13,    13,    13,   -90,
+      23,   -90,    41,   -90,   -90,   -90,    52,   -90,    12,   -90,
+     -90,   -19,    44,   -90,   -90,    11,    48,   -90,   -90,   -90,
+      11,    57,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -11,   -90,    13,   -90,
+     -90,   -90,   -90,   -90,   -90,    -9,    11,    58,   -90,   -90,
+     -90,   -19,   -90,    11,   -90,    53,   -14,    13,    42,    45,
+     -90,     5,    49,    54,   -90,   -90,    52,    11,    65,    66,
+      38,   -90,   -90,   -90,   -90,   -90,   -90,   -14,   -90,    55,
+     -90,    49,    56,   -90,   -90,   -20,   -20,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -90,   -90,   -90,    80,    69,   -90,   -90,   -90,    -8,     9,
+      -7,    14,   -90,   -90,    -5,   -89,   -26,   -90,    -4,   -90,
+     -90,   -90,    15,   -90,   -90,   -10,   -90,    46,   -90,   -90,
+      47,   -90,     8,   -90,   -90,   -90,   -90,    43,   -90,   -13,
+     -90,   -25,     7,   -12
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      45,    39,    53,    57,    58,   110,    61,   115,    49,     9,
+      10,    11,    12,    96,     5,     7,    96,    97,    98,    13,
+      99,    14,    15,    16,    17,    18,     1,     2,   128,    44,
+      44,   112,   113,   114,    98,     8,    99,    31,    88,    53,
+      40,    63,    92,    80,    81,    82,    83,    84,    61,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    85,    86,
+      44,    46,    73,    33,    34,    35,    36,    37,    38,    96,
+      91,    98,    93,    99,   106,    95,   107,   120,   110,    53,
+     122,   109,    97,   125,   126,   130,   127,    32,   131,    62,
+     118,   129,   103,   119,    89,   124,   123,   121,    90,   108,
+     105,   135,   111,    94,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   134,   134
+};
+
+static const yytype_int8 yycheck[] =
+{
+      12,     9,    14,    16,    17,    25,    18,    96,    27,     7,
+       8,     9,    10,    27,    49,     5,    27,    28,    29,    17,
+      31,    19,    20,    21,    22,    23,     5,     6,   117,    49,
+      49,    45,    46,    47,    29,     0,    31,     4,    46,    51,
+      49,     4,    55,    34,    35,    36,    37,    38,    60,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    35,    18,
+      49,    49,    49,    11,    12,    13,    14,    15,    16,    27,
+      26,    29,    24,    31,    86,    18,    18,    32,    25,    91,
+      31,    93,    28,    18,    18,    30,    48,     7,    32,    20,
+      97,   117,    78,    98,    48,   107,   106,   101,    51,    91,
+      85,   126,    95,    60,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   125,   126
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     5,     6,    51,    52,    49,    53,     5,     0,     7,
+       8,     9,    10,    17,    19,    20,    21,    22,    23,    54,
+      55,    56,    71,    73,    74,    76,    79,    83,    84,    85,
+      86,     4,    53,    11,    12,    13,    14,    15,    16,    58,
+      49,    72,    58,    75,    49,    93,    49,    77,    78,    27,
+      80,    81,    82,    93,    89,    90,    93,    89,    89,    87,
+      88,    93,    54,     4,    36,    37,    38,    39,    40,    41,
+      42,    43,    44,    49,    59,    60,    61,    62,    69,    70,
+      59,    59,    59,    59,    59,    35,    18,    57,    58,    77,
+      80,    26,    89,    24,    87,    18,    27,    28,    29,    31,
+      64,    65,    68,    61,    63,    72,    93,    18,    82,    93,
+      25,    92,    45,    46,    47,    65,    66,    67,    60,    64,
+      32,    68,    31,    75,    93,    18,    18,    48,    65,    66,
+      30,    32,    91,    92,    93,    91
+};
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
+
 #define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");			\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).
-
-   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
-   first token.  By default, to implement support for ranges, extend
-   its range to the last symbol.  */
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
 
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
-   Current.last_line   = Rhs[N].last_line;	\
-   Current.last_column = Rhs[N].last_column;
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
 
-/* YYLEX -- calling `yylex' with the right arguments.  */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
 
-#if YYPURE
-# if YYLSP_NEEDED
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval, &yylloc)
-#  endif
-# else /* !YYLSP_NEEDED */
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval)
-#  endif
-# endif /* !YYLSP_NEEDED */
-#else /* !YYPURE */
-# define YYLEX			yylex ()
-#endif /* !YYPURE */
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
 
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (&yylval, YYLEX_PARAM)
+#else
+# define YYLEX yylex (&yylval)
+#endif
 
 /* Enable debugging if requested.  */
 #if YYDEBUG
@@ -676,14 +956,155 @@ while (0)
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
 
+
 /* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
 # define YYINITDEPTH 200
@@ -693,59 +1114,59 @@ int yydebug;
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
+
 
-#ifdef YYERROR_VERBOSE
+
+#if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -754,85 +1175,266 @@ yystpcpy (yydest, yysrc)
 }
 #  endif
 # endif
-#endif
-
 
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+  if (! yyres)
+    return yystrlen (yystr);
 
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
-# else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+  return yystpcpy (yyres, yystr) - yyres;
+}
 # endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
-int yyparse (void);
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
+{
+  YYUSE (yyvaluep);
 
-/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
-   variables are global, or local to YYPARSE.  */
-
-#define YY_DECL_NON_LSP_VARIABLES			\
-/* The lookahead symbol.  */				\
-int yychar;						\
-							\
-/* The semantic value of the lookahead symbol. */	\
-YYSTYPE yylval;						\
-							\
-/* Number of parse errors so far.  */			\
-int yynerrs;
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
 
-#if YYLSP_NEEDED
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES			\
-						\
-/* Location data for the lookahead symbol.  */	\
-YYLTYPE yylloc;
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
 #else
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES
+int yyparse ();
 #endif
+#endif /* ! YYPARSE_PARAM */
 
 
-/* If nonreentrant, generate the variables here. */
 
-#if !YYPURE
-YY_DECL_VARIABLES
-#endif  /* !YYPURE */
 
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
 {
-  /* If reentrant, generate the variables here. */
-#if YYPURE
-  YY_DECL_VARIABLES
-#endif  /* !YYPURE */
+  /* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -842,42 +1444,30 @@ yyparse (YYPARSE_PARAM_ARG)
      Refer to the stacks thru separate pointers, to allow yyoverflow
      to reallocate them elsewhere.  */
 
-  /* The state stack. */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
-#if YYLSP_NEEDED
-  /* The location stack.  */
-  YYLTYPE yylsa[YYINITDEPTH];
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-#endif
 
-#if YYLSP_NEEDED
-# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-# define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
-#if YYLSP_NEEDED
-  YYLTYPE yyloc;
-#endif
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule. */
-  int yylen;
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -893,9 +1483,7 @@ yyparse (YYPARSE_PARAM_ARG)
 
   yyssp = yyss;
   yyvsp = yyvs;
-#if YYLSP_NEEDED
-  yylsp = yyls;
-#endif
+
   goto yysetstate;
 
 /*------------------------------------------------------------.
@@ -903,70 +1491,60 @@ yyparse (YYPARSE_PARAM_ARG)
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
   *yyssp = yystate;
 
-  if (yyssp >= yyss + yystacksize - 1)
+  if (yyss + yystacksize - 1 <= yyssp)
     {
       /* Get the current used size of the three stacks, in elements.  */
       YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack. Use copies of
+	/* Give user a chance to reallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
+
 
 	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  */
-# if YYLSP_NEEDED
-	YYLTYPE *yyls1 = yyls;
-	/* This used to be a conditional around just the two extra args,
-	   but that might be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yyls1, yysize * sizeof (*yylsp),
-		    &yystacksize);
-	yyls = yyls1;
-# else
-	yyoverflow ("parser stack overflow",
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
+
 		    &yystacksize);
-# endif
+
 	yyss = yyss1;
 	yyvs = yyvs1;
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	goto yyoverflowlab;
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
-# if YYLSP_NEEDED
-	YYSTACK_RELOCATE (yyls);
-# endif
-# undef YYSTACK_RELOCATE
+
+#  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
       }
@@ -975,14 +1553,12 @@ yyparse (YYPARSE_PARAM_ARG)
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
-#if YYLSP_NEEDED
-      yylsp = yyls + yysize - 1;
-#endif
+
 
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
-      if (yyssp >= yyss + yystacksize - 1)
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
@@ -990,108 +1566,71 @@ yyparse (YYPARSE_PARAM_ARG)
 
   goto yybackup;
 
-
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
+      yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE (yychar);
-
-#if YYDEBUG
-     /* We have to keep this `#if YYDEBUG', since we use variables
-	which are defined only if `YYDEBUG' is set.  */
-      if (yydebug)
-	{
-	  YYFPRINTF (stderr, "Next token is %d (%s",
-		     yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise
-	     meaning of a token, for further debugging info.  */
-# ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-# endif
-	  YYFPRINTF (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1115,328 +1654,470 @@ yyreduce:
   /* If YYLEN is nonzero, implement the default value of the action:
      `$$ = $1'.
 
-     Otherwise, the following line sets YYVAL to the semantic value of
-     the lookahead token.  This behavior is undocumented and Bison
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
      users should not rely upon it.  Assigning to YYVAL
      unconditionally makes the parser a bit smaller, and it avoids a
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
-#if YYLSP_NEEDED
-  /* Similarly for the default location.  Let the user run additional
-     commands if for instance locations are ranges.  */
-  yyloc = yylsp[1-yylen];
-  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-#endif
 
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+        case 2:
+#line 160 "mtgrammar.y"
+    {;}
+    break;
+
+  case 3:
+#line 161 "mtgrammar.y"
+    {;}
+    break;
+
+  case 4:
+#line 166 "mtgrammar.y"
+    { mtreader_processDeclaration ((yyvsp[(2) - (3)].mtdecl)); ;}
+    break;
+
+  case 5:
+#line 168 "mtgrammar.y"
+    { mtreader_processGlobalDeclaration ((yyvsp[(3) - (4)].mtdecl)); ;}
+    break;
+
+  case 6:
+#line 173 "mtgrammar.y"
+    { (yyval.mtdecl) = mtDeclarationNode_create ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].mtpieces)); ;}
+    break;
+
+  case 7:
+#line 177 "mtgrammar.y"
+    { (yyval.mtpieces) = mtDeclarationPieces_create (); ;}
+    break;
+
+  case 8:
+#line 179 "mtgrammar.y"
+    { (yyval.mtpieces) = mtDeclarationPieces_append ((yyvsp[(2) - (2)].mtpieces), (yyvsp[(1) - (2)].mtpiece)); ;}
+    break;
+
+  case 9:
+#line 183 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createContext ((yyvsp[(1) - (1)].mtcontext)); ;}
+    break;
+
+  case 10:
+#line 184 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createValues ((yyvsp[(1) - (1)].mtvalues)); ;}
+    break;
+
+  case 11:
+#line 185 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createDefaults ((yyvsp[(1) - (1)].mtdefaults)); ;}
+    break;
+
+  case 12:
+#line 186 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createValueDefault ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 13:
+#line 187 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createAnnotations ((yyvsp[(1) - (1)].mtannotations)); ;}
+    break;
+
+  case 14:
+#line 188 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createMerge ((yyvsp[(1) - (1)].mtmerge)); ;}
+    break;
+
+  case 15:
+#line 189 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createTransfers ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 16:
+#line 190 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createPreconditions ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 17:
+#line 191 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createPostconditions ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 18:
+#line 192 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createLosers ((yyvsp[(1) - (1)].mtlosereferencelist)); ;}
+    break;
+
+  case 19:
+#line 196 "mtgrammar.y"
+    { (yyval.mtcontext) = (yyvsp[(2) - (2)].mtcontext); ;}
+    break;
+
+  case 20:
+#line 201 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createAny (); ;}
+    break;
+
+  case 22:
+#line 206 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createParameter ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 23:
+#line 207 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createReference ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 24:
+#line 208 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createResult ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 25:
+#line 209 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createClause ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 26:
+#line 210 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createLiteral ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 27:
+#line 211 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createNull ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 28:
+#line 219 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unknown; ;}
+    break;
+
+  case 29:
+#line 220 "mtgrammar.y"
+    { DPRINTF (("Type: %s", qtype_unparse ((yyvsp[(1) - (1)].qtyp)))); (yyval.ctyp) = qtype_getType ((yyvsp[(1) - (1)].qtyp)); ;}
+    break;
+
+  case 31:
+#line 225 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_newBase ((yyvsp[(1) - (2)].qtyp), (yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 32:
+#line 229 "mtgrammar.y"
+    { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
+    break;
+
+  case 33:
+#line 231 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_mergeAlt ((yyvsp[(1) - (3)].qtyp), (yyvsp[(3) - (3)].qtyp)); ;}
+    break;
+
+  case 34:
+#line 235 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_combine ((yyvsp[(2) - (2)].qtyp), (yyvsp[(1) - (2)].ctyp)); ;}
+    break;
+
+  case 35:
+#line 239 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_unknown (); ;}
+    break;
+
+  case 36:
+#line 240 "mtgrammar.y"
+    { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
+    break;
+
+  case 37:
+#line 244 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (1)].pointers), ctype_unknown); ;}
+    break;
+
+  case 39:
+#line 246 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (2)].pointers), (yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 40:
+#line 250 "mtgrammar.y"
+    { (yyval.pointers) = pointers_createMt ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 41:
+#line 251 "mtgrammar.y"
+    { (yyval.pointers) = pointers_createModsMt ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].quals)); ;}
+    break;
+
+  case 42:
+#line 252 "mtgrammar.y"
+    { (yyval.pointers) = pointers_extend (pointers_createMt ((yyvsp[(1) - (2)].tok)), (yyvsp[(2) - (2)].pointers)); ;}
+    break;
+
+  case 43:
+#line 253 "mtgrammar.y"
+    { (yyval.pointers) = pointers_extend (pointers_createModsMt ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].quals)), (yyvsp[(3) - (3)].pointers)); ;}
+    break;
+
+  case 44:
+#line 257 "mtgrammar.y"
+    { (yyval.qual) = qual_createConst (); ;}
+    break;
+
+  case 45:
+#line 258 "mtgrammar.y"
+    { (yyval.qual) = qual_createVolatile (); ;}
+    break;
+
+  case 46:
+#line 259 "mtgrammar.y"
+    { (yyval.qual) = qual_createRestrict (); ;}
+    break;
+
+  case 47:
+#line 263 "mtgrammar.y"
+    { (yyval.quals) = qualList_single ((yyvsp[(1) - (1)].qual)); ;}
+    break;
+
+  case 48:
+#line 264 "mtgrammar.y"
+    { (yyval.quals) = qualList_add ((yyvsp[(1) - (2)].quals), (yyvsp[(2) - (2)].qual)); ;}
+    break;
+
+  case 49:
+#line 268 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_expectFunction ((yyvsp[(2) - (3)].ctyp)); ;}
+    break;
+
+  case 50:
+#line 269 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_makeArray (ctype_unknown); ;}
+    break;
+
+  case 51:
+#line 270 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_makeArray ((yyvsp[(1) - (3)].ctyp)); ;}
+    break;
+
+  case 52:
+#line 278 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_char; ;}
+    break;
+
+  case 53:
+#line 279 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_int; ;}
+    break;
+
+  case 54:
+#line 280 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_float; ;}
+    break;
+
+  case 55:
+#line 281 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_double; ;}
+    break;
+
+  case 56:
+#line 282 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_void; ;}
+    break;
+
+  case 57:
+#line 283 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unknown; ;}
+    break;
+
+  case 58:
+#line 284 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_anyintegral; ;}
+    break;
+
+  case 59:
+#line 285 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unsignedintegral; ;}
+    break;
+
+  case 60:
+#line 286 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_signedintegral; ;}
+    break;
+
+  case 62:
+#line 294 "mtgrammar.y"
+    { (yyval.ctyp) = mtscanner_lookupType ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 63:
+#line 298 "mtgrammar.y"
+    { (yyval.mtvalues) = mtValuesNode_create ((yyvsp[(2) - (2)].cstringlist)); ;}
+    break;
+
+  case 64:
+#line 302 "mtgrammar.y"
+    { (yyval.cstringlist) = cstringList_single (mttok_getText ((yyvsp[(1) - (1)].tok))); ;}
+    break;
+
+  case 65:
+#line 304 "mtgrammar.y"
+    { (yyval.cstringlist) = cstringList_prepend ((yyvsp[(3) - (3)].cstringlist), mttok_getText ((yyvsp[(1) - (3)].tok))); ;}
+    break;
+
+  case 66:
+#line 308 "mtgrammar.y"
+    { (yyval.tok) = (yyvsp[(2) - (2)].tok); ;}
+    break;
+
+  case 67:
+#line 312 "mtgrammar.y"
+    { (yyval.mtdefaults) = mtDefaultsNode_create ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].mtdeflist)); ;}
+    break;
+
+  case 68:
+#line 317 "mtgrammar.y"
+    { (yyval.mtdeflist) = mtDefaultsDeclList_single (mtDefaultsDecl_create ((yyvsp[(1) - (3)].mtcontext), (yyvsp[(3) - (3)].tok))); ;}
+    break;
+
+  case 69:
+#line 319 "mtgrammar.y"
+    { (yyval.mtdeflist) = mtDefaultsDeclList_prepend ((yyvsp[(4) - (4)].mtdeflist), mtDefaultsDecl_create ((yyvsp[(1) - (4)].mtcontext), (yyvsp[(3) - (4)].tok))); ;}
+    break;
+
+  case 70:
+#line 323 "mtgrammar.y"
+    { (yyval.mtannotations) = mtAnnotationsNode_create ((yyvsp[(2) - (2)].mtannotlist)); ;}
+    break;
+
+  case 71:
+#line 327 "mtgrammar.y"
+    { (yyval.mtannotlist) = mtAnnotationList_single ((yyvsp[(1) - (1)].mtannotdecl)); ;}
+    break;
+
+  case 72:
+#line 329 "mtgrammar.y"
+    { (yyval.mtannotlist) = mtAnnotationList_prepend ((yyvsp[(2) - (2)].mtannotlist), (yyvsp[(1) - (2)].mtannotdecl)); ;}
+    break;
+
+  case 73:
+#line 334 "mtgrammar.y"
+    { (yyval.mtannotdecl) = mtAnnotationDecl_create ((yyvsp[(1) - (4)].tok), (yyvsp[(2) - (4)].mtcontext), (yyvsp[(4) - (4)].tok)); ;}
+    break;
+
+  case 74:
+#line 338 "mtgrammar.y"
+    { (yyval.mtmerge) = mtMergeNode_create ((yyvsp[(2) - (2)].mtmergeclauselist)); ;}
+    break;
+
+  case 75:
+#line 342 "mtgrammar.y"
+    { (yyval.mtmergeclauselist) = mtMergeClauseList_single ((yyvsp[(1) - (1)].mtmergeclause)); ;}
+    break;
+
+  case 76:
+#line 343 "mtgrammar.y"
+    { (yyval.mtmergeclauselist) = mtMergeClauseList_prepend ((yyvsp[(2) - (2)].mtmergeclauselist), (yyvsp[(1) - (2)].mtmergeclause)); ;}
+    break;
+
+  case 77:
+#line 348 "mtgrammar.y"
+    { (yyval.mtmergeclause) = mtMergeClause_create ((yyvsp[(1) - (5)].mtmergeitem), (yyvsp[(3) - (5)].mtmergeitem), (yyvsp[(5) - (5)].mttransferaction)); ;}
+    break;
+
+  case 78:
+#line 352 "mtgrammar.y"
+    { (yyval.mtmergeitem) = mtMergeItem_createValue ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 79:
+#line 353 "mtgrammar.y"
+    { (yyval.mtmergeitem) = mtMergeItem_createStar ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 80:
+#line 357 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 81:
+#line 361 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 82:
+#line 365 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 83:
+#line 369 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = (yyvsp[(2) - (2)].mtlosereferencelist); ;}
+    break;
+
+  case 84:
+#line 373 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = mtLoseReferenceList_single ((yyvsp[(1) - (1)].mtlosereference)); ;}
+    break;
+
+  case 85:
+#line 374 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = mtLoseReferenceList_prepend ((yyvsp[(2) - (2)].mtlosereferencelist), (yyvsp[(1) - (2)].mtlosereference)); ;}
+    break;
+
+  case 86:
+#line 378 "mtgrammar.y"
+    { (yyval.mtlosereference) = mtLoseReference_create ((yyvsp[(1) - (3)].tok), (yyvsp[(3) - (3)].mttransferaction)); ;}
+    break;
+
+  case 87:
+#line 382 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = mtTransferClauseList_single ((yyvsp[(1) - (1)].mttransferclause)); ;}
+    break;
+
+  case 88:
+#line 383 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = mtTransferClauseList_prepend ((yyvsp[(2) - (2)].mttransferclauselist), (yyvsp[(1) - (2)].mttransferclause)); ;}
+    break;
+
+  case 89:
+#line 388 "mtgrammar.y"
+    { (yyval.mttransferclause) = mtTransferClause_create ((yyvsp[(1) - (5)].tok), (yyvsp[(3) - (5)].tok), (yyvsp[(5) - (5)].mttransferaction)); ;}
+    break;
+
+  case 90:
+#line 392 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createValue ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 91:
+#line 393 "mtgrammar.y"
+    { (yyval.mttransferaction) = (yyvsp[(1) - (1)].mttransferaction); ;}
+    break;
+
+  case 92:
+#line 397 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createError ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 93:
+#line 398 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createErrorMessage ((yyvsp[(2) - (2)].tok)); ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 2053 "mtgrammar.tab.c"
+      default: break;
     }
-#endif
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-  switch (yyn) {
-
-case 1:
-{;
-    break;}
-case 2:
-{;
-    break;}
-case 3:
-{ mtreader_processDeclaration (yyvsp[-1].mtdecl); ;
-    break;}
-case 4:
-{ mtreader_processGlobalDeclaration (yyvsp[-1].mtdecl); ;
-    break;}
-case 5:
-{ yyval.mtdecl = mtDeclarationNode_create (yyvsp[-1].tok, yyvsp[0].mtpieces); ;
-    break;}
-case 6:
-{ yyval.mtpieces = mtDeclarationPieces_create (); ;
-    break;}
-case 7:
-{ yyval.mtpieces = mtDeclarationPieces_append (yyvsp[0].mtpieces, yyvsp[-1].mtpiece); ;
-    break;}
-case 8:
-{ yyval.mtpiece = mtDeclarationPiece_createContext (yyvsp[0].mtcontext); ;
-    break;}
-case 9:
-{ yyval.mtpiece = mtDeclarationPiece_createValues (yyvsp[0].mtvalues); ;
-    break;}
-case 10:
-{ yyval.mtpiece = mtDeclarationPiece_createDefaults (yyvsp[0].mtdefaults); ;
-    break;}
-case 11:
-{ yyval.mtpiece = mtDeclarationPiece_createValueDefault (yyvsp[0].tok); ;
-    break;}
-case 12:
-{ yyval.mtpiece = mtDeclarationPiece_createAnnotations (yyvsp[0].mtannotations); ;
-    break;}
-case 13:
-{ yyval.mtpiece = mtDeclarationPiece_createMerge (yyvsp[0].mtmerge); ;
-    break;}
-case 14:
-{ yyval.mtpiece = mtDeclarationPiece_createTransfers (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 15:
-{ yyval.mtpiece = mtDeclarationPiece_createPreconditions (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 16:
-{ yyval.mtpiece = mtDeclarationPiece_createPostconditions (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 17:
-{ yyval.mtpiece = mtDeclarationPiece_createLosers (yyvsp[0].mtlosereferencelist); ;
-    break;}
-case 18:
-{ yyval.mtcontext = yyvsp[0].mtcontext; ;
-    break;}
-case 19:
-{ yyval.mtcontext = mtContextNode_createAny (); ;
-    break;}
-case 21:
-{ yyval.mtcontext = mtContextNode_createParameter (yyvsp[0].ctyp); ;
-    break;}
-case 22:
-{ yyval.mtcontext = mtContextNode_createReference (yyvsp[0].ctyp); ;
-    break;}
-case 23:
-{ yyval.mtcontext = mtContextNode_createResult (yyvsp[0].ctyp); ;
-    break;}
-case 24:
-{ yyval.mtcontext = mtContextNode_createClause (yyvsp[0].ctyp); ;
-    break;}
-case 25:
-{ yyval.mtcontext = mtContextNode_createLiteral (yyvsp[0].ctyp); ;
-    break;}
-case 26:
-{ yyval.mtcontext = mtContextNode_createNull (yyvsp[0].ctyp); ;
-    break;}
-case 27:
-{ yyval.ctyp = ctype_unknown; ;
-    break;}
-case 28:
-{ DPRINTF (("Type: %s", qtype_unparse (yyvsp[0].qtyp))); yyval.ctyp = qtype_getType (yyvsp[0].qtyp); ;
-    break;}
-case 30:
-{ yyval.qtyp = qtype_newBase (yyvsp[-1].qtyp, yyvsp[0].ctyp); ;
-    break;}
-case 31:
-{ yyval.qtyp = yyvsp[0].qtyp; ;
-    break;}
-case 32:
-{ yyval.qtyp = qtype_mergeAlt (yyvsp[-2].qtyp, yyvsp[0].qtyp); ;
-    break;}
-case 33:
-{ yyval.qtyp = qtype_combine (yyvsp[0].qtyp, yyvsp[-1].ctyp); ;
-    break;}
-case 34:
-{ yyval.qtyp = qtype_unknown (); ;
-    break;}
-case 35:
-{ yyval.qtyp = yyvsp[0].qtyp; ;
-    break;}
-case 36:
-{ yyval.ctyp = ctype_adjustPointers (yyvsp[0].pointers, ctype_unknown); ;
-    break;}
-case 38:
-{ yyval.ctyp = ctype_adjustPointers (yyvsp[-1].pointers, yyvsp[0].ctyp); ;
-    break;}
-case 39:
-{ yyval.pointers = pointers_createMt (yyvsp[0].tok); ;
-    break;}
-case 40:
-{ yyval.pointers = pointers_createModsMt (yyvsp[-1].tok, yyvsp[0].quals); ;
-    break;}
-case 41:
-{ yyval.pointers = pointers_extend (pointers_createMt (yyvsp[-1].tok), yyvsp[0].pointers); ;
-    break;}
-case 42:
-{ yyval.pointers = pointers_extend (pointers_createModsMt (yyvsp[-2].tok, yyvsp[-1].quals), yyvsp[0].pointers); ;
-    break;}
-case 43:
-{ yyval.qual = qual_createConst (); ;
-    break;}
-case 44:
-{ yyval.qual = qual_createVolatile (); ;
-    break;}
-case 45:
-{ yyval.qual = qual_createRestrict (); ;
-    break;}
-case 46:
-{ yyval.quals = qualList_single (yyvsp[0].qual); ;
-    break;}
-case 47:
-{ yyval.quals = qualList_add (yyvsp[-1].quals, yyvsp[0].qual); ;
-    break;}
-case 48:
-{ yyval.ctyp = ctype_expectFunction (yyvsp[-1].ctyp); ;
-    break;}
-case 49:
-{ yyval.ctyp = ctype_makeArray (ctype_unknown); ;
-    break;}
-case 50:
-{ yyval.ctyp = ctype_makeArray (yyvsp[-2].ctyp); ;
-    break;}
-case 51:
-{ yyval.ctyp = ctype_char; ;
-    break;}
-case 52:
-{ yyval.ctyp = ctype_int; ;
-    break;}
-case 53:
-{ yyval.ctyp = ctype_float; ;
-    break;}
-case 54:
-{ yyval.ctyp = ctype_double; ;
-    break;}
-case 55:
-{ yyval.ctyp = ctype_void; ;
-    break;}
-case 56:
-{ yyval.ctyp = ctype_unknown; ;
-    break;}
-case 57:
-{ yyval.ctyp = ctype_anyintegral; ;
-    break;}
-case 58:
-{ yyval.ctyp = ctype_unsignedintegral; ;
-    break;}
-case 59:
-{ yyval.ctyp = ctype_signedintegral; ;
-    break;}
-case 61:
-{ yyval.ctyp = mtscanner_lookupType (yyvsp[0].tok); ;
-    break;}
-case 62:
-{ yyval.mtvalues = mtValuesNode_create (yyvsp[0].cstringlist); ;
-    break;}
-case 63:
-{ yyval.cstringlist = cstringList_single (mttok_getText (yyvsp[0].tok)); ;
-    break;}
-case 64:
-{ yyval.cstringlist = cstringList_prepend (yyvsp[0].cstringlist, mttok_getText (yyvsp[-2].tok)); ;
-    break;}
-case 65:
-{ yyval.tok = yyvsp[0].tok; ;
-    break;}
-case 66:
-{ yyval.mtdefaults = mtDefaultsNode_create (yyvsp[-1].tok, yyvsp[0].mtdeflist); ;
-    break;}
-case 67:
-{ yyval.mtdeflist = mtDefaultsDeclList_single (mtDefaultsDecl_create (yyvsp[-2].mtcontext, yyvsp[0].tok)); ;
-    break;}
-case 68:
-{ yyval.mtdeflist = mtDefaultsDeclList_prepend (yyvsp[0].mtdeflist, mtDefaultsDecl_create (yyvsp[-3].mtcontext, yyvsp[-1].tok)); ;
-    break;}
-case 69:
-{ yyval.mtannotations = mtAnnotationsNode_create (yyvsp[0].mtannotlist); ;
-    break;}
-case 70:
-{ yyval.mtannotlist = mtAnnotationList_single (yyvsp[0].mtannotdecl); ;
-    break;}
-case 71:
-{ yyval.mtannotlist = mtAnnotationList_prepend (yyvsp[0].mtannotlist, yyvsp[-1].mtannotdecl); ;
-    break;}
-case 72:
-{ yyval.mtannotdecl = mtAnnotationDecl_create (yyvsp[-3].tok, yyvsp[-2].mtcontext, yyvsp[0].tok); ;
-    break;}
-case 73:
-{ yyval.mtmerge = mtMergeNode_create (yyvsp[0].mtmergeclauselist); ;
-    break;}
-case 74:
-{ yyval.mtmergeclauselist = mtMergeClauseList_single (yyvsp[0].mtmergeclause); ;
-    break;}
-case 75:
-{ yyval.mtmergeclauselist = mtMergeClauseList_prepend (yyvsp[0].mtmergeclauselist, yyvsp[-1].mtmergeclause); ;
-    break;}
-case 76:
-{ yyval.mtmergeclause = mtMergeClause_create (yyvsp[-4].mtmergeitem, yyvsp[-2].mtmergeitem, yyvsp[0].mttransferaction); ;
-    break;}
-case 77:
-{ yyval.mtmergeitem = mtMergeItem_createValue (yyvsp[0].tok); ;
-    break;}
-case 78:
-{ yyval.mtmergeitem = mtMergeItem_createStar (yyvsp[0].tok); ;
-    break;}
-case 79:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 80:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 81:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 82:
-{ yyval.mtlosereferencelist = yyvsp[0].mtlosereferencelist; ;
-    break;}
-case 83:
-{ yyval.mtlosereferencelist = mtLoseReferenceList_single (yyvsp[0].mtlosereference); ;
-    break;}
-case 84:
-{ yyval.mtlosereferencelist = mtLoseReferenceList_prepend (yyvsp[0].mtlosereferencelist, yyvsp[-1].mtlosereference); ;
-    break;}
-case 85:
-{ yyval.mtlosereference = mtLoseReference_create (yyvsp[-2].tok, yyvsp[0].mttransferaction); ;
-    break;}
-case 86:
-{ yyval.mttransferclauselist = mtTransferClauseList_single (yyvsp[0].mttransferclause); ;
-    break;}
-case 87:
-{ yyval.mttransferclauselist = mtTransferClauseList_prepend (yyvsp[0].mttransferclauselist, yyvsp[-1].mttransferclause); ;
-    break;}
-case 88:
-{ yyval.mttransferclause = mtTransferClause_create (yyvsp[-4].tok, yyvsp[-2].tok, yyvsp[0].mttransferaction); ;
-    break;}
-case 89:
-{ yyval.mttransferaction = mtTransferAction_createValue (yyvsp[0].tok); ;
-    break;}
-case 90:
-{ yyval.mttransferaction = yyvsp[0].mttransferaction; ;
-    break;}
-case 91:
-{ yyval.mttransferaction = mtTransferAction_createError (yyvsp[0].tok); ;
-    break;}
-case 92:
-{ yyval.mttransferaction = mtTransferAction_createErrorMessage (yyvsp[0].tok); ;
-    break;}
-}
-
-
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#if YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
-#if YYLSP_NEEDED
-  *++yylsp = yyloc;
-#endif
+
 
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
@@ -1444,11 +2125,11 @@ case 92:
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
@@ -1461,155 +2142,129 @@ yyerrlab:
   if (!yyerrstatus)
     {
       ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
 	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exhausted");
-	}
-      else
-#endif /* defined (YYERROR_VERBOSE) */
-	yyerror ("parse error");
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
-  goto yyerrlab1;
 
 
-/*--------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action |
-`--------------------------------------------------*/
-yyerrlab1:
+
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yychar = YYEMPTY;
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
+  goto yyerrlab1;
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
 
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
 
-/*-------------------------------------------------------------------.
-| yyerrdefault -- current state does not do anything special for the |
-| error token.                                                       |
-`-------------------------------------------------------------------*/
-yyerrdefault:
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
 
-  /* If its default is to accept any token, ok.  Otherwise pop it.  */
-  yyn = yydefact[yystate];
-  if (yyn)
-    goto yydefault;
-#endif
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
 
-/*---------------------------------------------------------------.
-| yyerrpop -- pop the current state because it cannot handle the |
-| error token                                                    |
-`---------------------------------------------------------------*/
-yyerrpop:
-  if (yyssp == yyss)
-    YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#if YYLSP_NEEDED
-  yylsp--;
-#endif
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-#if YYDEBUG
-  if (yydebug)
+  for (;;)
     {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "Error: state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-/*--------------.
-| yyerrhandle.  |
-`--------------*/
-yyerrhandle:
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -1629,23 +2284,46 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-/*---------------------------------------------.
-| yyoverflowab -- parser overflow comes here.  |
-`---------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
+#endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
+#line 405 "mtgrammar.y"
+
+
 # include "bison.reset"
 
 extern char *yytext;
@@ -1676,6 +2354,7 @@ static void yyprint (FILE *file, int type, YYSTYPE value)
 
 
 
+
 /*
 ** Resets all flags in bison.head
 */
@@ -1726,3 +2405,5 @@ static void yyprint (FILE *file, int type, YYSTYPE value)
 
 /*drl added 12/11/2002*/
 /*@=type@*/
+
+/*@=enummemuse@*/
diff --git a/src/mtgrammar.c.der b/src/mtgrammar.c.der
index 67c2e99..4b7c5fc 100644
--- a/src/mtgrammar.c.der
+++ b/src/mtgrammar.c.der
@@ -52,69 +52,190 @@
 /*drl added 12/11/2002*/
 /*@-type@*/
 
+/*@-enummemuse@*/
+
 /* < end of bison.head > */
 
-/* A Bison parser, made from mtgrammar.y
-   by GNU bison 1.35.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-#define YYBISON 1  /* Identify Bison output.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
 #define yyparse mtparse
-#define yylex mtlex
+#define yylex   mtlex
 #define yyerror mterror
-#define yylval mtlval
-#define yychar mtchar
+#define yylval  mtlval
+#define yychar  mtchar
 #define yydebug mtdebug
 #define yynerrs mtnerrs
-# define	MT_BADTOK	257
-# define	MT_END	258
-# define	MT_STATE	259
-# define	MT_GLOBAL	260
-# define	MT_CONTEXT	261
-# define	MT_ONEOF	262
-# define	MT_DEFAULTS	263
-# define	MT_DEFAULT	264
-# define	MT_REFERENCE	265
-# define	MT_PARAMETER	266
-# define	MT_RESULT	267
-# define	MT_CLAUSE	268
-# define	MT_LITERAL	269
-# define	MT_NULL	270
-# define	MT_ANNOTATIONS	271
-# define	MT_ARROW	272
-# define	MT_MERGE	273
-# define	MT_TRANSFERS	274
-# define	MT_PRECONDITIONS	275
-# define	MT_POSTCONDITIONS	276
-# define	MT_LOSEREFERENCE	277
-# define	MT_AS	278
-# define	MT_ERROR	279
-# define	MT_PLUS	280
-# define	MT_STAR	281
-# define	MT_BAR	282
-# define	MT_LPAREN	283
-# define	MT_RPAREN	284
-# define	MT_LBRACKET	285
-# define	MT_RBRACKET	286
-# define	MT_LBRACE	287
-# define	MT_RBRACE	288
-# define	MT_COMMA	289
-# define	MT_CHAR	290
-# define	MT_INT	291
-# define	MT_FLOAT	292
-# define	MT_DOUBLE	293
-# define	MT_VOID	294
-# define	MT_ANYTYPE	295
-# define	MT_INTEGRALTYPE	296
-# define	MT_UNSIGNEDINTEGRALTYPE	297
-# define	MT_SIGNEDINTEGRALTYPE	298
-# define	MT_CONST	299
-# define	MT_VOLATILE	300
-# define	MT_RESTRICT	301
-# define	MT_STRINGLIT	302
-# define	MT_IDENT	303
 
 
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     MT_BADTOK = 258,
+     MT_END = 259,
+     MT_STATE = 260,
+     MT_GLOBAL = 261,
+     MT_CONTEXT = 262,
+     MT_ONEOF = 263,
+     MT_DEFAULTS = 264,
+     MT_DEFAULT = 265,
+     MT_REFERENCE = 266,
+     MT_PARAMETER = 267,
+     MT_RESULT = 268,
+     MT_CLAUSE = 269,
+     MT_LITERAL = 270,
+     MT_NULL = 271,
+     MT_ANNOTATIONS = 272,
+     MT_ARROW = 273,
+     MT_MERGE = 274,
+     MT_TRANSFERS = 275,
+     MT_PRECONDITIONS = 276,
+     MT_POSTCONDITIONS = 277,
+     MT_LOSEREFERENCE = 278,
+     MT_AS = 279,
+     MT_ERROR = 280,
+     MT_PLUS = 281,
+     MT_STAR = 282,
+     MT_BAR = 283,
+     MT_LPAREN = 284,
+     MT_RPAREN = 285,
+     MT_LBRACKET = 286,
+     MT_RBRACKET = 287,
+     MT_LBRACE = 288,
+     MT_RBRACE = 289,
+     MT_COMMA = 290,
+     MT_CHAR = 291,
+     MT_INT = 292,
+     MT_FLOAT = 293,
+     MT_DOUBLE = 294,
+     MT_VOID = 295,
+     MT_ANYTYPE = 296,
+     MT_INTEGRALTYPE = 297,
+     MT_UNSIGNEDINTEGRALTYPE = 298,
+     MT_SIGNEDINTEGRALTYPE = 299,
+     MT_CONST = 300,
+     MT_VOLATILE = 301,
+     MT_RESTRICT = 302,
+     MT_STRINGLIT = 303,
+     MT_IDENT = 304
+   };
+#endif
+/* Tokens.  */
+#define MT_BADTOK 258
+#define MT_END 259
+#define MT_STATE 260
+#define MT_GLOBAL 261
+#define MT_CONTEXT 262
+#define MT_ONEOF 263
+#define MT_DEFAULTS 264
+#define MT_DEFAULT 265
+#define MT_REFERENCE 266
+#define MT_PARAMETER 267
+#define MT_RESULT 268
+#define MT_CLAUSE 269
+#define MT_LITERAL 270
+#define MT_NULL 271
+#define MT_ANNOTATIONS 272
+#define MT_ARROW 273
+#define MT_MERGE 274
+#define MT_TRANSFERS 275
+#define MT_PRECONDITIONS 276
+#define MT_POSTCONDITIONS 277
+#define MT_LOSEREFERENCE 278
+#define MT_AS 279
+#define MT_ERROR 280
+#define MT_PLUS 281
+#define MT_STAR 282
+#define MT_BAR 283
+#define MT_LPAREN 284
+#define MT_RPAREN 285
+#define MT_LBRACKET 286
+#define MT_RBRACKET 287
+#define MT_LBRACE 288
+#define MT_RBRACE 289
+#define MT_COMMA 290
+#define MT_CHAR 291
+#define MT_INT 292
+#define MT_FLOAT 293
+#define MT_DOUBLE 294
+#define MT_VOID 295
+#define MT_ANYTYPE 296
+#define MT_INTEGRALTYPE 297
+#define MT_UNSIGNEDINTEGRALTYPE 298
+#define MT_SIGNEDINTEGRALTYPE 299
+#define MT_CONST 300
+#define MT_VOLATILE 301
+#define MT_RESTRICT 302
+#define MT_STRINGLIT 303
+#define MT_IDENT 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 30 "mtgrammar.y"
+
 
 # include "bison.reset"
 # include "splintMacros.nf"
@@ -143,8 +264,29 @@ static void yyprint (/*FILE *p_file, int p_type, YYSTYPE p_value */);
 # include "bison.head"
 
 
-#ifndef YYSTYPE
-typedef union {
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 62 "mtgrammar.y"
+{
   mttok tok; 
   mtDeclarationNode mtdecl;
   mtDeclarationPiece mtpiece;
@@ -171,393 +313,212 @@ typedef union {
   /*@only@*/ qtype qtyp;
   qual qual;
   qualList quals;
-} yystype;
-# define YYSTYPE yystype
+}
+/* Line 187 of yacc.c.  */
+#line 261 "mtgrammar.tab.c"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
 #endif
-#ifndef YYDEBUG
-# define YYDEBUG 1
-#endif
 
 
 
-#define	YYFINAL		136
-#define	YYFLAG		-32768
-#define	YYNTBASE	50
+/* Copy the second part of user declarations.  */
 
-/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
-#define YYTRANSLATE(x) ((unsigned)(x) <= 303 ? yytranslate[x] : 93)
 
-/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
-static const char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
-       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
-      46,    47,    48,    49
-};
-
-#if YYDEBUG
-static const short yyprhs[] =
-{
-       0,     0,     1,     3,     7,    12,    15,    16,    19,    21,
-      23,    25,    27,    29,    31,    33,    35,    37,    39,    42,
-      43,    45,    48,    51,    54,    57,    60,    63,    64,    66,
-      68,    71,    73,    77,    80,    81,    83,    85,    87,    90,
-      92,    95,    98,   102,   104,   106,   108,   110,   113,   117,
-     120,   124,   126,   128,   130,   132,   134,   136,   138,   140,
-     142,   144,   146,   149,   151,   155,   158,   161,   165,   170,
-     173,   175,   178,   183,   186,   188,   191,   197,   199,   201,
-     204,   207,   210,   213,   215,   218,   222,   224,   227,   233,
-     235,   237,   239,   242
-};
-static const short yyrhs[] =
-{
-      -1,    51,     0,     5,    52,     4,     0,     6,     5,    52,
-       4,     0,    49,    53,     0,     0,    54,    53,     0,    55,
-       0,    70,     0,    73,     0,    72,     0,    75,     0,    78,
-       0,    84,     0,    82,     0,    83,     0,    85,     0,     7,
-      57,     0,     0,    57,     0,    12,    58,     0,    11,    58,
-       0,    13,    58,     0,    14,    58,     0,    15,    58,     0,
-      16,    58,     0,     0,    59,     0,    60,     0,    60,    63,
-       0,    61,     0,    60,    28,    59,     0,    68,    62,     0,
-       0,    60,     0,    64,     0,    67,     0,    64,    67,     0,
-      27,     0,    27,    66,     0,    27,    64,     0,    27,    66,
-      64,     0,    45,     0,    46,     0,    47,     0,    65,     0,
-      66,    65,     0,    29,    63,    30,     0,    31,    32,     0,
-      67,    31,    32,     0,    36,     0,    37,     0,    38,     0,
-      39,     0,    40,     0,    41,     0,    42,     0,    43,     0,
-      44,     0,    69,     0,    49,     0,     8,    71,     0,    49,
-       0,    49,    35,    71,     0,    10,    92,     0,     9,    74,
-       0,    57,    18,    92,     0,    57,    18,    92,    74,     0,
-      17,    76,     0,    77,     0,    77,    76,     0,    49,    56,
-      18,    92,     0,    19,    79,     0,    80,     0,    80,    79,
-       0,    81,    26,    81,    18,    90,     0,    92,     0,    27,
-       0,    21,    88,     0,    22,    88,     0,    20,    88,     0,
-      23,    86,     0,    87,     0,    87,    86,     0,    92,    18,
-      91,     0,    89,     0,    89,    88,     0,    92,    24,    92,
-      18,    90,     0,    92,     0,    91,     0,    25,     0,    25,
-      48,     0,    49,     0
-};
+/* Line 216 of yacc.c.  */
+#line 274 "mtgrammar.tab.c"
 
+#ifdef short
+# undef short
 #endif
 
-#if YYDEBUG
-/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
-static const short yyrline[] =
-{
-       0,   160,   161,   165,   167,   172,   177,   178,   183,   184,
-     185,   186,   187,   188,   189,   190,   191,   192,   196,   201,
-     202,   206,   207,   208,   209,   210,   211,   219,   220,   224,
-     225,   229,   230,   235,   239,   240,   244,   245,   246,   250,
-     251,   252,   253,   257,   258,   259,   263,   264,   268,   269,
-     270,   278,   279,   280,   281,   282,   283,   284,   285,   286,
-     287,   294,   298,   302,   303,   308,   312,   316,   318,   323,
-     327,   328,   333,   338,   342,   343,   347,   352,   353,   357,
-     361,   365,   369,   373,   374,   378,   382,   383,   387,   392,
-     393,   397,   398,   402
-};
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
 #endif
 
-
-#if (YYDEBUG) || defined YYERROR_VERBOSE
-
-/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
-static const char *const yytname[] =
-{
-  "$", "error", "$undefined.", "MT_BADTOK", "MT_END", "MT_STATE", 
-  "MT_GLOBAL", "MT_CONTEXT", "MT_ONEOF", "MT_DEFAULTS", "MT_DEFAULT", 
-  "MT_REFERENCE", "MT_PARAMETER", "MT_RESULT", "MT_CLAUSE", "MT_LITERAL", 
-  "MT_NULL", "MT_ANNOTATIONS", "MT_ARROW", "MT_MERGE", "MT_TRANSFERS", 
-  "MT_PRECONDITIONS", "MT_POSTCONDITIONS", "MT_LOSEREFERENCE", "MT_AS", 
-  "MT_ERROR", "MT_PLUS", "MT_STAR", "MT_BAR", "MT_LPAREN", "MT_RPAREN", 
-  "MT_LBRACKET", "MT_RBRACKET", "MT_LBRACE", "MT_RBRACE", "MT_COMMA", 
-  "MT_CHAR", "MT_INT", "MT_FLOAT", "MT_DOUBLE", "MT_VOID", "MT_ANYTYPE", 
-  "MT_INTEGRALTYPE", "MT_UNSIGNEDINTEGRALTYPE", "MT_SIGNEDINTEGRALTYPE", 
-  "MT_CONST", "MT_VOLATILE", "MT_RESTRICT", "MT_STRINGLIT", "MT_IDENT", 
-  "file", "mtsDeclaration", "declarationNode", "declarationPieces", 
-  "declarationPiece", "contextDeclaration", "optContextSelection", 
-  "contextSelection", "optType", "typeExpression", "completeType", 
-  "completeTypeAux", "optCompleteType", "abstractDecl", "pointers", 
-  "innerMods", "innerModsList", "abstractDeclBase", "typeSpecifier", 
-  "typeName", "valuesDeclaration", "valuesList", "defaultNode", 
-  "defaultsDeclaration", "defaultDeclarationList", 
-  "annotationsDeclaration", "annotationsDeclarationList", 
-  "annotationDeclaration", "mergeDeclaration", "mergeClauses", 
-  "mergeClause", "mergeItem", "preconditionsDeclaration", 
-  "postconditionsDeclaration", "transfersDeclaration", 
-  "loseReferenceDeclaration", "lostClauses", "lostClause", 
-  "transferClauses", "transferClause", "transferAction", "errorAction", 
-  "valueChoice", 0
-};
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
 #endif
 
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
-static const short yyr1[] =
-{
-       0,    50,    50,    51,    51,    52,    53,    53,    54,    54,
-      54,    54,    54,    54,    54,    54,    54,    54,    55,    56,
-      56,    57,    57,    57,    57,    57,    57,    58,    58,    59,
-      59,    60,    60,    61,    62,    62,    63,    63,    63,    64,
-      64,    64,    64,    65,    65,    65,    66,    66,    67,    67,
-      67,    68,    68,    68,    68,    68,    68,    68,    68,    68,
-      68,    69,    70,    71,    71,    72,    73,    74,    74,    75,
-      76,    76,    77,    78,    79,    79,    80,    81,    81,    82,
-      83,    84,    85,    86,    86,    87,    88,    88,    89,    90,
-      90,    91,    91,    92
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
-static const short yyr2[] =
-{
-       0,     0,     1,     3,     4,     2,     0,     2,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     2,     0,
-       1,     2,     2,     2,     2,     2,     2,     0,     1,     1,
-       2,     1,     3,     2,     0,     1,     1,     1,     2,     1,
-       2,     2,     3,     1,     1,     1,     1,     2,     3,     2,
-       3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     2,     1,     3,     2,     2,     3,     4,     2,
-       1,     2,     4,     2,     1,     2,     5,     1,     1,     2,
-       2,     2,     2,     1,     2,     3,     1,     2,     5,     1,
-       1,     1,     2,     1
-};
-
-/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
-   doesn't specify something else to do.  Zero means the default is an
-   error. */
-static const short yydefact[] =
-{
-       1,     0,     0,     2,     6,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     5,     6,     8,
-       9,    11,    10,    12,    13,    15,    16,    14,    17,     3,
-       0,    27,    27,    27,    27,    27,    27,    18,    63,    62,
-       0,    66,    93,    65,    19,    69,    70,    78,    73,    74,
-       0,    77,    81,    86,     0,    79,    80,    82,    83,     0,
-       7,     4,    51,    52,    53,    54,    55,    56,    57,    58,
-      59,    61,    22,    28,    29,    31,    34,    60,    21,    23,
-      24,    25,    26,     0,     0,     0,    20,    71,    75,     0,
-      87,     0,    84,     0,    39,     0,     0,     0,    30,    36,
-      37,    35,    33,    64,    67,     0,     0,     0,    91,    85,
-      43,    44,    45,    41,    46,    40,    32,     0,    49,    38,
-       0,    68,    72,     0,     0,    92,    42,    47,    48,    50,
-      76,    90,    89,    88,     0,     0,     0
-};
-
-static const short yydefgoto[] =
-{
-     134,     3,     5,    17,    18,    19,    85,    40,    72,    73,
-      74,    75,   102,    98,    99,   114,   115,   100,    76,    77,
-      20,    39,    21,    22,    41,    23,    45,    46,    24,    48,
-      49,    50,    25,    26,    27,    28,    57,    58,    52,    53,
-     130,   131,    54
-};
-
-static const short yypact[] =
-{
-      21,   -29,    30,-32768,     2,    33,   -29,    52,    -9,    52,
-      -8,    -3,   -19,    -8,    -8,    -8,    -8,-32768,     2,-32768,
-  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-      54,    13,    13,    13,    13,    13,    13,-32768,    24,-32768,
-      43,-32768,-32768,-32768,    52,-32768,    -3,-32768,-32768,   -19,
-      34,-32768,-32768,    -8,    46,-32768,-32768,-32768,    -8,    57,
-  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-  -32768,-32768,-32768,-32768,    16,-32768,    13,-32768,-32768,-32768,
-  -32768,-32768,-32768,    -9,    -8,    58,-32768,-32768,-32768,   -19,
-  -32768,    -8,-32768,    47,   -14,    13,    42,    45,-32768,     5,
-      49,    50,-32768,-32768,    52,    -8,    64,    65,    36,-32768,
-  -32768,-32768,-32768,-32768,-32768,   -14,-32768,    55,-32768,    49,
-      56,-32768,-32768,   -20,   -20,-32768,-32768,-32768,-32768,-32768,
-  -32768,-32768,-32768,-32768,    86,    87,-32768
-};
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-static const short yypgoto[] =
-{
-  -32768,-32768,    83,    72,-32768,-32768,-32768,    -6,   -18,    -4,
-      17,-32768,-32768,    -2,   -87,   -23,-32768,    -1,-32768,-32768,
-  -32768,    14,-32768,-32768,    -5,-32768,    59,-32768,-32768,    51,
-  -32768,     7,-32768,-32768,-32768,-32768,    44,-32768,   -11,-32768,
-     -21,     8,   -10
-};
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-#define	YYLAST		114
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
 
-static const short yytable[] =
-{
-      43,    37,    51,    55,    56,   108,    59,   113,    47,     7,
-       8,     9,    10,    94,    78,    79,    80,    81,    82,    11,
-       4,    12,    13,    14,    15,    16,     1,     2,   126,    42,
-      42,   110,   111,   112,    96,     6,    97,    29,    86,    51,
-      38,    42,    90,    94,    95,    96,    44,    97,    59,    62,
-      63,    64,    65,    66,    67,    68,    69,    70,    61,    83,
-      89,    84,    71,    31,    32,    33,    34,    35,    36,    94,
-      91,    96,   108,    97,   104,    93,   105,   118,    95,    51,
-     120,   107,   123,   124,   125,   128,   135,   136,   129,    30,
-      60,   116,   127,   101,   117,   122,   106,   103,   119,   121,
-      88,   109,    92,   133,     0,    87,     0,     0,     0,     0,
-       0,     0,     0,   132,   132
-};
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
 
-static const short yycheck[] =
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
 {
-      10,     7,    12,    14,    15,    25,    16,    94,    27,     7,
-       8,     9,    10,    27,    32,    33,    34,    35,    36,    17,
-      49,    19,    20,    21,    22,    23,     5,     6,   115,    49,
-      49,    45,    46,    47,    29,     5,    31,     4,    44,    49,
-      49,    49,    53,    27,    28,    29,    49,    31,    58,    36,
-      37,    38,    39,    40,    41,    42,    43,    44,     4,    35,
-      26,    18,    49,    11,    12,    13,    14,    15,    16,    27,
-      24,    29,    25,    31,    84,    18,    18,    32,    28,    89,
-      31,    91,    18,    18,    48,    30,     0,     0,    32,     6,
-      18,    95,   115,    76,    96,   105,    89,    83,    99,   104,
-      49,    93,    58,   124,    -1,    46,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,   123,   124
-};
-#define YYPURE 1
-
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-
-/* Skeleton output parser for bison,
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
-   Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser when
-   the %semantic_parser declaration is not specified in the grammar.
-   It was written by Richard Stallman by simplifying the hairy parser
-   used when %semantic_parser is specified.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
+  return i;
+}
+#endif
 
-#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
-# else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
 #   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
 # else
-#  if defined (__STDC__) || defined (__cplusplus)
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
 #  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
 # endif
-#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
-# if YYLSP_NEEDED
-  YYLTYPE yyls;
-# endif
-};
+  };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
-# if YYLSP_NEEDED
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
-      + 2 * YYSTACK_GAP_MAX)
-# else
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
-# endif
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -572,97 +533,416 @@ union yyalloc
 	YYSIZE_T yynewbytes;						\
 	YYCOPY (&yyptr->Stack, Stack, yysize);				\
 	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  8
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   114
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  44
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  94
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  136
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     6,    10,    15,    18,    19,    22,
+      24,    26,    28,    30,    32,    34,    36,    38,    40,    42,
+      45,    46,    48,    51,    54,    57,    60,    63,    66,    67,
+      69,    71,    74,    76,    80,    83,    84,    86,    88,    90,
+      93,    95,    98,   101,   105,   107,   109,   111,   113,   116,
+     120,   123,   127,   129,   131,   133,   135,   137,   139,   141,
+     143,   145,   147,   149,   152,   154,   158,   161,   164,   168,
+     173,   176,   178,   181,   186,   189,   191,   194,   200,   202,
+     204,   207,   210,   213,   216,   218,   221,   225,   227,   230,
+     236,   238,   240,   242,   245
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      51,     0,    -1,    -1,    52,    -1,     5,    53,     4,    -1,
+       6,     5,    53,     4,    -1,    49,    54,    -1,    -1,    55,
+      54,    -1,    56,    -1,    71,    -1,    74,    -1,    73,    -1,
+      76,    -1,    79,    -1,    85,    -1,    83,    -1,    84,    -1,
+      86,    -1,     7,    58,    -1,    -1,    58,    -1,    12,    59,
+      -1,    11,    59,    -1,    13,    59,    -1,    14,    59,    -1,
+      15,    59,    -1,    16,    59,    -1,    -1,    60,    -1,    61,
+      -1,    61,    64,    -1,    62,    -1,    61,    28,    60,    -1,
+      69,    63,    -1,    -1,    61,    -1,    65,    -1,    68,    -1,
+      65,    68,    -1,    27,    -1,    27,    67,    -1,    27,    65,
+      -1,    27,    67,    65,    -1,    45,    -1,    46,    -1,    47,
+      -1,    66,    -1,    67,    66,    -1,    29,    64,    30,    -1,
+      31,    32,    -1,    68,    31,    32,    -1,    36,    -1,    37,
+      -1,    38,    -1,    39,    -1,    40,    -1,    41,    -1,    42,
+      -1,    43,    -1,    44,    -1,    70,    -1,    49,    -1,     8,
+      72,    -1,    49,    -1,    49,    35,    72,    -1,    10,    93,
+      -1,     9,    75,    -1,    58,    18,    93,    -1,    58,    18,
+      93,    75,    -1,    17,    77,    -1,    78,    -1,    78,    77,
+      -1,    49,    57,    18,    93,    -1,    19,    80,    -1,    81,
+      -1,    81,    80,    -1,    82,    26,    82,    18,    91,    -1,
+      93,    -1,    27,    -1,    21,    89,    -1,    22,    89,    -1,
+      20,    89,    -1,    23,    87,    -1,    88,    -1,    88,    87,
+      -1,    93,    18,    92,    -1,    90,    -1,    90,    89,    -1,
+      93,    24,    93,    18,    91,    -1,    93,    -1,    92,    -1,
+      25,    -1,    25,    48,    -1,    49,    -1
+};
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   160,   160,   161,   165,   167,   172,   177,   178,   183,
+     184,   185,   186,   187,   188,   189,   190,   191,   192,   196,
+     201,   202,   206,   207,   208,   209,   210,   211,   219,   220,
+     224,   225,   229,   230,   235,   239,   240,   244,   245,   246,
+     250,   251,   252,   253,   257,   258,   259,   263,   264,   268,
+     269,   270,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   294,   298,   302,   303,   308,   312,   316,   318,
+     323,   327,   328,   333,   338,   342,   343,   347,   352,   353,
+     357,   361,   365,   369,   373,   374,   378,   382,   383,   387,
+     392,   393,   397,   398,   402
+};
 #endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "MT_BADTOK", "MT_END", "MT_STATE",
+  "MT_GLOBAL", "MT_CONTEXT", "MT_ONEOF", "MT_DEFAULTS", "MT_DEFAULT",
+  "MT_REFERENCE", "MT_PARAMETER", "MT_RESULT", "MT_CLAUSE", "MT_LITERAL",
+  "MT_NULL", "MT_ANNOTATIONS", "MT_ARROW", "MT_MERGE", "MT_TRANSFERS",
+  "MT_PRECONDITIONS", "MT_POSTCONDITIONS", "MT_LOSEREFERENCE", "MT_AS",
+  "MT_ERROR", "MT_PLUS", "MT_STAR", "MT_BAR", "MT_LPAREN", "MT_RPAREN",
+  "MT_LBRACKET", "MT_RBRACKET", "MT_LBRACE", "MT_RBRACE", "MT_COMMA",
+  "MT_CHAR", "MT_INT", "MT_FLOAT", "MT_DOUBLE", "MT_VOID", "MT_ANYTYPE",
+  "MT_INTEGRALTYPE", "MT_UNSIGNEDINTEGRALTYPE", "MT_SIGNEDINTEGRALTYPE",
+  "MT_CONST", "MT_VOLATILE", "MT_RESTRICT", "MT_STRINGLIT", "MT_IDENT",
+  "$accept", "file", "mtsDeclaration", "declarationNode",
+  "declarationPieces", "declarationPiece", "contextDeclaration",
+  "optContextSelection", "contextSelection", "optType", "typeExpression",
+  "completeType", "completeTypeAux", "optCompleteType", "abstractDecl",
+  "pointers", "innerMods", "innerModsList", "abstractDeclBase",
+  "typeSpecifier", "typeName", "valuesDeclaration", "valuesList",
+  "defaultNode", "defaultsDeclaration", "defaultDeclarationList",
+  "annotationsDeclaration", "annotationsDeclarationList",
+  "annotationDeclaration", "mergeDeclaration", "mergeClauses",
+  "mergeClause", "mergeItem", "preconditionsDeclaration",
+  "postconditionsDeclaration", "transfersDeclaration",
+  "loseReferenceDeclaration", "lostClauses", "lostClause",
+  "transferClauses", "transferClause", "transferAction", "errorAction",
+  "valueChoice", 0
+};
 #endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
+};
 # endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    50,    51,    51,    52,    52,    53,    54,    54,    55,
+      55,    55,    55,    55,    55,    55,    55,    55,    55,    56,
+      57,    57,    58,    58,    58,    58,    58,    58,    59,    59,
+      60,    60,    61,    61,    62,    63,    63,    64,    64,    64,
+      65,    65,    65,    65,    66,    66,    66,    67,    67,    68,
+      68,    68,    69,    69,    69,    69,    69,    69,    69,    69,
+      69,    69,    70,    71,    72,    72,    73,    74,    75,    75,
+      76,    77,    77,    78,    79,    80,    80,    81,    82,    82,
+      83,    84,    85,    86,    87,    87,    88,    89,    89,    90,
+      91,    91,    92,    92,    93
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     1,     3,     4,     2,     0,     2,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       0,     1,     2,     2,     2,     2,     2,     2,     0,     1,
+       1,     2,     1,     3,     2,     0,     1,     1,     1,     2,
+       1,     2,     2,     3,     1,     1,     1,     1,     2,     3,
+       2,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     2,     1,     3,     2,     2,     3,     4,
+       2,     1,     2,     4,     2,     1,     2,     5,     1,     1,
+       2,     2,     2,     2,     1,     2,     3,     1,     2,     5,
+       1,     1,     1,     2,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     0,     0,     3,     7,     0,     0,     1,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     6,
+       7,     9,    10,    12,    11,    13,    14,    16,    17,    15,
+      18,     4,     0,    28,    28,    28,    28,    28,    28,    19,
+      64,    63,     0,    67,    94,    66,    20,    70,    71,    79,
+      74,    75,     0,    78,    82,    87,     0,    80,    81,    83,
+      84,     0,     8,     5,    52,    53,    54,    55,    56,    57,
+      58,    59,    60,    62,    23,    29,    30,    32,    35,    61,
+      22,    24,    25,    26,    27,     0,     0,     0,    21,    72,
+      76,     0,    88,     0,    85,     0,    40,     0,     0,     0,
+      31,    37,    38,    36,    34,    65,    68,     0,     0,     0,
+      92,    86,    44,    45,    46,    42,    47,    41,    33,     0,
+      50,    39,     0,    69,    73,     0,     0,    93,    43,    48,
+      49,    51,    77,    91,    90,    89
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     6,    19,    20,    21,    87,    42,    74,
+      75,    76,    77,   104,   100,   101,   116,   117,   102,    78,
+      79,    22,    41,    23,    24,    43,    25,    47,    48,    26,
+      50,    51,    52,    27,    28,    29,    30,    59,    60,    54,
+      55,   132,   133,    56
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int8 yypact[] =
+{
+      21,   -35,    10,    35,   -90,     2,    33,   -35,   -90,    52,
+      -9,    52,    11,    12,   -19,    11,    11,    11,    11,   -90,
+       2,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,    37,    13,    13,    13,    13,    13,    13,   -90,
+      23,   -90,    41,   -90,   -90,   -90,    52,   -90,    12,   -90,
+     -90,   -19,    44,   -90,   -90,    11,    48,   -90,   -90,   -90,
+      11,    57,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -11,   -90,    13,   -90,
+     -90,   -90,   -90,   -90,   -90,    -9,    11,    58,   -90,   -90,
+     -90,   -19,   -90,    11,   -90,    53,   -14,    13,    42,    45,
+     -90,     5,    49,    54,   -90,   -90,    52,    11,    65,    66,
+      38,   -90,   -90,   -90,   -90,   -90,   -90,   -14,   -90,    55,
+     -90,    49,    56,   -90,   -90,   -20,   -20,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -90,   -90,   -90,    80,    69,   -90,   -90,   -90,    -8,     9,
+      -7,    14,   -90,   -90,    -5,   -89,   -26,   -90,    -4,   -90,
+     -90,   -90,    15,   -90,   -90,   -10,   -90,    46,   -90,   -90,
+      47,   -90,     8,   -90,   -90,   -90,   -90,    43,   -90,   -13,
+     -90,   -25,     7,   -12
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      45,    39,    53,    57,    58,   110,    61,   115,    49,     9,
+      10,    11,    12,    96,     5,     7,    96,    97,    98,    13,
+      99,    14,    15,    16,    17,    18,     1,     2,   128,    44,
+      44,   112,   113,   114,    98,     8,    99,    31,    88,    53,
+      40,    63,    92,    80,    81,    82,    83,    84,    61,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    85,    86,
+      44,    46,    73,    33,    34,    35,    36,    37,    38,    96,
+      91,    98,    93,    99,   106,    95,   107,   120,   110,    53,
+     122,   109,    97,   125,   126,   130,   127,    32,   131,    62,
+     118,   129,   103,   119,    89,   124,   123,   121,    90,   108,
+     105,   135,   111,    94,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   134,   134
+};
+
+static const yytype_int8 yycheck[] =
+{
+      12,     9,    14,    16,    17,    25,    18,    96,    27,     7,
+       8,     9,    10,    27,    49,     5,    27,    28,    29,    17,
+      31,    19,    20,    21,    22,    23,     5,     6,   117,    49,
+      49,    45,    46,    47,    29,     0,    31,     4,    46,    51,
+      49,     4,    55,    34,    35,    36,    37,    38,    60,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    35,    18,
+      49,    49,    49,    11,    12,    13,    14,    15,    16,    27,
+      26,    29,    24,    31,    86,    18,    18,    32,    25,    91,
+      31,    93,    28,    18,    18,    30,    48,     7,    32,    20,
+      97,   117,    78,    98,    48,   107,   106,   101,    51,    91,
+      85,   126,    95,    60,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   125,   126
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     5,     6,    51,    52,    49,    53,     5,     0,     7,
+       8,     9,    10,    17,    19,    20,    21,    22,    23,    54,
+      55,    56,    71,    73,    74,    76,    79,    83,    84,    85,
+      86,     4,    53,    11,    12,    13,    14,    15,    16,    58,
+      49,    72,    58,    75,    49,    93,    49,    77,    78,    27,
+      80,    81,    82,    93,    89,    90,    93,    89,    89,    87,
+      88,    93,    54,     4,    36,    37,    38,    39,    40,    41,
+      42,    43,    44,    49,    59,    60,    61,    62,    69,    70,
+      59,    59,    59,    59,    59,    35,    18,    57,    58,    77,
+      80,    26,    89,    24,    87,    18,    27,    28,    29,    31,
+      64,    65,    68,    61,    63,    72,    93,    18,    82,    93,
+      25,    92,    45,    46,    47,    65,    66,    67,    60,    64,
+      32,    68,    31,    75,    93,    18,    18,    48,    65,    66,
+      30,    32,    91,    92,    93,    91
+};
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
+
 #define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");			\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).
-
-   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
-   first token.  By default, to implement support for ranges, extend
-   its range to the last symbol.  */
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
 
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
-   Current.last_line   = Rhs[N].last_line;	\
-   Current.last_column = Rhs[N].last_column;
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
 
-/* YYLEX -- calling `yylex' with the right arguments.  */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
 
-#if YYPURE
-# if YYLSP_NEEDED
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval, &yylloc)
-#  endif
-# else /* !YYLSP_NEEDED */
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval)
-#  endif
-# endif /* !YYLSP_NEEDED */
-#else /* !YYPURE */
-# define YYLEX			yylex ()
-#endif /* !YYPURE */
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
 
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (&yylval, YYLEX_PARAM)
+#else
+# define YYLEX yylex (&yylval)
+#endif
 
 /* Enable debugging if requested.  */
 #if YYDEBUG
@@ -676,14 +956,155 @@ while (0)
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
 
+
 /* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
 # define YYINITDEPTH 200
@@ -693,59 +1114,59 @@ int yydebug;
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
+
 
-#ifdef YYERROR_VERBOSE
+
+#if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -754,85 +1175,266 @@ yystpcpy (yydest, yysrc)
 }
 #  endif
 # endif
-#endif
-
 
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+  if (! yyres)
+    return yystrlen (yystr);
 
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
-# else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+  return yystpcpy (yyres, yystr) - yyres;
+}
 # endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
-int yyparse (void);
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
+{
+  YYUSE (yyvaluep);
 
-/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
-   variables are global, or local to YYPARSE.  */
-
-#define YY_DECL_NON_LSP_VARIABLES			\
-/* The lookahead symbol.  */				\
-int yychar;						\
-							\
-/* The semantic value of the lookahead symbol. */	\
-YYSTYPE yylval;						\
-							\
-/* Number of parse errors so far.  */			\
-int yynerrs;
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
 
-#if YYLSP_NEEDED
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES			\
-						\
-/* Location data for the lookahead symbol.  */	\
-YYLTYPE yylloc;
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
 #else
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES
+int yyparse ();
 #endif
+#endif /* ! YYPARSE_PARAM */
 
 
-/* If nonreentrant, generate the variables here. */
 
-#if !YYPURE
-YY_DECL_VARIABLES
-#endif  /* !YYPURE */
 
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
 {
-  /* If reentrant, generate the variables here. */
-#if YYPURE
-  YY_DECL_VARIABLES
-#endif  /* !YYPURE */
+  /* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -842,42 +1444,30 @@ yyparse (YYPARSE_PARAM_ARG)
      Refer to the stacks thru separate pointers, to allow yyoverflow
      to reallocate them elsewhere.  */
 
-  /* The state stack. */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
-#if YYLSP_NEEDED
-  /* The location stack.  */
-  YYLTYPE yylsa[YYINITDEPTH];
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-#endif
 
-#if YYLSP_NEEDED
-# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-# define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
-#if YYLSP_NEEDED
-  YYLTYPE yyloc;
-#endif
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule. */
-  int yylen;
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -893,9 +1483,7 @@ yyparse (YYPARSE_PARAM_ARG)
 
   yyssp = yyss;
   yyvsp = yyvs;
-#if YYLSP_NEEDED
-  yylsp = yyls;
-#endif
+
   goto yysetstate;
 
 /*------------------------------------------------------------.
@@ -903,70 +1491,60 @@ yyparse (YYPARSE_PARAM_ARG)
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
   *yyssp = yystate;
 
-  if (yyssp >= yyss + yystacksize - 1)
+  if (yyss + yystacksize - 1 <= yyssp)
     {
       /* Get the current used size of the three stacks, in elements.  */
       YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack. Use copies of
+	/* Give user a chance to reallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
+
 
 	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  */
-# if YYLSP_NEEDED
-	YYLTYPE *yyls1 = yyls;
-	/* This used to be a conditional around just the two extra args,
-	   but that might be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yyls1, yysize * sizeof (*yylsp),
-		    &yystacksize);
-	yyls = yyls1;
-# else
-	yyoverflow ("parser stack overflow",
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
+
 		    &yystacksize);
-# endif
+
 	yyss = yyss1;
 	yyvs = yyvs1;
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	goto yyoverflowlab;
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
-# if YYLSP_NEEDED
-	YYSTACK_RELOCATE (yyls);
-# endif
-# undef YYSTACK_RELOCATE
+
+#  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
       }
@@ -975,14 +1553,12 @@ yyparse (YYPARSE_PARAM_ARG)
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
-#if YYLSP_NEEDED
-      yylsp = yyls + yysize - 1;
-#endif
+
 
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
-      if (yyssp >= yyss + yystacksize - 1)
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
@@ -990,108 +1566,71 @@ yyparse (YYPARSE_PARAM_ARG)
 
   goto yybackup;
 
-
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
+      yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE (yychar);
-
-#if YYDEBUG
-     /* We have to keep this `#if YYDEBUG', since we use variables
-	which are defined only if `YYDEBUG' is set.  */
-      if (yydebug)
-	{
-	  YYFPRINTF (stderr, "Next token is %d (%s",
-		     yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise
-	     meaning of a token, for further debugging info.  */
-# ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-# endif
-	  YYFPRINTF (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1115,328 +1654,470 @@ yyreduce:
   /* If YYLEN is nonzero, implement the default value of the action:
      `$$ = $1'.
 
-     Otherwise, the following line sets YYVAL to the semantic value of
-     the lookahead token.  This behavior is undocumented and Bison
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
      users should not rely upon it.  Assigning to YYVAL
      unconditionally makes the parser a bit smaller, and it avoids a
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
-#if YYLSP_NEEDED
-  /* Similarly for the default location.  Let the user run additional
-     commands if for instance locations are ranges.  */
-  yyloc = yylsp[1-yylen];
-  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-#endif
 
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+        case 2:
+#line 160 "mtgrammar.y"
+    {;}
+    break;
+
+  case 3:
+#line 161 "mtgrammar.y"
+    {;}
+    break;
+
+  case 4:
+#line 166 "mtgrammar.y"
+    { mtreader_processDeclaration ((yyvsp[(2) - (3)].mtdecl)); ;}
+    break;
+
+  case 5:
+#line 168 "mtgrammar.y"
+    { mtreader_processGlobalDeclaration ((yyvsp[(3) - (4)].mtdecl)); ;}
+    break;
+
+  case 6:
+#line 173 "mtgrammar.y"
+    { (yyval.mtdecl) = mtDeclarationNode_create ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].mtpieces)); ;}
+    break;
+
+  case 7:
+#line 177 "mtgrammar.y"
+    { (yyval.mtpieces) = mtDeclarationPieces_create (); ;}
+    break;
+
+  case 8:
+#line 179 "mtgrammar.y"
+    { (yyval.mtpieces) = mtDeclarationPieces_append ((yyvsp[(2) - (2)].mtpieces), (yyvsp[(1) - (2)].mtpiece)); ;}
+    break;
+
+  case 9:
+#line 183 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createContext ((yyvsp[(1) - (1)].mtcontext)); ;}
+    break;
+
+  case 10:
+#line 184 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createValues ((yyvsp[(1) - (1)].mtvalues)); ;}
+    break;
+
+  case 11:
+#line 185 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createDefaults ((yyvsp[(1) - (1)].mtdefaults)); ;}
+    break;
+
+  case 12:
+#line 186 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createValueDefault ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 13:
+#line 187 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createAnnotations ((yyvsp[(1) - (1)].mtannotations)); ;}
+    break;
+
+  case 14:
+#line 188 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createMerge ((yyvsp[(1) - (1)].mtmerge)); ;}
+    break;
+
+  case 15:
+#line 189 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createTransfers ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 16:
+#line 190 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createPreconditions ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 17:
+#line 191 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createPostconditions ((yyvsp[(1) - (1)].mttransferclauselist)); ;}
+    break;
+
+  case 18:
+#line 192 "mtgrammar.y"
+    { (yyval.mtpiece) = mtDeclarationPiece_createLosers ((yyvsp[(1) - (1)].mtlosereferencelist)); ;}
+    break;
+
+  case 19:
+#line 196 "mtgrammar.y"
+    { (yyval.mtcontext) = (yyvsp[(2) - (2)].mtcontext); ;}
+    break;
+
+  case 20:
+#line 201 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createAny (); ;}
+    break;
+
+  case 22:
+#line 206 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createParameter ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 23:
+#line 207 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createReference ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 24:
+#line 208 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createResult ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 25:
+#line 209 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createClause ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 26:
+#line 210 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createLiteral ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 27:
+#line 211 "mtgrammar.y"
+    { (yyval.mtcontext) = mtContextNode_createNull ((yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 28:
+#line 219 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unknown; ;}
+    break;
+
+  case 29:
+#line 220 "mtgrammar.y"
+    { DPRINTF (("Type: %s", qtype_unparse ((yyvsp[(1) - (1)].qtyp)))); (yyval.ctyp) = qtype_getType ((yyvsp[(1) - (1)].qtyp)); ;}
+    break;
+
+  case 31:
+#line 225 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_newBase ((yyvsp[(1) - (2)].qtyp), (yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 32:
+#line 229 "mtgrammar.y"
+    { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
+    break;
+
+  case 33:
+#line 231 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_mergeAlt ((yyvsp[(1) - (3)].qtyp), (yyvsp[(3) - (3)].qtyp)); ;}
+    break;
+
+  case 34:
+#line 235 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_combine ((yyvsp[(2) - (2)].qtyp), (yyvsp[(1) - (2)].ctyp)); ;}
+    break;
+
+  case 35:
+#line 239 "mtgrammar.y"
+    { (yyval.qtyp) = qtype_unknown (); ;}
+    break;
+
+  case 36:
+#line 240 "mtgrammar.y"
+    { (yyval.qtyp) = (yyvsp[(1) - (1)].qtyp); ;}
+    break;
+
+  case 37:
+#line 244 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (1)].pointers), ctype_unknown); ;}
+    break;
+
+  case 39:
+#line 246 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_adjustPointers ((yyvsp[(1) - (2)].pointers), (yyvsp[(2) - (2)].ctyp)); ;}
+    break;
+
+  case 40:
+#line 250 "mtgrammar.y"
+    { (yyval.pointers) = pointers_createMt ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 41:
+#line 251 "mtgrammar.y"
+    { (yyval.pointers) = pointers_createModsMt ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].quals)); ;}
+    break;
+
+  case 42:
+#line 252 "mtgrammar.y"
+    { (yyval.pointers) = pointers_extend (pointers_createMt ((yyvsp[(1) - (2)].tok)), (yyvsp[(2) - (2)].pointers)); ;}
+    break;
+
+  case 43:
+#line 253 "mtgrammar.y"
+    { (yyval.pointers) = pointers_extend (pointers_createModsMt ((yyvsp[(1) - (3)].tok), (yyvsp[(2) - (3)].quals)), (yyvsp[(3) - (3)].pointers)); ;}
+    break;
+
+  case 44:
+#line 257 "mtgrammar.y"
+    { (yyval.qual) = qual_createConst (); ;}
+    break;
+
+  case 45:
+#line 258 "mtgrammar.y"
+    { (yyval.qual) = qual_createVolatile (); ;}
+    break;
+
+  case 46:
+#line 259 "mtgrammar.y"
+    { (yyval.qual) = qual_createRestrict (); ;}
+    break;
+
+  case 47:
+#line 263 "mtgrammar.y"
+    { (yyval.quals) = qualList_single ((yyvsp[(1) - (1)].qual)); ;}
+    break;
+
+  case 48:
+#line 264 "mtgrammar.y"
+    { (yyval.quals) = qualList_add ((yyvsp[(1) - (2)].quals), (yyvsp[(2) - (2)].qual)); ;}
+    break;
+
+  case 49:
+#line 268 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_expectFunction ((yyvsp[(2) - (3)].ctyp)); ;}
+    break;
+
+  case 50:
+#line 269 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_makeArray (ctype_unknown); ;}
+    break;
+
+  case 51:
+#line 270 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_makeArray ((yyvsp[(1) - (3)].ctyp)); ;}
+    break;
+
+  case 52:
+#line 278 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_char; ;}
+    break;
+
+  case 53:
+#line 279 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_int; ;}
+    break;
+
+  case 54:
+#line 280 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_float; ;}
+    break;
+
+  case 55:
+#line 281 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_double; ;}
+    break;
+
+  case 56:
+#line 282 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_void; ;}
+    break;
+
+  case 57:
+#line 283 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unknown; ;}
+    break;
+
+  case 58:
+#line 284 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_anyintegral; ;}
+    break;
+
+  case 59:
+#line 285 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_unsignedintegral; ;}
+    break;
+
+  case 60:
+#line 286 "mtgrammar.y"
+    { (yyval.ctyp) = ctype_signedintegral; ;}
+    break;
+
+  case 62:
+#line 294 "mtgrammar.y"
+    { (yyval.ctyp) = mtscanner_lookupType ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 63:
+#line 298 "mtgrammar.y"
+    { (yyval.mtvalues) = mtValuesNode_create ((yyvsp[(2) - (2)].cstringlist)); ;}
+    break;
+
+  case 64:
+#line 302 "mtgrammar.y"
+    { (yyval.cstringlist) = cstringList_single (mttok_getText ((yyvsp[(1) - (1)].tok))); ;}
+    break;
+
+  case 65:
+#line 304 "mtgrammar.y"
+    { (yyval.cstringlist) = cstringList_prepend ((yyvsp[(3) - (3)].cstringlist), mttok_getText ((yyvsp[(1) - (3)].tok))); ;}
+    break;
+
+  case 66:
+#line 308 "mtgrammar.y"
+    { (yyval.tok) = (yyvsp[(2) - (2)].tok); ;}
+    break;
+
+  case 67:
+#line 312 "mtgrammar.y"
+    { (yyval.mtdefaults) = mtDefaultsNode_create ((yyvsp[(1) - (2)].tok), (yyvsp[(2) - (2)].mtdeflist)); ;}
+    break;
+
+  case 68:
+#line 317 "mtgrammar.y"
+    { (yyval.mtdeflist) = mtDefaultsDeclList_single (mtDefaultsDecl_create ((yyvsp[(1) - (3)].mtcontext), (yyvsp[(3) - (3)].tok))); ;}
+    break;
+
+  case 69:
+#line 319 "mtgrammar.y"
+    { (yyval.mtdeflist) = mtDefaultsDeclList_prepend ((yyvsp[(4) - (4)].mtdeflist), mtDefaultsDecl_create ((yyvsp[(1) - (4)].mtcontext), (yyvsp[(3) - (4)].tok))); ;}
+    break;
+
+  case 70:
+#line 323 "mtgrammar.y"
+    { (yyval.mtannotations) = mtAnnotationsNode_create ((yyvsp[(2) - (2)].mtannotlist)); ;}
+    break;
+
+  case 71:
+#line 327 "mtgrammar.y"
+    { (yyval.mtannotlist) = mtAnnotationList_single ((yyvsp[(1) - (1)].mtannotdecl)); ;}
+    break;
+
+  case 72:
+#line 329 "mtgrammar.y"
+    { (yyval.mtannotlist) = mtAnnotationList_prepend ((yyvsp[(2) - (2)].mtannotlist), (yyvsp[(1) - (2)].mtannotdecl)); ;}
+    break;
+
+  case 73:
+#line 334 "mtgrammar.y"
+    { (yyval.mtannotdecl) = mtAnnotationDecl_create ((yyvsp[(1) - (4)].tok), (yyvsp[(2) - (4)].mtcontext), (yyvsp[(4) - (4)].tok)); ;}
+    break;
+
+  case 74:
+#line 338 "mtgrammar.y"
+    { (yyval.mtmerge) = mtMergeNode_create ((yyvsp[(2) - (2)].mtmergeclauselist)); ;}
+    break;
+
+  case 75:
+#line 342 "mtgrammar.y"
+    { (yyval.mtmergeclauselist) = mtMergeClauseList_single ((yyvsp[(1) - (1)].mtmergeclause)); ;}
+    break;
+
+  case 76:
+#line 343 "mtgrammar.y"
+    { (yyval.mtmergeclauselist) = mtMergeClauseList_prepend ((yyvsp[(2) - (2)].mtmergeclauselist), (yyvsp[(1) - (2)].mtmergeclause)); ;}
+    break;
+
+  case 77:
+#line 348 "mtgrammar.y"
+    { (yyval.mtmergeclause) = mtMergeClause_create ((yyvsp[(1) - (5)].mtmergeitem), (yyvsp[(3) - (5)].mtmergeitem), (yyvsp[(5) - (5)].mttransferaction)); ;}
+    break;
+
+  case 78:
+#line 352 "mtgrammar.y"
+    { (yyval.mtmergeitem) = mtMergeItem_createValue ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 79:
+#line 353 "mtgrammar.y"
+    { (yyval.mtmergeitem) = mtMergeItem_createStar ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 80:
+#line 357 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 81:
+#line 361 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 82:
+#line 365 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = (yyvsp[(2) - (2)].mttransferclauselist); ;}
+    break;
+
+  case 83:
+#line 369 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = (yyvsp[(2) - (2)].mtlosereferencelist); ;}
+    break;
+
+  case 84:
+#line 373 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = mtLoseReferenceList_single ((yyvsp[(1) - (1)].mtlosereference)); ;}
+    break;
+
+  case 85:
+#line 374 "mtgrammar.y"
+    { (yyval.mtlosereferencelist) = mtLoseReferenceList_prepend ((yyvsp[(2) - (2)].mtlosereferencelist), (yyvsp[(1) - (2)].mtlosereference)); ;}
+    break;
+
+  case 86:
+#line 378 "mtgrammar.y"
+    { (yyval.mtlosereference) = mtLoseReference_create ((yyvsp[(1) - (3)].tok), (yyvsp[(3) - (3)].mttransferaction)); ;}
+    break;
+
+  case 87:
+#line 382 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = mtTransferClauseList_single ((yyvsp[(1) - (1)].mttransferclause)); ;}
+    break;
+
+  case 88:
+#line 383 "mtgrammar.y"
+    { (yyval.mttransferclauselist) = mtTransferClauseList_prepend ((yyvsp[(2) - (2)].mttransferclauselist), (yyvsp[(1) - (2)].mttransferclause)); ;}
+    break;
+
+  case 89:
+#line 388 "mtgrammar.y"
+    { (yyval.mttransferclause) = mtTransferClause_create ((yyvsp[(1) - (5)].tok), (yyvsp[(3) - (5)].tok), (yyvsp[(5) - (5)].mttransferaction)); ;}
+    break;
+
+  case 90:
+#line 392 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createValue ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 91:
+#line 393 "mtgrammar.y"
+    { (yyval.mttransferaction) = (yyvsp[(1) - (1)].mttransferaction); ;}
+    break;
+
+  case 92:
+#line 397 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createError ((yyvsp[(1) - (1)].tok)); ;}
+    break;
+
+  case 93:
+#line 398 "mtgrammar.y"
+    { (yyval.mttransferaction) = mtTransferAction_createErrorMessage ((yyvsp[(2) - (2)].tok)); ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 2053 "mtgrammar.tab.c"
+      default: break;
     }
-#endif
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-  switch (yyn) {
-
-case 1:
-{;
-    break;}
-case 2:
-{;
-    break;}
-case 3:
-{ mtreader_processDeclaration (yyvsp[-1].mtdecl); ;
-    break;}
-case 4:
-{ mtreader_processGlobalDeclaration (yyvsp[-1].mtdecl); ;
-    break;}
-case 5:
-{ yyval.mtdecl = mtDeclarationNode_create (yyvsp[-1].tok, yyvsp[0].mtpieces); ;
-    break;}
-case 6:
-{ yyval.mtpieces = mtDeclarationPieces_create (); ;
-    break;}
-case 7:
-{ yyval.mtpieces = mtDeclarationPieces_append (yyvsp[0].mtpieces, yyvsp[-1].mtpiece); ;
-    break;}
-case 8:
-{ yyval.mtpiece = mtDeclarationPiece_createContext (yyvsp[0].mtcontext); ;
-    break;}
-case 9:
-{ yyval.mtpiece = mtDeclarationPiece_createValues (yyvsp[0].mtvalues); ;
-    break;}
-case 10:
-{ yyval.mtpiece = mtDeclarationPiece_createDefaults (yyvsp[0].mtdefaults); ;
-    break;}
-case 11:
-{ yyval.mtpiece = mtDeclarationPiece_createValueDefault (yyvsp[0].tok); ;
-    break;}
-case 12:
-{ yyval.mtpiece = mtDeclarationPiece_createAnnotations (yyvsp[0].mtannotations); ;
-    break;}
-case 13:
-{ yyval.mtpiece = mtDeclarationPiece_createMerge (yyvsp[0].mtmerge); ;
-    break;}
-case 14:
-{ yyval.mtpiece = mtDeclarationPiece_createTransfers (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 15:
-{ yyval.mtpiece = mtDeclarationPiece_createPreconditions (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 16:
-{ yyval.mtpiece = mtDeclarationPiece_createPostconditions (yyvsp[0].mttransferclauselist); ;
-    break;}
-case 17:
-{ yyval.mtpiece = mtDeclarationPiece_createLosers (yyvsp[0].mtlosereferencelist); ;
-    break;}
-case 18:
-{ yyval.mtcontext = yyvsp[0].mtcontext; ;
-    break;}
-case 19:
-{ yyval.mtcontext = mtContextNode_createAny (); ;
-    break;}
-case 21:
-{ yyval.mtcontext = mtContextNode_createParameter (yyvsp[0].ctyp); ;
-    break;}
-case 22:
-{ yyval.mtcontext = mtContextNode_createReference (yyvsp[0].ctyp); ;
-    break;}
-case 23:
-{ yyval.mtcontext = mtContextNode_createResult (yyvsp[0].ctyp); ;
-    break;}
-case 24:
-{ yyval.mtcontext = mtContextNode_createClause (yyvsp[0].ctyp); ;
-    break;}
-case 25:
-{ yyval.mtcontext = mtContextNode_createLiteral (yyvsp[0].ctyp); ;
-    break;}
-case 26:
-{ yyval.mtcontext = mtContextNode_createNull (yyvsp[0].ctyp); ;
-    break;}
-case 27:
-{ yyval.ctyp = ctype_unknown; ;
-    break;}
-case 28:
-{ DPRINTF (("Type: %s", qtype_unparse (yyvsp[0].qtyp))); yyval.ctyp = qtype_getType (yyvsp[0].qtyp); ;
-    break;}
-case 30:
-{ yyval.qtyp = qtype_newBase (yyvsp[-1].qtyp, yyvsp[0].ctyp); ;
-    break;}
-case 31:
-{ yyval.qtyp = yyvsp[0].qtyp; ;
-    break;}
-case 32:
-{ yyval.qtyp = qtype_mergeAlt (yyvsp[-2].qtyp, yyvsp[0].qtyp); ;
-    break;}
-case 33:
-{ yyval.qtyp = qtype_combine (yyvsp[0].qtyp, yyvsp[-1].ctyp); ;
-    break;}
-case 34:
-{ yyval.qtyp = qtype_unknown (); ;
-    break;}
-case 35:
-{ yyval.qtyp = yyvsp[0].qtyp; ;
-    break;}
-case 36:
-{ yyval.ctyp = ctype_adjustPointers (yyvsp[0].pointers, ctype_unknown); ;
-    break;}
-case 38:
-{ yyval.ctyp = ctype_adjustPointers (yyvsp[-1].pointers, yyvsp[0].ctyp); ;
-    break;}
-case 39:
-{ yyval.pointers = pointers_createMt (yyvsp[0].tok); ;
-    break;}
-case 40:
-{ yyval.pointers = pointers_createModsMt (yyvsp[-1].tok, yyvsp[0].quals); ;
-    break;}
-case 41:
-{ yyval.pointers = pointers_extend (pointers_createMt (yyvsp[-1].tok), yyvsp[0].pointers); ;
-    break;}
-case 42:
-{ yyval.pointers = pointers_extend (pointers_createModsMt (yyvsp[-2].tok, yyvsp[-1].quals), yyvsp[0].pointers); ;
-    break;}
-case 43:
-{ yyval.qual = qual_createConst (); ;
-    break;}
-case 44:
-{ yyval.qual = qual_createVolatile (); ;
-    break;}
-case 45:
-{ yyval.qual = qual_createRestrict (); ;
-    break;}
-case 46:
-{ yyval.quals = qualList_single (yyvsp[0].qual); ;
-    break;}
-case 47:
-{ yyval.quals = qualList_add (yyvsp[-1].quals, yyvsp[0].qual); ;
-    break;}
-case 48:
-{ yyval.ctyp = ctype_expectFunction (yyvsp[-1].ctyp); ;
-    break;}
-case 49:
-{ yyval.ctyp = ctype_makeArray (ctype_unknown); ;
-    break;}
-case 50:
-{ yyval.ctyp = ctype_makeArray (yyvsp[-2].ctyp); ;
-    break;}
-case 51:
-{ yyval.ctyp = ctype_char; ;
-    break;}
-case 52:
-{ yyval.ctyp = ctype_int; ;
-    break;}
-case 53:
-{ yyval.ctyp = ctype_float; ;
-    break;}
-case 54:
-{ yyval.ctyp = ctype_double; ;
-    break;}
-case 55:
-{ yyval.ctyp = ctype_void; ;
-    break;}
-case 56:
-{ yyval.ctyp = ctype_unknown; ;
-    break;}
-case 57:
-{ yyval.ctyp = ctype_anyintegral; ;
-    break;}
-case 58:
-{ yyval.ctyp = ctype_unsignedintegral; ;
-    break;}
-case 59:
-{ yyval.ctyp = ctype_signedintegral; ;
-    break;}
-case 61:
-{ yyval.ctyp = mtscanner_lookupType (yyvsp[0].tok); ;
-    break;}
-case 62:
-{ yyval.mtvalues = mtValuesNode_create (yyvsp[0].cstringlist); ;
-    break;}
-case 63:
-{ yyval.cstringlist = cstringList_single (mttok_getText (yyvsp[0].tok)); ;
-    break;}
-case 64:
-{ yyval.cstringlist = cstringList_prepend (yyvsp[0].cstringlist, mttok_getText (yyvsp[-2].tok)); ;
-    break;}
-case 65:
-{ yyval.tok = yyvsp[0].tok; ;
-    break;}
-case 66:
-{ yyval.mtdefaults = mtDefaultsNode_create (yyvsp[-1].tok, yyvsp[0].mtdeflist); ;
-    break;}
-case 67:
-{ yyval.mtdeflist = mtDefaultsDeclList_single (mtDefaultsDecl_create (yyvsp[-2].mtcontext, yyvsp[0].tok)); ;
-    break;}
-case 68:
-{ yyval.mtdeflist = mtDefaultsDeclList_prepend (yyvsp[0].mtdeflist, mtDefaultsDecl_create (yyvsp[-3].mtcontext, yyvsp[-1].tok)); ;
-    break;}
-case 69:
-{ yyval.mtannotations = mtAnnotationsNode_create (yyvsp[0].mtannotlist); ;
-    break;}
-case 70:
-{ yyval.mtannotlist = mtAnnotationList_single (yyvsp[0].mtannotdecl); ;
-    break;}
-case 71:
-{ yyval.mtannotlist = mtAnnotationList_prepend (yyvsp[0].mtannotlist, yyvsp[-1].mtannotdecl); ;
-    break;}
-case 72:
-{ yyval.mtannotdecl = mtAnnotationDecl_create (yyvsp[-3].tok, yyvsp[-2].mtcontext, yyvsp[0].tok); ;
-    break;}
-case 73:
-{ yyval.mtmerge = mtMergeNode_create (yyvsp[0].mtmergeclauselist); ;
-    break;}
-case 74:
-{ yyval.mtmergeclauselist = mtMergeClauseList_single (yyvsp[0].mtmergeclause); ;
-    break;}
-case 75:
-{ yyval.mtmergeclauselist = mtMergeClauseList_prepend (yyvsp[0].mtmergeclauselist, yyvsp[-1].mtmergeclause); ;
-    break;}
-case 76:
-{ yyval.mtmergeclause = mtMergeClause_create (yyvsp[-4].mtmergeitem, yyvsp[-2].mtmergeitem, yyvsp[0].mttransferaction); ;
-    break;}
-case 77:
-{ yyval.mtmergeitem = mtMergeItem_createValue (yyvsp[0].tok); ;
-    break;}
-case 78:
-{ yyval.mtmergeitem = mtMergeItem_createStar (yyvsp[0].tok); ;
-    break;}
-case 79:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 80:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 81:
-{ yyval.mttransferclauselist = yyvsp[0].mttransferclauselist; ;
-    break;}
-case 82:
-{ yyval.mtlosereferencelist = yyvsp[0].mtlosereferencelist; ;
-    break;}
-case 83:
-{ yyval.mtlosereferencelist = mtLoseReferenceList_single (yyvsp[0].mtlosereference); ;
-    break;}
-case 84:
-{ yyval.mtlosereferencelist = mtLoseReferenceList_prepend (yyvsp[0].mtlosereferencelist, yyvsp[-1].mtlosereference); ;
-    break;}
-case 85:
-{ yyval.mtlosereference = mtLoseReference_create (yyvsp[-2].tok, yyvsp[0].mttransferaction); ;
-    break;}
-case 86:
-{ yyval.mttransferclauselist = mtTransferClauseList_single (yyvsp[0].mttransferclause); ;
-    break;}
-case 87:
-{ yyval.mttransferclauselist = mtTransferClauseList_prepend (yyvsp[0].mttransferclauselist, yyvsp[-1].mttransferclause); ;
-    break;}
-case 88:
-{ yyval.mttransferclause = mtTransferClause_create (yyvsp[-4].tok, yyvsp[-2].tok, yyvsp[0].mttransferaction); ;
-    break;}
-case 89:
-{ yyval.mttransferaction = mtTransferAction_createValue (yyvsp[0].tok); ;
-    break;}
-case 90:
-{ yyval.mttransferaction = yyvsp[0].mttransferaction; ;
-    break;}
-case 91:
-{ yyval.mttransferaction = mtTransferAction_createError (yyvsp[0].tok); ;
-    break;}
-case 92:
-{ yyval.mttransferaction = mtTransferAction_createErrorMessage (yyvsp[0].tok); ;
-    break;}
-}
-
-
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#if YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
-#if YYLSP_NEEDED
-  *++yylsp = yyloc;
-#endif
+
 
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
@@ -1444,11 +2125,11 @@ case 92:
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
@@ -1461,155 +2142,129 @@ yyerrlab:
   if (!yyerrstatus)
     {
       ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
 	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exhausted");
-	}
-      else
-#endif /* defined (YYERROR_VERBOSE) */
-	yyerror ("parse error");
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
-  goto yyerrlab1;
 
 
-/*--------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action |
-`--------------------------------------------------*/
-yyerrlab1:
+
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yychar = YYEMPTY;
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
+  goto yyerrlab1;
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
 
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
 
-/*-------------------------------------------------------------------.
-| yyerrdefault -- current state does not do anything special for the |
-| error token.                                                       |
-`-------------------------------------------------------------------*/
-yyerrdefault:
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
 
-  /* If its default is to accept any token, ok.  Otherwise pop it.  */
-  yyn = yydefact[yystate];
-  if (yyn)
-    goto yydefault;
-#endif
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
 
-/*---------------------------------------------------------------.
-| yyerrpop -- pop the current state because it cannot handle the |
-| error token                                                    |
-`---------------------------------------------------------------*/
-yyerrpop:
-  if (yyssp == yyss)
-    YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#if YYLSP_NEEDED
-  yylsp--;
-#endif
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-#if YYDEBUG
-  if (yydebug)
+  for (;;)
     {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "Error: state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-/*--------------.
-| yyerrhandle.  |
-`--------------*/
-yyerrhandle:
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -1629,23 +2284,46 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-/*---------------------------------------------.
-| yyoverflowab -- parser overflow comes here.  |
-`---------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
+#endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
+#line 405 "mtgrammar.y"
+
+
 # include "bison.reset"
 
 extern char *yytext;
@@ -1676,6 +2354,7 @@ static void yyprint (FILE *file, int type, YYSTYPE value)
 
 
 
+
 /*
 ** Resets all flags in bison.head
 */
@@ -1726,3 +2405,5 @@ static void yyprint (FILE *file, int type, YYSTYPE value)
 
 /*drl added 12/11/2002*/
 /*@=type@*/
+
+/*@=enummemuse@*/
diff --git a/src/signature.c.der b/src/signature.c.der
index 1c270a8..112260a 100644
--- a/src/signature.c.der
+++ b/src/signature.c.der
@@ -230,7 +230,7 @@
 
 
 /* Copy the first part of user declarations.  */
-
+#line 32 "signature.y"
 
 
 # include <stdio.h>
@@ -278,7 +278,7 @@ static void yyprint (/*FILE *p_file, int p_type, YYSTYPE p_value */);
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
+#line 71 "signature.y"
 {
   ltoken ltok;  /* a leaf is also an ltoken */
   unsigned int count;
@@ -290,8 +290,8 @@ typedef union YYSTYPE
   /*@only@*/  lslOpList operators;
   /*@-redef@*/ /*@-matchfields@*/ 
 }
-/* Line 193 of yacc.c.  */
-
+/* Line 187 of yacc.c.  */
+#line 237 "signature.tab.c"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
@@ -304,7 +304,7 @@ typedef union YYSTYPE
 
 
 /* Line 216 of yacc.c.  */
-
+#line 250 "signature.tab.c"
 
 #ifdef short
 # undef short
@@ -1559,12 +1559,12 @@ yyreduce:
   switch (yyn)
     {
         case 2:
-
+#line 139 "signature.y"
     { lslOpList_free ((yyvsp[(1) - (1)].operators)); ;}
     break;
 
   case 3:
-
+#line 143 "signature.y"
     { lslOpList x = lslOpList_new ();
 		g_importedlslOp = (yyvsp[(1) - (1)].operator);
 		lslOpList_add (x, (yyvsp[(1) - (1)].operator));
@@ -1572,186 +1572,186 @@ yyreduce:
     break;
 
   case 4:
-
+#line 148 "signature.y"
     { lslOpList_add ((yyvsp[(1) - (2)].operators), (yyvsp[(2) - (2)].operator));
 		(yyval.operators) = (yyvsp[(1) - (2)].operators); ;}
     break;
 
   case 5:
-
+#line 153 "signature.y"
     { (yyval.operator) = makelslOpNode ((yyvsp[(1) - (3)].name), (yyvsp[(3) - (3)].signature)); ;}
     break;
 
   case 6:
-
+#line 160 "signature.y"
     { (yyval.name) = makeNameNodeId ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 7:
-
+#line 162 "signature.y"
     { (yyval.name) = makeNameNodeForm ((yyvsp[(1) - (1)].opform)); ;}
     break;
 
   case 8:
-
+#line 167 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (6)].ltok), OPF_IF, opFormUnion_createMiddle (0), ltoken_undefined); ;}
     break;
 
   case 9:
-
+#line 169 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (1)].ltok), OPF_ANYOP, opFormUnion_createAnyOp ((yyvsp[(1) - (1)].ltok)), ltoken_undefined); ;}
     break;
 
   case 10:
-
+#line 171 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_MANYOP, opFormUnion_createAnyOp ((yyvsp[(2) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 11:
-
+#line 173 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_ANYOPM, opFormUnion_createAnyOp ((yyvsp[(1) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 12:
-
+#line 175 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MANYOPM, opFormUnion_createAnyOp ((yyvsp[(2) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 13:
-
+#line 177 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MIDDLE, opFormUnion_createMiddle ((yyvsp[(2) - (3)].count)), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 14:
-
+#line 179 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (4)].ltok), OPF_MMIDDLE, opFormUnion_createMiddle ((yyvsp[(3) - (4)].count)), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 15:
-
+#line 181 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (4)].ltok), OPF_MIDDLEM, opFormUnion_createMiddle ((yyvsp[(2) - (4)].count)), (yyvsp[(3) - (4)].ltok)); ;}
     break;
 
   case 16:
-
+#line 183 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (5)].ltok), OPF_MMIDDLEM, 
 			      opFormUnion_createMiddle ((yyvsp[(3) - (5)].count)), (yyvsp[(4) - (5)].ltok)); ;}
     break;
 
   case 17:
-
+#line 186 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_BMIDDLE, 
 			      opFormUnion_createMiddle ((yyvsp[(2) - (3)].count)), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 18:
-
+#line 189 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (4)].ltok), OPF_BMMIDDLE, 
 			      opFormUnion_createMiddle ((yyvsp[(3) - (4)].count)), (yyvsp[(4) - (4)].ltok)); ;}
     break;
 
   case 19:
-
+#line 192 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (4)].ltok), OPF_BMIDDLEM, 
 			    opFormUnion_createMiddle ((yyvsp[(2) - (4)].count)), (yyvsp[(3) - (4)].ltok)); ;}
     break;
 
   case 20:
-
+#line 195 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(2) - (5)].ltok), OPF_BMMIDDLEM, 
 			    opFormUnion_createMiddle ((yyvsp[(3) - (5)].count)), (yyvsp[(4) - (5)].ltok)); ;}
     break;
 
   case 21:
-
+#line 198 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (2)].ltok), OPF_SELECT, 
 			    opFormUnion_createAnyOp ((yyvsp[(2) - (2)].ltok)), ltoken_undefined); ;}
     break;
 
   case 22:
-
+#line 201 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MSELECT, 
 			    opFormUnion_createAnyOp ((yyvsp[(3) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 23:
-
+#line 206 "signature.y"
     { (yyval.opform) = makeOpFormNode ((yyvsp[(1) - (3)].ltok), OPF_MMAP, 
 			    opFormUnion_createAnyOp ((yyvsp[(3) - (3)].ltok)), ltoken_undefined); ;}
     break;
 
   case 24:
-
+#line 211 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
   case 25:
-
+#line 213 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
   case 26:
-
+#line 215 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
   case 27:
-
+#line 219 "signature.y"
     { (yyval.count) = 0; ;}
     break;
 
   case 28:
-
+#line 221 "signature.y"
     { (yyval.count) = (yyvsp[(1) - (1)].count); ;}
     break;
 
   case 29:
-
+#line 225 "signature.y"
     { (yyval.count) = 1; ;}
     break;
 
   case 30:
-
+#line 227 "signature.y"
     { (yyval.count) = (yyvsp[(1) - (3)].count) + 1; ;}
     break;
 
   case 31:
-
+#line 231 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
   case 32:
-
+#line 233 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
   case 33:
-
+#line 237 "signature.y"
     { (yyval.signature) = makesigNode ((yyvsp[(2) - (3)].ltok), (yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 34:
-
+#line 241 "signature.y"
     { (yyval.ltokenList) = ltokenList_new (); ;}
     break;
 
   case 35:
-
+#line 243 "signature.y"
     { (yyval.ltokenList) = (yyvsp[(1) - (1)].ltokenList); ;}
     break;
 
   case 36:
-
+#line 247 "signature.y"
     { (yyval.ltokenList) = ltokenList_singleton ((yyvsp[(1) - (1)].ltok)); ;}
     break;
 
   case 37:
-
+#line 249 "signature.y"
     { (yyval.ltokenList) = ltokenList_push ((yyvsp[(1) - (3)].ltokenList), (yyvsp[(3) - (3)].ltok)); ;}
     break;
 
   case 38:
-
+#line 253 "signature.y"
     { 
 	  (yyval.ltok) = (yyvsp[(1) - (1)].ltok); 
 	  ltoken_setText ((yyval.ltok), processTraitSortId (ltoken_getText ((yyvsp[(1) - (1)].ltok)))); 
@@ -1759,13 +1759,13 @@ yyreduce:
     break;
 
   case 39:
-
+#line 260 "signature.y"
     { (yyval.ltok) = (yyvsp[(1) - (1)].ltok); ;}
     break;
 
 
 /* Line 1267 of yacc.c.  */
-
+#line 1711 "signature.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -1979,7 +1979,7 @@ yyreturn:
 }
 
 
-
+#line 263 "signature.y"
 
 
 # include "bison.reset"
